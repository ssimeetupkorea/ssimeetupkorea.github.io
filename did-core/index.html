<!DOCTYPE html>
<html>
<head>
  <title>
    탈중앙 식별자 Decentralized Identifiers (DIDs) v1.0
  </title>
  <meta content='text/html; charset=utf-8' http-equiv='Content-Type'><!--
    === NOTA BENE ===
    For the three scripts below, if your spec resides on dev.w3 you can check them
    out in the same tree and use relative links so that they'll work offline.
   -->

  <script class='remove'
    src='https://www.w3.org/Tools/respec/respec-w3c-common'>
  </script><!--script src='./respec-w3c-common.js' class='remove'></script-->

  <script class='remove' src="./common.js">
  </script>
  <script class="remove" type="text/javascript">
  var respecConfig = {
        wgPublicList: "public-did-wg",
        wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/117488/status",
        wg: "Decentralized Identifier Working Group",
        wgURI: "https://www.w3.org/2019/did-wg/",

    // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
    specStatus: "WD",

    // the specification's short name, as in http://www.w3.org/TR/short-name/
    shortName: "did-core",


    edDraftURI: "https://w3c.github.io/did-core/",

    // subtitle
    subtitle: "Core Data Model and Syntaxes",

    // if you wish the publication date to be other than today, set this
    //publishDate:  "2019-11-07",

    // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
    // and its maturity status
    // previousPublishDate:  "1977-03-15",
    // previousMaturity:  "WD",

    // extend the bibliography entries
    localBiblio: ccg.localBiblio,
    github: {
            repoURL: "https://github.com/w3c/did-core/",
            branch: "master"
    },
    includePermalinks: false,


    // editors, add as many as you like
    // only "name" is required
    editors: [{
        name: "Drummond Reed",
        url: "https://www.linkedin.com/in/drummondreed/",
        company: "Evernym",
        companyURL: "https://www.evernym.com/",
        w3cid: 3096
      },
      {
        name: "Manu Sporny",
        url: "http://manu.sporny.org/",
        company: "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/",
        w3cid: 41758
      },
      {
        name: "Markus Sabadello",
        url: "https://www.linkedin.com/in/markus-sabadello-353a0821",
        company: "Danube Tech",
        companyURL: "https://danubetech.com/",
        w3cid: 46729
      }
    ],

    // authors, add as many as you like.
    // This is optional, uncomment if you have authors as well as editors.
    // only "name" is required. Same format as editors.
    authors: [{
        name: "Drummond Reed",
        url: "https://www.linkedin.com/in/drummondreed/",
        company: "Evernym",
        companyURL: "https://www.evernym.com/",
        w3cid: 3096
      },
      {
        name: "Manu Sporny",
        url: "http://manu.sporny.org/",
        company: "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/",
        w3cid: 41758
      },
      {
        name: "Dave Longley",
        url: "",
        company: "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/",
        w3cid: 48025
      },
      {
        name: "Christopher Allen",
        url: "https://www.linkedin.com/in/christophera",
        company: "Blockchain Commons",
        companyURL: "https://www.BlockchainCommons.com",
        w3cid: 85560
      },
      {
        name: "Ryan Grant",
        url: "",
        company: "",
        companyURL: ""
      },
      {
        name: "Markus Sabadello",
        url: "https://www.linkedin.com/in/markus-sabadello-353a0821",
        company: "Danube Tech",
        companyURL: "https://danubetech.com/",
        w3cid: 46729
      }
    ]
    };
  </script>
  <style>
  pre .highlight {
    font-weight: bold;
    color: green;
  }
  pre .comment {
    color: SteelBlue;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  </style>
</head>
<body>
  <section id='abstract'>
    <p>
<a>탈중앙 식별자</a>(DIDs)란 검증가능하고 탈중앙화된 디지털 신원을 위한 새로운 형식의 식별자이다.  
이러한 새로운 식별자는 <a>DID 컨트롤러</a>가 DID의 제어권을 증명하고, 중앙화된 레지스트리, 신원 제공자, 인증기관 등으로부터 독립적으로 구현할 수 있도록 설계되었다. 
<a>DID</a>는 <a>DID 주체</a>와 관련된 URL로써, <a>DID 문서</a>라는 방식을 통해 해당 주체와 신뢰할 수 있는 상호작용을 가능하게하는 도구이다. 
<a>DID 문서</a>는 특정 DID를 어떻게 사용하는지에 대해 설명해 놓은 간단한 문서이다. 
각 <a>DID 문서</a>는 암호학적 요소, 검증 메소드, 서비스 엔드포인트 등으로 표현될 수 있다. 
해당요소들은 <a>DID 컨트롤러</a>가 DID의 통제권에 대한 증명을 가능하게 하는 메커니즘 집합을 제공한다. 
서비스 엔드포인트는 <a>DID 주체</a>와의 믿을 수 있는 상호작용을 가능하게 한다.
    </p>
    <p>
본 문서는 일반 데이터 모델, URL 형식, <a>DID</a>를 위한 일련의 작동방식, <a>DID 문서</a> 그리고 <a>DID 메소드</a>에 대해 명시하고 있다.
    </p>
  </section>

  <section id='sotd'>

    <p>
This specification is under active development and implementers are advised
against implementing the specification unless they are directly involved
with the W3C DID Working Group. There are use cases [[?DID-USE-CASES]] in active
development that establish requirements for this document.
    </p>

    <p>
At present, there exist
<a href="https://w3c-ccg.github.io/did-method-registry/#the-registry">40
experimental implementations</a> and a preliminary
<a href="https://github.com/w3c-ccg/did-test-suite/">test suite</a>
that will eventually determine whether or not implementations are conformant.
Readers are advised that Appendix <a href="#current-issues"></a> contains a
list of concerns and proposed changes that will most likely result in
alterations to this specification.
    </p>

    <p>
Comments regarding this document are welcome. Please file issues
directly on <a href="https://github.com/w3c/did-core/issues/">GitHub</a>,
or send them
to <a href="mailto:public-did-wg@w3.org">public-did-wg@w3.org</a> (
<a href="mailto:public-did-wg-request@w3.org?subject=subscribe">subscribe</a>,
<a href="https://lists.w3.org/Archives/Public/public-did-wg/">archives</a>).
    </p>

    <p>
Portions of the work on this specification have been funded by the
United States Department of Homeland Security's Science and Technology
Directorate under contracts HSHQDC-16-R00012-H-SB2016-1-002 and
HSHQDC-17-C-00019. The content of this specification does not
necessarily reflect the position or the policy of the U.S. Government
and no official endorsement should be inferred.
    </p>

    <p>
Work on this specification has also been supported by the Rebooting the
Web of Trust community facilitated by Christopher Allen, Shannon
Appelcline, Kiara Robles, Brian Weller, Betty Dhamers, Kaliya Young,
Kim Hamilton Duffy, Manu Sporny, Drummond Reed, Joe Andrieu, and
Heather Vescent.
    </p>
  </section>

  <section class="informative">
    <h1>
Introduction
    </h1>

    <p>
기존의 ID 관리 시스템(<a href="https://en.wikipedia.org/wiki/Identity_management">identity management</a>)은 기업의 디렉토리 서비스(<a href="https://en.wikipedia.org/wiki/Directory_service">directory services</a>), 인증 기관(,
<a href="https://en.wikipedia.org/wiki/Certificate_authority">certificate authorities</a>) 또는 도메인 등록 기관(<a href="https://en.wikipedia.org/wiki/Domain_name_registry">domain name registries</a>)과 같은 중앙 집중식 기관을 기반으로 한다. 암호학적 신뢰 검증의 관점에서 보면, 이들 중앙집중화 된 각 기관은 각각의 신뢰점(<a href="https://en.wikipedia.org/wiki/Trust_anchor">root of trust</a>)이 된다. 이러한 시스템들을 통해 ID 관리를 수행하려면 연합 ID 관리(<a href="https://en.wikipedia.org/wiki/Federated_identity">federated identity management</a>)를 구축해야 한다.
    </p>

    <p>
<a>블록체인</a>이라고도 하는 분산원장기술(DLT, <a>Distributed ledger Technology</a>)의 출현은 완전한 <a>탈중앙 ID 관리</a> 기회를 제공한다. 탈중앙 신원 시스템에서 개체(개인, 조직 및 기타 사항과 같은 제한이 없는 개별 식별 가능 단위)는 공유된 신뢰점을 자유롭게 사용할 수 있다. 전세계에 분산된 원장, 탈중앙 p2p 네트워크, 또는 유사한 기능을 가진 다른 시스템은 권한의 집중이나 단일 장애점을 도입하지 않고 신뢰점를 관리할 수 있는 수단을 제공한다. <a>DLTs</a>(분산원장기술들)과 <a>탈중앙 ID 관리</a>를 결합한 시스템에서는 누구나 분산되고, 신뢰점과 독립적인 자신의 식별자들을 생성하고 관리 할 수 있다.
    </p>

    <p>
개체들은 <a>탈중앙 식별자</a>(<a>DIDs</a>)에 의해 식별되며, 증명(예: 디지털 서명, 생체인식 등)을 통해 인증할 수 있다. <a>DIDs</a>는 <a>DID 문서들</a>(<a>DID documents</a>)을 참조한다. <a>DID 문서</a>는 <a>DID</a> 식별자와 주체가 상호 작용을 하기 위한 <a>서비스 엔드포인트</a>들을 포함한다. 프라이버시 디자인[<a href="https://en.wikipedia.org/wiki/Privacy_by_design">Privacy by
Design</a>] 가이드라인에 따라, 개체들은 신원, 페르소나, 그리고 컨텍스트들에 따라 구분하고 싶은 바람을 따라 자신이 원하는 만큼 많은 <a>DIDs</a>(<a>DID 문서</a>와 <a>서비스 엔드포인트</a>들이 포함된)를 가질 수 있다.
    </p>

    <p>
<a>DID 메소드</a>는 특정 <a>분산 원장</a> 또는 네트워크에서 <a>DID</a>와 관련된 <a>DID 문서</a>들을 생성, 읽기, 갱신, 그리고 비활성화 하는 메커니즘이다. <a>DID 메소드들</a>은 별도의 <a>DID 메소드</a> 규격을 사용하여 정의한다.
    </p>

    <p>
이 설계는 중앙 집중식 레지스트리와 공개키 기반구조(<a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">PKI, public key infrastructure</a>)의 중앙 집중식 인증 기관에 대한 식별자의 의존성을 제거 한다. <a>DID 레지스트리</a>가 <a>분산 원장</a>인 경우, 각 개체는 자체 인증 기관의 역할을 할 수 있으며, 이것을 분권화된 <a href="https://github.com/WebOfTrustInfo/rebooting-the-web-of-trust/blob/master/final-documents/dpki.pdf">PKI- DPKI(decentralized PKI)</a>라고 한다.
    </p>

    <p class="note">
참고로 <a>DID 메소드</a>들은 연합, 또는 중앙집중식 ID 관리 시스템에 등록된 식별자로도 사용될 수 있다. 이것을 위해, 모든 유형의 식별자 시스템에 <a>DIDs</a> 지원을 추가할 수 있다. 이로 인해 중앙집중, 연합 및 <a>탈중앙 식별자</a>들 사이의 상호 운용성이 형성 된다.
    </p>

    <p>
이 규격의 첫번째 목적은 일반적인 <a>DID 스키마</a>와 일반적인 <a>DID 문서</a>들에서 동작하는 명령어 집합을 모든 <a>DID 레지스트리</a>에 구현될 수 있도록 정의하는 것 이다. 이 규격의 두번째 목적은 <a>DID 메소드</a>를 위한 적합 요구조건(특정 <a>DID 레지스트리</a>를 위한 특정 <a>DID 스키마</a>와 특정 <a>DID 문서</a>에서 동작하는 명령어 세트를 정의하는 별도의 규격)을 정의하기 위함이다.
    </p>

    <p class="note">
개념적으로, 이 규격(Decentralized Identifiers)과 <a>DID 메소드</a> 규격의 관계는 IETF 일반 <a>URI</a> 규격([RFC3986])과 특정 <a>URI</a> 체계([IANA-URI-SCHEMES])([RFC7230]에 명시된 http:와 https: 체계)의 관계와 유사하다. IETF 일반 URN 규격([RFC8141]) 및 특정 URN 네임스페이스 정의([RFC4122]에 정의된 <a>UUID</a> URN 네임스페이스 등과 같은)의 관계와도 역시 유사하다. 
차이점은 <a>DID 메소드</a> 규격은 특정 <a>DID 스키마</a>를 정의하는 것 외에도, 적절한 <a>DID 레지스트리</a>에서 <a>DIDs</a>의 구별방법을 제공하거나, 비활성화하거나, <a>DID 문서</a>를 작성하는 방법을 명시한다는 것이다.
    </p>

    <p>
특정 <a>DID 메소드</a> 규격을 가진 일반 <a>DID</a> 규격의 계층적 설계는 <a>URI</a> 규격과 동일한 개념의 일부를 도입한다:
    </p>
      <ul>
        <li>
다른 <a>URI 체계</a>의 <a>URIs</a>가 상호운용되지 않는 것처럼, 다른 <a>DID 메소드</a>의 <a>DIDs</a>는 상호운용되지 않을 수 있다.
        </li>
        <li>
일부 브라우저가 특정 URI 체계만 지원하는 경우와 같이, 특정한 <a>DID 메소드</a>만을 지원하는 관계의 지원을 받기 위해 복수의 <a>DIDs</a>가 필요할 수 있다.
        </li>
        <li>
모든 브라우저가 동일한 URI 체계를 지원하지 않는 것과 같이, 모든 <a>DID 메소드</a>가 동일한 암호 체계를 지원하지는 않기 때문에, 다른 암호화 체계를 지원하기 위해 복수의 <a>DIDs</a>가 필요할 수 있다.
        </li>
        <li>
복수의 <a>DIDs</a>의 관리 및 그리고 어떤 <a>DID</a>가 어떤 관계에 속하는지 추적하는 것은, 어떤 웹 주소가 어떤 웹사이트에 속하는지 추적하거나 어떤 이메일 주소가 어떤 관계에 속하는지 추적하는 것과 유사한 문제를 야기한다.
        </li>
      </ul>

    <p>
<a>DID 메소드</a> 및 규격 목록은 [[DID-METHOD-REGISTRY]]를 참조하십시오.
      </p>

  <section class="informative">
    <h2>
A Simple Example
    </h2>

    <p>
<a>DID</a>는 3부분으로 구성된 간단한 문자열입니다.:
    </p>
      <ul>
        <li>
URL scheme identifier (<code>did</code>)
        </li>
        <li>
Identifier for the <a>DID method</a>
        </li>
        <li>
DID method-specific identifier.
        </li>
      </ul>

    <pre class="example nohighlight" title="A simple example of a decentralized identifier (DID)">
did:example:123456789abcdefghi
    </pre>

    <p>
위의 예제 <a>DID</a>는 <a>DID 문서</a>로 해석됩니다. <a>DID 문서</a>에는 <a>DID</a>를 제어하여 개체를 암호학적으로 인증하는 방법 및 개체와 상호 작용하는 데 사용할 수있는 서비스와 같이 <a>DID</a>와 관련된 정보가 포함되어 있다.
    </p>

    <pre class="example nohighlight" title="Minimal self-managed DID document">
{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:example:123456789abcdefghi",
  "authentication": [{
    <span class="comment">// used to authenticate as did:...fghi</span>
    "id": "did:example:123456789abcdefghi#keys-1",
    "type": "RsaVerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }],
  "service": [{
    <span class="comment">// used to retrieve Verifiable Credentials associated with the DID</span>
    "id":"did:example:123456789abcdefghi#vcs",
    "type": "VerifiableCredentialService",
    "serviceEndpoint": "https://example.com/vc/"
  }]
}
    </pre>
  </section>

  <section class="informative">
    <h2>
Design Goals
    </h2>

    <p>
<a>탈중앙 식별자들</a>은  [[?VC-DATA-MODEL]]과 같은 검증가능한 증명생태계와 같은 더 큰 시스템의 구성요소이며, 이 규격의 설계를 주도 했다. 이 절에는 이 규격의 기본 설계 목표가 요약되어 있다.
    </p>

    <table class="simple">
      <thead>
        <tr>
          <th>
Goal
          </th>
          <th>
Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
Decentralization
          </td>
          <td>
글로벌 고유 식별자, 공개 확인 키, <a>서비스 엔드포인트</a> 및 기타 메타 데이터의 등록을 포함한, 식별자 관리에서 중앙집중식 기관, 또는 단일실패점 요소를 제거해야 한다.
          </td>
        </tr>

        <tr>
          <td>
Control
          </td>
          <td>
주어진 개체, 인간과 비인간 모두에게 외부 기관에 의존하지 않고 디지털 식별자를 직접 제어 할 수있는 권한을 부여하십시오.
          </td>
        </tr>

        <tr>
          <td>
Privacy
          </td>
          <td>
개체가 속성 또는 기타 데이터의 최소, 선택적 및 점진적 공개를 포함하여 정보의 프라이버시를 제어 할 수 있도록한다.
          </td>
        </tr>

        <tr>
          <td>
Security
          </td>
          <td>
필요한 수준의 보증을 위해 <a>DID 문서</a>에 의존할 수 있도록 RP(relying parties)들에게 충분한 보안을 제공한다.
          </td>
        </tr>

        <tr>
            <td>
Proof-based
          </td>
          <td>
다른 개체와 상호작용할 때 <a>DID 주체</a>가 암호화 증명을 제공 할 수 있어야 한다.
          </td>
        </tr>

        <tr>
          <td>
Discoverability
          </td>
          <td>
다른 개체가 해당 개체에 대해 더 많이 학습하거나 상호 작용할 수 있도록 <a>DIDs</a>를 검색 할 수 있어야 한다.
          </td>
        </tr>

        <tr>
          <td>
Interoperability
          </td>
          <td>
<a>DID</a> 인프라는 상호운용성을 위해 설계된 기존 툴과 소프트웨어 라이브러리를 이용할 수 있도록 상호운용성 표준을 사용해야 한다.
          </td>
        </tr>

        <tr>
          <td>
Portability
          </td>
          <td>
시스템과 네트워크에 독립적이어야 하며 기업이 <a>DIDs</a> 및 <a>DID 메소드</a>를 지원하는 모든 시스템과 함께 디지털 식별자를 사용할 수 있도록 해야 한다.
          </td>
        </tr>

        <tr>
          <td>
Simplicity
          </td>
          <td>
기술을보다 쉽게 이해하고, 구현 및 배포 할 수 있도록 축소 된 간단한 기능을 선호해야 한다.
          </td>
        </tr>

        <tr>
          <td>
Extensibility
          </td>
          <td>
상호운용성(Interoperability), 이식성(Portability) 또는 단순성(Simplicity)을 크게 방해하지 않는 경우 가능한 확장할 수 있다.
          </td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h3>
Interoperability
    </h3>

    <p>
<a>DIDs</a>와 <a>DID 문서</a>의 구현 상호운용성은 규격에 부합하는 <a>DIDs</a> 및 <a>DID 문서</a>를 작성하고 분석할 수 있는 구현 능력을 평가하여 시험한다. <a>DID 메소드</a>의 상호운용성은 최소한 다음과 같이 최소 규격을 평가함으로써 결정된다.:
    </p>
      <ul>
        <li>
<a>DID 메소드</a> 이름은 겹치지 않고 유일해야 하며, <a>DID 메소드</a>의 기존용례와 모순된 사용은 하지 못한다.
        </li>
        <li>
요구되는 기능들이 지원되어져야 한다.
        </li>
        <li>
설명이 필요한 작업에 대해 설명되어야 한다.
        </li>
        <li>
규격은 독립적 구현을 위해 충분히 구체적이고 상세하고 완전해야 한다.
        </li>
        <li>
규격은 보안 및 프라이버시 고려사항을 기술하는 섹션을 포함해야 한다.
        </li>
      </ul>

    <p>
<a>DIDs</a> 및 <a>DID 문서</a>의 생산자와 소비자를 위한 상호운용성은 <a>DIDs</a> 및 <a>DID 문서</a>가 일치하는지 확인함으로써 보장된다. <a>DID 메소드</a> 규격에 대한 상호운용성은 각 <a>DID 메소드</a> 규격에 있는 세부사항에 의해 보장된다. 웹 브라우저가 알려진 모든 URIs 스키마를 구현할 필요가 없는 것처럼, <a>DIDs</a>와 함께 작동하는 호환 소프트웨어는 알려진 모든 <a>DID 메소드</a>를 구현할 필요가 없음을 이해해야한다. 그러나 지정된 <a>DID 메소드</a>의 모든 구현은 해당 메소드에 대해 상호운용성이 보장해야한다.
    </p>
  </section>

  </section>

  <section class="informative">
    <h1>
용어
    </h1>

    <div data-include="terms.html" data-oninclude="restrictReferences">
    </div>

  </section>

  <section class="informative">
    <h1>
Data Model
    </h1>

    <p>
이 섹션에서는 <a>decentralized identifier</a> 데이터 모델 개념,
특히, 키와 서비스 그리고 <a>DID 주체</a>가 <a>DID 문서</a>와 어떻게 관련되어 있는지에 대해 개략적으로 설명한다.</p>

    <p>
      데이터 모델을 확장하는 방법에 대한 자세한 내용은 
<a href="#extensibility"></a>을 참조한다.
    </p>

  <section>
    <h2>
Identifier
    </h2>

    <p>
      데이터 모델에서 식별자는 일반적으로 사람, 조직, 장치, 키, 서비스 및 사물의 특정 인스턴스를 식별하기 위해 사용된다. 
      식별자는 전형적인 URLs이며, 좀 더 일반적으로는 <a>URIs</a> 이다. 
      비 <a>URI</a> 기반 식별자는 데이터 모델이 이를 지원하기는 하지만, 
      다른 인터넷 기반 식별자와 함께 사용하기 쉽지 않기 때문에 권장되지 않는다.
    </p>
  </section>

  <section>
    <h2>
DID Document
    </h2>

   <p>
    <a>DID 문서</a>는 <a>decentralized identifier</a>(DID)와 관련된 리소스다. 
    <a>DID 문서</a>는 일반적으로 검증 메소드(public key 등) 및 <a>DID 컨트롤러</a>와 상호 작용 하는데 사용할 수 있는 서비스를 포함한다.
    </p>

    <p>
    <a>DID 문서</a>는 특정 구문에 따라 일련화된다(<a href="#did-document-syntax"></a> 참조). <a>DID</a> 자체는 <code>id</code> 속성에 포함되어 있다. 

    </p>

    <p>
      <a>DID 문서</a>에 존재할 수 있는 속성은 <a href="#did-documents"></a>에 자세히 설명되어 있다.
    </p>

    <p>
      <a>DID 문서</a>에 있는 속성은 해당 <a href="#did-methods"></a> 에 따라 업데이트 할 수 있다.
    </p>
  </section>

  <section>
    <h2>
Cryptographic Keys and Other Verification Methods
    </h2>

    <p>
      <a>DID 문서</a>는 <a>DID 주체</a> 또는 관련된 것들과의 상호작용을 인증 하거나 승인하는 데 사용할 수 있는 
      암호화 키 및 기타 검증 메소드를 나타낼 수 있다. 
      표현된 정보에는 디지털 서명을 확인하는 데 전역적으로 사용할 수 있는 
      명확한 식별자와 공개키 자료가 포함된다. 
      키의 상태 정보(예: 정지 또는 취소된 경우)나 하드웨어 기반 암호화 키인지 여부를 결정할 수 있는 속성 등 
      기타 정보를 표시할 수 있다.
    </p>

    <p> 
      암호화 키 자료와 관련하여, 공개키는 사용할 대상에 따라 
      <code>publicKey</code> 또는 <code>authentication</code> 속성을 사용하는 <a>DID 문서</a>에 포함될 수 있다. 

      각 공개키는 고유한 식별자(<code>id</code>), <code>type</code>, 그리고 <code>controller</code> 뿐만아니라 
      키 유형에 따라 다른 속성을 갖는다. 자세한 내용은 <a href="#public-keys"></a>를 참조한다.
    </p>
  </section>

      <p>
        이 규격은 DID 문서에서 공개키 자료를 표현하기 위한 형식의 수를 가능한 적게 제한하여 상호 운용성을 높이려고 노력한다. 
        구현자가 구현해야하는 형식이 적을수록 모든 형식을 지원할 가능성이 높다. 
        이 접근 방식은 구현의 용이성과 역사적으로 광범위하게 배포된 지원 형식간에 미묘한 균형을 유지한다. 
        이 규격에서 지원되는 특정 유형의 키 형식은 <a href="#public-keys"></a>에 나와 있다.
      </p>
    </section>

    <section>
      <h2>
Services
    </h2>

    <p>
      <a>서비스 엔드포인트</a>는 <a>DID 주체</a> 또는 관련 개체와 통신할 수 있는 방법을 나타내기 위해 <a>DID 문서</a>에서 사용된다. 
      <a>DID 문서</a>에 나열된 서비스에는 개인 정보 보호 메시징 서비스에 대한 정보 
      또는 소셜 미디어 계정, 개인 웹사이트, 이메일 주소와 같은 공개 정보가 포함될 수 있다. 
      서비스와 관련된 메타 데이터는 보통 서비스마다 다르다. 예를 들어, 암호화된 메시징 서비스와 관련된 메타 데이터는 
      메시지는 보내기 전에 암호화된 링크를 시작하는 방법을 나타낼 수 있다. 
    </p>

    <p>
      서비스에 대한 포인터는 <code>service</code> 속성을 사용하여 표현한다. 
      각 서비스에는 고유한 <code>id</code> 와 <code>type</code> 뿐만 아니라, <a>URI</a> 또는 
      서비스를 설명하는 추가적 특성이 있는 <code>serviceEndpoint</code> 가 있다. 
    </p>

    <p>
      자세한 내용은 <a href="#service-endpoints"></a>를 참조한다.
    </p>
  </section>

  </section>

  <section class="normative">
    <h1>
탈중앙 식별자 (DIDs)
    </h1>
    <p>
전역에서 유일한 <a>탈중앙 식별자</a>는 새로운 개념은 아니다. 
<a>범용고유식별자</a>(UUIDs)는 1980년대에 처음 개발되었고 향후 개방소프트웨어재단의 <a href="https://en.wikipedia.org/wiki/Distributed_Computing_Environment">분산 컴퓨팅 환경</a>에서 표준 기능이 되었다. 
<a>UUID</a>는 충돌 가능성이 무한히 작을 정도로 충분한 엔트로피를 가진 128bit 값을 생성하는 알고리즘을 통해 
중앙화된 등록 서비스 없이도 글로벌 유일성을 가질 수 있다. 
<a>UUID</a>는 [RFC4122]에서 URN(Unified Resource Name)의 특정 형식으로써 공식 명시되어 있다.
    </p>

    <p>
<a>DID</a>는 아래 사항을 제외하고는 <a>UUID</a>와 유사하다:
    </p>
      <ul>
        <li>
URL과 동일하게, 주체에 대해 설명하는 일반 자원을 주소 분해(Resolve)하거나 역참조(Dereferenced)한다. 
더 상세한 내용은 섹션 <a href="#did-documents">5. DID Documents</a> 참조.
        </li>
        <li>
URL을 역참조 할 경우 반환되는 리소스와는 다르게, <a>DID 문서</a>는 일반적으로 <a>DID 주체</a>에 대한 인증을 가능하게 하는 암호학적 요소를 포함하고 있다.
        </li>
      </ul>

    <section>
      <h2>
일반 DID 구문
      </h2>

      <p>
일반 <a>DID 스키마</a>는 [[!RFC3986]]을 준수하는 URI 체계이다.
<a>DID 스키마</a>는 <a>DID URL</a> 체계 및 권한 구성 요소에만 특화되어 있다. 
<code>path-abempty</code>, <code>query</code>, 그리고 <code>fragment</code> 구성 요소들은 [[!RFC3986]]에서 정의된 ABNF 규칙과 동일하다.
      </p>

      <p class="note">
<a>DID</a>라는 용어는 아래와 같이 ABNF의 <code>did</code> 규칙을 따르는 URI만을 의미한다. 
<a>DID</a>는 <a>DID 주체</a>를 항상 식별한다. 
<a>DID URL</a>이라는 용어는 <code>did-url</code> 규칙에 따라 정의되는데, <a>DID</a>로 시작하고 그 뒤에 하나 이상의 구성 요소가 추가되는 URL을 나타낸다. 
<a>DID URL</a>은 찾아야 할 리소스를 항상 식별한다.
      </p>

      <p>
아래는 <code>ALPHA</code>와 <code>DIGIT</code>을 정의하는 [[!RFC5234]] 구문을 사용하는 ABNF 정의에 대한 것이다. 
ABNF에서 정의되지 않은 다른 모든 규칙 이름들은 RFC3986에 정의되어 있다.
      </p>

      <pre class="nohighlight">
did                = "did:" method-name ":" method-specific-id
method-name        = 1*method-char
method-char        = %x61-7A / DIGIT
method-specific-id = *idchar *( ":" *idchar )
idchar             = ALPHA / DIGIT / "." / "-" / "_"
did-url            = did *( ";" param ) path-abempty [ "?" query ]
                     [ "#" fragment ]
param              = param-name [ "=" param-value ]
param-name         = 1*param-char
param-value        = *param-char
param-char         = ALPHA / DIGIT / "." / "-" / "_" / ":" /
                     pct-encoded
      </pre>

      <p class="issue" data-number="34">
The grammar currently allows an empty <code>method-specific-id</code>,
e.g., <code>did:example:</code> would be a valid <a>DID</a> that could identify
the <a>DID method</a> itself.
      </p>

    </section>

    <section>
      <h2>
메소드 특화 구문
      </h2>

      <p>
<a>DID 메소드</a> 명세는 반드시 <code>method-name</code>과  <code>method-specific-id</code> 구문을 정의함으로써 일반 DID 구문을 추가로 제한해야 한다.
더 상세한 내용은 섹션 <a href="#did-methods">7. DID Methods</a> 참조.
      </p>
    </section>

    <section>
      <h2>
일반 DID 매개변수 이름
      </h2>

      <p>
<a>DID URL</a> 구문은 matrix parameter 구문([[MATRIX-URIS]])을 기반의 매개변수를 위한 간단하고 일반화 된 포멧을 지원한다. 
위의 ABNF는 매개변수 이름에 대해 어떠한 것도 특정하지 않는다 (<code>param-name</code> 규칙)
      </p>
      <p>
일부 일반 DID 매개변수 이름(예를들면, 서비스 선택을 위한)은 어떠한 특정 <a>DID 메소드</a>와 완전히 독립적이어야 하며, 
반드시 모든 <a>DID</a>와 동일하게 작동해야만 한다. 
그 외(예를들면, 버전관리를 위한)는 특정 <a>DID 메소드</a>에 의해 지원될 수 있지만, 
반드시 <a>DID 메소드</a>가 그것을 지원하는 방식으로 동일하게 작동해야만 한다.
      </p>
      <p>
메소드에 완전히 특화된 매개변수 이름은 <a href="#method-specific-did-parameter-names">
4.4 Method-Specific DID Parameter Names</a>에서 설명하고 있다.
      </p>
      <p>
아래 표는 일반 DID 매개변수 이름 세트를 정의하고 있다:
      </p>
      <table class="simple">
        <thead>
          <tr>
            <th>
일반 DID 매개변수 이름
            </th>
            <th>
설명
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
<code>hl</code>
            </td>
            <td>
[HASHLINK]에 명시된, 무결성 보호를 추가하기 위한 <a>DID 문서</a>의 자원 해시 
            </td>
          </tr>
          <tr>
            <td>
<code>service</code>
            </td>
            <td>
서비스 ID를 통해 DID 문서로 부터 서비스를 식별
            </td>
          </tr>
          <tr>
            <td>
<code>version-id</code>
            </td>
            <td>
해석할 <a>DID 문서</a>의 특정 버전을 식별 (버전 ID는 순차적이거나 <a>UUID</a>이거나 메소드에 특화될 수 있음.
이 매개변수는 모든 <a>DID 메소드</a>에서 지원하지 않을 수 있음에 주의
            </td>
          </tr>

          <tr>
            <td>
<code>version-time</code>
            </td>
            <td>
해석할 <a>DID 문서</a>의 특정 버전 타임스탬프를 식별. 즉, 특정 시간의 <a>DID</a>에 대해 <a>DID 문서</a>가 유효하다는 것을 의미.
이 매개변수는 모든 <a>DID 메소드</a>에서 지원하지 않을 수 있음에 주의
            </td>
          </tr>
        </tbody>
      </table>

      <p>
위 매개변수들을 위한 정확한 처리 규칙은 [[DID-RESOLUTION]]에 명시되어 있다.
      </p>

      <p class="note">
DID URL에 포함되지는 않지만 <a>DID 리졸버</a>에 <em>대역외(Out-of-band)</em>로 전달하는 추가적인 매개변수나 옵션이 있을 수 있다. 
예를들면, Resolution 프로토콜 혹은 다른 어떤 메커니즘을 사용하는 것이다. 
이러한 옵션은 캐싱(Caching) 또는 기대하는 Resolution 결과에 대한 형식을 제어할 수도 있다. 
이것은 HTTP와 유사하게 캐싱 또는 결과 형식이 HTTP URL의 일부가 아닌 HTTP 헤더에 표현되는 것과 같다.
중요한 구별점은 <a>DID URL</a>의 일부가 아닌 DID 매개변수는 어떠한 자원이 식별되는지를 지정하는 반면, 
<a>DID URL</a>의 일부가 아닌 <a>DID 리졸버</a> 옵션은 해당 자원이 어떻게 역참조하는지를 제어한다는 점이다.
      </p>
    </section>

    <section>
      <h2>
Method-Specific DID Parameter Names
      </h2>

      <p>
A <a>DID method</a> specification MAY specify additional method-specific
parameter names. A method-specific parameter name MUST be prefixed by the method
name, as defined by the <code>method-name</code> rule.
      </p>

      <p>
For example, if the method <code>did:foo:</code> defines the parameter bar, the
parameter name must be <code>foo:bar</code>. An example <a>DID URL</a> using
this method and this method-specific parameter would be as shown below.
      </p>

      <pre class="example nohighlight">
did:foo:21tDAKCERh95uGgKbJNHYp;foo:bar=high
      </pre>

      <p class="issue" data-number="35">
Consider using kebab-case style instead of colon separator,
e.g., <code>foo-bar</code> instead of <code>foo:bar</code>.
      </p>

      <p>
A method-specific parameter name defined by one <a>DID method</a> MAY be used by
other <a>DID methods</a>.
      </p>

      <pre class="example nohighlight">
did:example:21tDAKCERh95uGgKbJNHYp;foo:bar=low
      </pre>

      <p>
Method-specific parameter names MAY be combined with generic parameter names in
any order.
      </p>

      <pre class="example nohighlight">
did:example:21tDAKCERh95uGgKbJNHYp;service=agent;foo:bar=high
      </pre>

      <p>
Both <a>DID method</a> namespaces and method-specific parameter namespaces MAY
include colons, so they might be partitioned hierarchically, as defined by a
<a>DID method</a> specification. The following example <a>DID URL</a>
illustrates both.
      </p>

      <pre class="example nohighlight">
did:foo:baz:21tDAKCERh95uGgKbJNHYp;foo:baz:hex=b612
      </pre>
    </section>

      <p class="issue" data-number="36">
Review what exactly we want to say about method-specific parameters
defined by one method but used in a <a>DID URL</a> with a different method.
Also discuss hierarchical method namespaces in DID parameter names.
      </p>

    <section>
      <h2>
Path
      </h2>

      <p>
A generic <a>DID path</a> is identical to a URI path and MUST conform to the
<code>path-abempty</code> ABNF rule in [[!RFC3986]]. A <a>DID path</a> SHOULD be
used to address resources available through a <a>service endpoint</a>. For more
information, see Section <a href="#service-endpoints"></a>.
      </p>

      <p>
A specific <a>DID scheme</a> MAY specify ABNF rules for <a>DID paths</a> that
are more restrictive than the generic rules in this section.
      </p>

      <pre class="example nohighlight">
did:example:123456/path
      </pre>
    </section>

    <section>
      <h2>
Query
      </h2>

      <p>
A generic <a>DID query</a> is identical to a URI query and MUST conform to the
<code>query</code> ABNF rule in [[!RFC3986]]. A <a>DID query</a> SHOULD be used
to address resources available through a <a>service endpoint</a>. For more
information, see Section <a href="#service-endpoints"></a>.
      </p>

      <p>
A specific <a>DID scheme</a> MAY specify ABNF rules for <a>DID queries</a> that
are more restrictive than the generic rules in this section.
      </p>

      <pre class="example nohighlight">
did:example:123456?query=true
      </pre>
    </section>

    <section>
      <h2>
Fragment
      </h2>

      <p>
A generic <a>DID fragment</a> is identical to a URI fragment and MUST conform to
the <code>fragment</code> ABNF rule in [[RFC3986]]. Implementers are strongly
discouraged from using a <a>DID fragment</a> for anything other than a
method-independent reference into the <a>DID document</a> to identify a
component of a <a>DID document</a> (for example, a unique
<a>public key description</a> or <a>service endpoint</a>). To resolve this
reference, the complete <a>DID URL</a> including the <a>DID fragment</a> MUST be
used as input to the <a>DID URL</a> dereferencing algorithm for the
target component in the <a>DID document</a> object. For more information, see
[[DID-RESOLUTION]].
      </p>

      <p>
A specific <a>DID scheme</a> MAY specify ABNF rules for <a>DID fragments</a>
that are more restrictive than the generic rules in this section.
      </p>

      <p>
Implementations need not rely on graph-based processing of <a>DID documents</a>
to locate metadata contained in the <a>DID document</a> when the <a>DID</a>
includes a <a>DID fragment</a>. Tree-based processing can be used instead.
      </p>

      <p>
Implementations SHOULD NOT prevent the use of <a>JSON Pointer</a>
([[!RFC6901]]).
      </p>

      <pre class="example nohighlight">
did:example:123456#oidc
      </pre>
    </section>

    <section>
      <h2>
Normalization
      </h2>

      <p>
For the broadest interoperability, make <a>DID</a> normalization as simple and
universal as possible:
      </p>
        <ul>
          <li>
The <a>DID scheme</a> name MUST be lowercase.
          </li>

          <li>
The <a>DID method</a> name MUST be lowercase.
          </li>

          <li>
Case sensitivity and normalization of the value of the
<code>method-specific-id</code> rule in Section
<a href="#generic-did-syntax"></a> MUST be defined by the governing
<a>DID method</a> specification.
          </li>
        </ul>
    </section>

    <section>
      <h2>
Persistence
      </h2>

      <p>
A <a>DID</a> is expected to be persistent and immutable. That is, a <a>DID</a>
is bound exclusively and permanently to its one and only subject. Even after a
<a>DID</a> is deactivated, it is intended that it never be repurposed.
      </p>

      <p>
Ideally, a <a>DID</a> would be a completely abstract decentralized identifier
(like a <a>UUID</a>) that could be bound to multiple underlying
<a>DID registries</a> over time, thus maintaining its persistence independent of
any particular system. However, registering the same identifier on multiple
<a>DID registries</a> introduces extremely hard entityship and
<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types%23SOA">start-of-authority</a>
(SOA) problems. It also greatly increases implementation complexity for
developers.
      </p>

      <p>
To avoid these issues, it is RECOMMENDED that <a>DID method</a> specifications
only produce <a>DIDs</a> and <a>DID methods</a> bound to strong, stable
<a>DID registries</a> capable of making the highest level of commitment to
persistence of the <a>DID</a> and <a>DID method</a> over time.
      </p>

      <p class="note">
Although not included in this version, future versions of this specification
might support a <a>DID document</a> <code>equivID</code> property to establish
verifiable equivalence relations between <a>DIDs</a> representing the same
subject on multiple <a>DID registries</a>. Such equivalence relations can
produce the practical equivalent of a single persistent abstract <a>DID</a>. For
more information, see Section <a href="#future-work"></a>.
      </p>
    </section>
  </section>

  <section class="normative">
    <h1>
DID Documents
    </h1>

    <p>
      <a>DID</a>는 <a>DID 문서</a>를 가리킨다. 
      <a>DID 문서</a>들은 <a href="#data-model"></a>을 직렬화 한 것이다. 
      이번 섹션에서는 <a>DID 문서</a>의 속성과 이 속성들이 필수인지 옵션인지를 정의한다.
    </p>

    <section>
      <h2>Contexts</h2>

        <p>
          두 개의 소프트웨어 시스템이 데이터를 교환해야 하는 경우 
          두 시스템이 이해할 수 있는 용어와 프로토콜을 사용해야 한다. 
          <code>@context</code> 속성은 동일한 DID 문서에서 작동하는 두 시스템이 서로 동의하는 용어를 사용하도록 한다.
        </p>

        <p>
          <a>DID 문서</a> 는 반드시 <code>@context</code> 속성을 포함해야 한다.
        </p>

        <p class="note" title="The JSON-LD Context">
          <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD Context</a>에 대한 
          자세한 정보는 [[!JSON-LD]] 사양에서 확인할 수 있다.
        </p>

        <dl>
          <dt><dfn>@context</dfn></dt>
          <dd>
            <code>@context</code> 속성의 값은 반드시 하나 이상의 <a>URIs</a> 여야 하며, 
            여기서 첫 번째 <a>URI</a>의 값은 <code>https://www.w3.org/ns/did/v1</code> 이다. 
            둘 이상의 <a>URI</a>가 제공될 경우, <a>URIs</a>는 반드시  순서있는 배열로 해석되어야 한다. 
            <a>URIs</a>를 역 참조하여 컨텍스트에 대한 기계 판독 가능한 정보가 포함된 문서를 생성 하는 것이 좋다. 
          </dd>
        </dl>

      <p>
Example:
      </p>

      <pre class="example nohighlight">
{
  "@context": "https://www.w3.org/ns/did/v1"
}
</pre>
      <p>
        <a>DID 문서</a> 규격은 자체 JSON-LD 컨텍스트를 정의 할 수 있다. 
        하지만 메소드를 올바르게 구현하는 데 필요한 경우가 아니면 새 컨텍스트를 정의하는 것은 권장하지 않는다. 
        메소드별 컨텍스트는 일반 <a>DID</a> 컨텍스트에 정의된 용어를 재정의하면 안된다.
      </p>
    </section>

    <section>
      <h2>
DID Subject
      </h2>

      <p>
The <a>DID subject</a> is denoted with the <code>id</code> property.
This is the entity that the <a>DID document</a> is about, i.e.,
it is the entity identified by the <a>DID</a> and described by the <a>DID document</a>.
      </p>

      <p>
<a>DID documents</a> MUST include the <code>id</code> property.
      </p>

      <dl>
          <dt><dfn>id</dfn></dt>
          <dd>
The value of <code>id</code> MUST be a single valid <a>DID</a>.
          </dd>
      </dl>

      <p>
Example:
      </p>

      <pre class="example nohighlight">
{
  "id": "did:example:21tDAKCERh95uGgKbJNHYp"
}
      </pre>
      <p class="note">
<a>DID method</a> specifications can create intermediate representations of
a <a>DID document</a> that do not contain the <code>id</code> key, such as
when a <a>DID resolver</a> is performing resolution. However, the fully
resolved <a>DID document</a> always contains a valid <code>id</code> property.
The value of <code>id</code> in the resolved <a>DID document</a> is expected
to match the <a>DID</a> that was resolved.
      </p>
    </section>
    <!-- section>
      <h2>Delegates</h2>
        <p class="issue">
The way that Delegates are handled is changing. The feature is still supported,
but via the `authorizationCapability` field rather than the more specialized
`guardian` field.
        </p>
        <p>
A delegate is an entity, such as a parent or aid organization, that creates and
maintains a <a>DID document</a> for a dependent who is not in a position to hold
or control authentication credentials (e.g., cryptographic keys).
        </p>
        <p>
The rules for a delegate are:
        </p>
        <ol start="1">
          <li>
A <a>DID document</a> that includes an
<code>authentication</code> field
(Section <a href="#authentication"></a>) MAY list one or
more delegates via the <code>authorizationCapability</code> field.
          </li>
          <li>
A <a>DID document</a> that does not include an
<code>authentication</code> MUST have a delegate.
          </li>
          <li>
The <code>authorizationCapability</code> field must contain a capability for the
delegate that includes <code>UpdateDidDocument</code> as the capability,
the <a>DID</a> of the delegate as the <code>entity</code>, and MAY include a
more specific set of <code>authentication</code>s that the
delegate MAY use to authenticate when updating the <a>DID document</a>.
          </li>
          <li>
The delegate <a>DID</a> MUST resolve to a <a>DID document</a> that has a
<code>authentication</code> property containing at least one value,
i.e., the delegate relationships must not be nested.
          </li>
        </ol>
        <p>
Example:
        </p>
<pre class="example nohighlight" title="Basic DID document">
{
"@context": "https://www.w3.org/ns/did/v1",
"id": "did:example:123456789abcdefghi",
"authorizationCapability": [{
  // this entity is a delegate and may update any field in this
  // DID document using any authentication mechanism understood
  // by the ledger
  "permission": "UpdateDidDocument",
  "entity": "did:example:zxyvwtrkpn987654321"
}],
"authentication": [{
  // this biometric can be used to authenticate as did:...fghi
  "type": "PseudonymousBiometricTemplate2017",
  "biometricService": "https://example.com/authenticate",
  "biometricTemplateShard": "Mjk4MzQyO...5Mzg0MDI5Mwo="
}],
"service": [{
  "type": "ExampleService",
  "serviceEndpoint": "https://example.com/endpoint/8377464"
}]
}
</pre>
    </section -->

    <section>
      <h2>
Public Keys
      </h2>

      <p>
Public keys are used for digital signatures, encryption and other
cryptographic operations, which in turn are the basis for purposes
such as authentication (see Section <a href="#authentication"></a>)
or establishing secure communication with <a>service endpoints</a>
(see Section <a href="#service-endpoints"></a>). In addition, public
keys may play a role in authorization mechanisms of <a>DID</a> CRUD
operations (see Section <a href="#did-operations"></a>), which can be
defined by <a>DID method</a> specifications.
      </p>

      <p>
A <a>DID document</a> MAY include a <code>publicKey</code> property. If so:
      </p>

      <dl>
          <dt><dfn>publicKey</dfn></dt>
          <dd>
The value of the <code>publicKey</code> property MUST be an array of
public key objects. Each public key object MUST have the
<code>type</code>, <code>controller</code>, and specific public key
properties, and SHOULD have an <code>id</code> property. The object
MAY include additional properties.
          </dd>
      </dl>

      <p>
The value of the <code>id</code> property (if present) MUST be a URI. The array
of public keys MUST NOT contain multiple entries with the same
<code>id</code>. A <a>DID document</a> processor MUST produce an error in that
case.
      </p>

      <p>
The value of the <code>type</code> property MUST be exactly one public key value
(see available key types in Appendix <a href="#registries"></a>).
      </p>

      <p>
The value of the <code>controller</code> property, which identifies the
controller of the corresponding private key, MUST be a valid DID.
      </p>

      <p>
All public key properties MUST be from the Linked Data Cryptographic Suite Registry.
A registry of key types and formats is available in Appendix <a href="#registries"></a>
      </p>

      <p>
If a public key does not exist in the <a>DID document</a>, it MUST be
assumed the key has been revoked or is invalid. The <a>DID document</a> MAY
contain revoked keys. A <a>DID document</a> that contains a revoked key MUST
also contain or refer to the revocation information for the key (e.g.,
a revocation list). Each <a>DID method</a> specification is expected to
detail how revocation is performed and tracked.
      </p>

      <p>
All public key formats MUST be expressed in either JSON Web Key (JWK)
format using the <code>publicKeyJwk</code> property or one of the
formats listed in the table below. Public key expression MUST NOT use any other key format.
      </p>

      <p class="issue">
The Working Group is still debating whether the base encoding format used
will be Base58 (Bitcoin) [[BASE58]], base64url [[RFC7515]] or base16 (hex) [[RFC4648]]. The entries in the
table below currently assume PEM and Base58 (Bitcoin), but may change to base64url and/or base16 (hex) once
the group achieves consensus on this particular issue.
      </p>


      <p class="issue">
The Working Group is still debating whether secp256k1 Schnorr public key values
will be elaborated upon in this specification and if so, how they will be
expressed and encoded.
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>
Key&nbsp;Type
            </th>
            <th>
Support
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
RSA
            </td>
            <td>
RSA public key values MUST either be encoded as a JWK or be encoded in
Privacy Enhanced Mail (PEM) format using the <code>publicKeyPem</code> property.
            </td>
          </tr>
          <tr>
            <td>
ed25519
            </td>
            <td>
Ed25519 public key values MUST either be encoded as a JWK or be encoded as
the raw 32-byte public key value in Base58 Bitcoin format using the
<code>publicKeyBase58</code> property.
            </td>
          </tr>
          <tr>
            <td>
secp256k1-koblitz
            </td>
            <td>
Secp256k1 Koblitz public key values MUST either be encoded as a JWK or be
encoded as the raw 33-byte public key value in Base58 Bitcoin format using the
<code>publicKeyBase58</code> property.
            </td>
          </tr>
          <tr>
            <td>
secp256r1
            </td>
            <td>
Secp256r1 public key values MUST either be encoded as a JWK or be encoded as
the raw 32-byte public key value encoded in Base58 Bitcoin format using the
<code>publicKeyBase58</code> property.
            </td>
          </tr>
          <tr>
            <td>
Curve25519
            </td>
            <td>
Curve25519 (also known as X25519) public key values MUST either be encoded as a JWK or be encoded as
the raw 32-byte public key value in Base58 Bitcoin format using the
<code>publicKeyBase58</code> property.
            </td>
          </tr>
        </tbody>
      </table>

      <p>
Example:
      </p>

      <pre class="example nohighlight" title="Various public keys">
{
  "@context": ["https://www.w3.org/ns/did/v1", "https://w3id.org/security/v1"],
  "id": "did:example:123456789abcdefghi",
  <span class="comment">...</span>
  "publicKey": [{
    "id": "did:example:123456789abcdefghi#keys-1",
    "type": "RsaVerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }, {
    "id": "did:example:123456789abcdefghi#keys-2",
    "type": "Ed25519VerificationKey2018",
    "controller": "did:example:pqrstuvwxyz0987654321",
    "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
  }, {
    "id": "did:example:123456789abcdefghi#keys-3",
    "type": "Secp256k1VerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyHex": "02b97c30de767f084ce3080168ee293053ba33b235d7116a3263d29f1450936b71"
  }],
  <span class="comment">...</span>
}
</pre>
      <p>
A key MAY be <em>embedded</em> or <em>referenced</em> in a <a>DID
document</a>. For example, the <code>authentication</code> property
may refer to keys in both ways:
      </p>

      <pre class="example nohighlight" title="Various public keys">
{
<span class="comment">...</span>

  "authentication": [
    <span class="comment">// this key is referenced, it may be used for more than one proof purpose</span>
    "did:example:123456789abcdefghi#keys-1",
    <span class="comment">// this key is embedded and may *only* be used for authentication</span>
    {
      "id": "did:example:123456789abcdefghi#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:example:123456789abcdefghi",
      "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
    }
  ],

<span class="comment">...</span>
}
</pre>
      <p>
The algorithm to use when processing a <code>publicKey</code>
property in a <a>DID document</a> is:
      </p>

      <ol class="algorithm">
        <li>
Let <em>value</em> be the data associated with the
        <code>publicKey</code> property and initialize <em>result</em> to
        <code>null</code>.
        </li>

        <li>
If <em>value</em> is an object, the key material is embedded. Set
        <em>result</em> to <em>value</em>.
        </li>

        <li>
If <em>value</em> is a string, the key is included by reference.
Assume <em>value</em> is a URL.
          <ol>
            <li>
Dereference the URL and retrieve the <code>publicKey</code>
properties associated with the URL (e.g., process the
<code>publicKey</code> property at the top-level of the
dereferenced document).
            </li>

            <li>
Iterate through each public key object.
              <ol>
                <li>
If the <code>id</code> property of the object matches
<em>value</em>, set <em>result</em> to the object.
                </li>
              </ol>
            </li>
          </ol>
        </li>

        <li>
If <em>result</em> does not contain at least the <code>id</code>,
<code>type</code>, and <code>controller</code> properties as well as any
mandatory public cryptographic material, as determined by the
<em>result</em>'s <code>type</code> property, throw an error.
        </li>
      </ol>

      <p class="note">
While the <code>controller</code> field may seem redundant in some of the
examples above, keys may be expressed in a <a>DID document</a> where the
controller is described in another <a>DID document</a>. Linked Data Proof
libraries typically expect the <code>controller</code> field to always
exist and may throw an exception if it is missing. Furthermore, per
the requirement that <a>DID documents</a> be interpretable as either a graph
or a tree, a default <code>controller</code> field cannot be inferred by
using a key's position in a tree.
      </p>

      <p class="note">
Caching and expiration of the keys in a <a>DID document</a> is entirely the
responsibility of <a>DID resolvers</a> and other clients. See Section
<a href="#did-resolvers"></a>.
      </p>
    </section>

    <section>
      <h2>
Authentication
      </h2>

      <p>
Authentication is the mechanism by which <a>DID controllers</a> can
cryptographically prove that they are associated with a <a>DID</a>. For more
information, see Section <a href="#binding-of-identity"></a>. Note that
Authentication is separate from Authorization because <a>DID controllers</a>
might wish to enable others to update their <a>DID document</a> (for example, to
assist with key recovery, as discussed in Section
<a href="#key-revocation-and-recovery"></a>) without enabling them to prove
control (and thus be able to impersonate the <a>DID controller(s)</a>).
      </p>

      <p>
A <a>DID document</a> MAY include an <code>authentication</code>
property. If so:
      </p>
      <dl>
          <dt><dfn>authentication</dfn></dt>
          <dd>
The value of the <code>authentication</code> property SHOULD be
an array of verification methods. Each verification method MAY be embedded
or referenced. An example of a verification method is a public key (see
Section <a href="#public-keys"></a>).
          </dd>
      </dl>

      <p>
Example:
      </p>

      <pre class="example nohighlight" title="Authentication field containing three verification methods">
{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:example:123456789abcdefghi",
  <span class="comment">...</span>
  "authentication": [
    <span class="comment">// this method can be used to authenticate as did:...fghi</span>
    "did:example:123456789abcdefghi#keys-1",
    <span class="comment">// this method can be used to authenticate as did:...fghi</span>
    "did:example:123456789abcdefghi#biometric-1",
    <span class="comment">// this method is *only* authorized for authentication, it may not</span>
    <span class="comment">// be used for any other proof purpose, so its full description is</span>
    <span class="comment">// embedded here rather than using only a reference</span>
    {
      "id": "did:example:123456789abcdefghi#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:example:123456789abcdefghi",
      "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
    }
  ],
  <span class="comment">...</span>
}
</pre>
    </section>

    <section>
      <h2>
Authorization and Delegation
      </h2>

      <p>
Authorization is the mechanism used to state how operations may be
performed on behalf of the <a>DID subject</a>. Delegation is the
mechanism that the subject uses to authorize others to act
on their behalf. Note that Authorization is separate from
Authentication as explained in Section <a href="#authentication"></a>.
This is particularly important for key
recovery in the case of key loss, when the subject no longer has
access to their keys, or key compromise, where the <a>DID controller</a>'s
trusted third parties need to override malicious activity by an attacker. See
Section <a href="#security-considerations"></a>.
      </p>

      <p>
Each <a>DID method</a> MUST define how authorization and delegation are
implemented, including any necessary cryptographic operations.
      </p>

      <p>
There are at least two suggested methods for implementing
Authorization and Delegation, which may be layered:
      </p>

      <ol>
        <li>
A <a>DID registry</a> could implement a coarse
grained <code>controller</code> pattern by enabling <a>DID documents</a> to
express the <a>DID</a> of another <a>DID controller</a> that controls it, or
additionally,
        </li>

        <li>
A <a>DID registry</a> could implement a
Capabilities-based approach that enables further fine-grained control
of authorization and delegation.
        </li>
      </ol>

      <p>
Example:
      </p>

      <pre class="example nohighlight" title="DID document with a controller property">
{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:example:123456789abcdefghi",
  "controller": "did:example:bcehfew7h32f32h7af3",
  "service": [{
    <span class="comment">// used to retrieve Verifiable Credentials associated with the DID</span>
    "type": "VerifiableCredentialService",
    "serviceEndpoint": "https://example.com/vc/"
  }]
}
        </pre>
    </section>

    <section>
      <h2>
Service Endpoints
      </h2>

      <p>
One of the primary purposes of a <a>DID document</a> is to enable
discovery of <a>service endpoints</a>. A <a>service
endpoint</a> can be any type of service the <a>DID subject</a> wishes to
advertise, including <a>decentralized identity management</a> services for
further discovery, authentication, authorization, or interaction.
      </p>

      <p>
A <a>DID document</a> MAY include a <code>service</code> property. If so:
      </p>

      <dl>
          <dt><dfn>service</dfn></dt>
          <dd>
The value of the <code>service</code> property SHOULD be an array
of <a>service endpoint</a> objects. Each service endpoint MUST
have <code>type</code> and <code>serviceEndpoint</code> properties,
SHOULD have an <code>id</code> property, and MAY include additional
properties.
          </dd>
      </dl>

      <p>
The value of the <code>id</code> property (if present) MUST be a URI.
The array of <a>service endpoints</a> MUST NOT contain multiple entries
with the same <code>id</code>. A <a>DID document</a> processor MUST
produce an error in that case.
      </p>

      <p>
The value of the <code>serviceEndpoint</code> property MUST be a
JSON-LD object or a valid <a>URI</a> conforming to [[RFC3986]] and
normalized according to the rules in section 6 of [[RFC3986]] and to
any normalization rules in its applicable URI scheme specification.
      </p>

      <p>
It is expected that the <a>service endpoint</a> protocol is
published in an open standard specification.
      </p>

      <p>
Example:
      </p>

      <pre class="example nohighlight" title="Various service endpoints">
{
  "service": [{
    "id": "did:example:123456789abcdefghi#openid",
    "type": "OpenIdConnectVersion1.0Service",
    "serviceEndpoint": "https://openid.example.com/"
  }, {
    "id": "did:example:123456789abcdefghi#vcr",
    "type": "CredentialRepositoryService",
    "serviceEndpoint": "https://repository.example.com/service/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#xdi",
    "type": "XdiService",
    "serviceEndpoint": "https://xdi.example.com/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#agent",
    "type": "AgentService",
    "serviceEndpoint": "https://agent.example.com/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#hub",
    "type": "IdentityHub",
    "publicKey": "did:example:123456789abcdefghi#key-1",
    "serviceEndpoint": {
      "@context": "https://schema.identity.foundation/hub",
      "type": "UserHubEndpoint",
      "instances": ["did:example:456", "did:example:789"]
    }
  }, {
    "id": "did:example:123456789abcdefghi#messages",
    "type": "MessagingService",
    "serviceEndpoint": "https://example.com/messages/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#inbox",
    "type": "SocialWebInboxService",
    "serviceEndpoint": "https://social.example.com/83hfh37dj",
    "description": "My public social inbox",
    "spamCost": {
      "amount": "0.50",
      "currency": "USD"
    }
  }, {
    "id": "did:example:123456789abcdefghi#authpush",
    "type": "DidAuthPushModeVersion1",
    "serviceEndpoint": "http://auth.example.com/did:example:123456789abcdefg"
  }]
}
</pre>
      <p>
See Sections <a href="#did-method-schemes"></a>
and <a href="#authentication"></a> for further security
considerations regarding authentication <a>service endpoints</a>.
      </p>
    </section>

    <section>
      <h2>
Created
      </h2>

      <p>
A <a>DID document</a> SHOULD include a <code>created</code> property. If so:
      </p>

      <dl>
          <dt><dfn>created</dfn></dt>
          <dd>
The value of <code>created</code> MUST be a valid XML datetime value as
defined in section 3.3.7 of <a href="https://www.w3.org/TR/xmlschema11-2/">
W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a> [[!XMLSCHEMA11-2]].
This datetime value MUST be normalized to UTC 00:00 as indicated by the trailing "Z".
          </dd>
      </dl>

      <p>
Example:
      </p>

      <pre class="example nohighlight">
{
  "created": "2002-10-10T17:00:00Z"
}
</pre>
    </section>

    <section>
      <h2>
Updated
      </h2>

      <p>
Standard metadata for identifier records includes a timestamp of the
most recent change.
      </p>

      <p>
A <a>DID document</a> SHOULD include an <code>updated</code> property. If so:
      </p>

      <dl>
          <dt><dfn>updated</dfn></dt>
          <dd>
The <code>updated</code> value MUST follow the same formatting rules as the
<code>created</code> property (see Section <a href="#created"></a>).
          </dd>
      </dl>

      <p>
Example:
      </p>

      <pre class="example nohighlight">
{
  "updated": "2016-10-17T02:41:00Z"
}
</pre>
    </section>

    <section>
      <h2>
Proof
      </h2>

      <p>
	      <a>DID 문서</a>의 <code>proof</code>은 다음 중 하나에 따라 <a>DID 문서</a>의 무결성을 증명하는 암호화 증명이다:
      </p>

      <ol start="1">
        <li>
		섹션 5.2 <a href="#did-subject">DID 주체</a>에 정의 된 <a>DID 주체</a> 또는:
        </li>

        <li>
<a href="#authorization-and-delegation">권한 부여 및 위임</a>에 정의 된 DID 컨트롤러 (있는 경우).
        </li>
      </ol>

      <p>
	      이 증명은 <a>DID</a>와 <a>DID 문서</a>간의 연관성(binding) 대한 증명이 아니다 (섹션 9.3 신원의 바인딩 참조(<a href="#binding-of-identity"></a>)).
      </p>

      <p>
	      <a>DID 문서</a>는 <code>proof</code> 속성을 포함 할 수 있다. 그렇다면:
      </p>

      <dl>
          <dt><dfn>proof</dfn></dt>
          <dd>
<code>proof</code> 값은 무조건 링크 된 데이터 증명(<a href="https://w3c-dvcg.github.io/ld-signatures/">Linked Data Proofs</a>)에서 정의한 유효한 JSON-LD 증명이어야한다.
          </dd>
      </dl>

      <p>
Example:
      </p>

      <pre class="example nohighlight" title="A signature-based proof">
{
  "proof": {
    "type": "LinkedDataSignature2015",
    "created": "2016-02-08T16:02:20Z",
    "creator": "did:example:8uQhQMGzWxR8vw5P3UWH1ja#keys-1",
    "signatureValue": "QNB13Y7Q9...1tzjn4w=="
  }
}
</pre>
    </section>

    <section>
      <h2>
Extensibility
      </h2>

      <p>
	      <a>탈중앙화 식별자</a> 데이터 모델의 목표 중 하나는 비허가형 혁신을 가능하게하는 것이다. 이를 위해서는 데이터 모델을 다양한 방법으로 확장 할 수 있어야 한다:
      </p>

      <ul>
        <li>
The requirement to model complex multi-entity relationships is
provided through the use of a graph-based data model.
        </li>

        <li>
The requirement to enable extending the machine-readable
vocabularies used to describe information in the data model &mdash;
without relying on a centralized system &mdash; is accomplished via
the use of [[LINKED-DATA]].
        </li>

        <li>
The requirement to support multiple types of cryptographic proof
formats is accomplished via the use of Linked Data Proofs
[[LD-PROOFS]], Linked Data Signatures [[LD-SIGNATURES]], and a
variety of signature suites.
        </li>

        <li>
The requirement to provide all of the extensibility mechanisms
outlined above in a data format that is popular among software
developers and web page authors is enabled via the use of
[[!JSON-LD]].
        </li>
      </ul>

      <p>
This approach to data modeling is often called an "open world
assumption", meaning that anyone can say anything about any other
thing. This approach often feels in conflict with building simple
and predictable software systems. Balancing extensibility with
program correctness is always more challenging with an open world
assumption than it is with closed software systems.
      </p>

      <p>
The rest of this section describes how both extensibility and program
correctness are achieved through a series of examples.
      </p>

      <p>
	      다음과 같은 <a>DID 문서</a>로 시작한다고 가정 해 본다:
      </p>

      <pre class="example nohighlight" title="A simple DID document">
{
  "@context": "https://example.org/example-method/v1",
  "id": "did:example:123456789abcdefghi",
  "publicKey": [{ <span class="comment">...</span> }],
  "authentication": [{ <span class="comment">...</span> }],
  "service": [{ <span class="comment">...</span> }]
}
      </pre>
      <p>
이 섹션에서는 <code>publicKey</code>, <code>authentication</code> 및 <code>service</code> 속성의 내용이 중요하지 않다. 중요한 것은 위의 개체가 유효한 <a>DID 문서</a>라는 것이다. 개발자가 추가 정보를 표현하기 위해 <a>DID 문서</a>를 확장하고 싶다고 가정 하자. 추가정보는 피사체의 공개 사진 스트림이다.
      </p>

      <p>
The first thing that a developer would do is create a JSON-LD Context
containing the new term:
      </p>

      <pre class="example nohighlight" title="An example JSON-LD Context">
{
  "@context": {
    "PhotoStreamService": "https://example.com/vocab#PhotoStreamService"
  }
}
      </pre>
      <p>
	      JSON-LD 컨텍스트가 생성되었으므로 개발자는 <a>DID 문서</a> 프로세서에 액세스 할 수있는 어떤 위치에 이를 무조건 게시해야한다. 예를 들어, 우리가 JSON-LD 컨텍스트 위의 다음 URL에 게시되어 있다고 가정하자 :
<code>did:example:contexts:987654321</code>. 이 시점에서이 섹션의 첫 번째 예제를 확장하는 것은 위의 컨텍스트를 포함하고 <a>DID 문서</a>에 새 속성을 추가하는 간단한 문제이다.
      </p>

      <pre class="example nohighlight" title="A DID document with a custom extension">
{
  "@context": "https://example.org/example-method/v1",
  "id": "did:example:123456789abcdefghi",
  "authentication": [ <span class="comment">...</span> ],
  "service": [<span class="highlight">{
    "@context": "did:example:contexts:987654321",
    "id": "did:example:123456789abcdefghi#photos",
    "type": "PhotoStreamService",
    "serviceEndpoint": "https://example.org/photos/379283"
  }</span>]
}
      </pre>
      <p>
	      지금까지의 예시에서는 <a>탈중앙화 식별자</a> 데이터 모델을 탈중앙화 방식으로 쉽게 확장 할 수 있음을 보여주었다. 또한 이 방식으로 생성 된 <a>탈중앙화 식별자</a>가 네임 스페이스 충돌 및 의미상 모호성을 방지한다.
      </p>

      <p>
	      동적 확장성 모델은 구현 부담을 증가시킨다. 이러한 시스템 용으로 작성된 소프트웨어는 응용 프로그램의 위험 프로파일에 따라 확장명이 포함 된 <a>DID 문서</a>를 수락 할 수 있는지 여부를 결정해야한다. 일부 응용 프로그램은 확장을 허용하지만 무시하도록 선택하고 다른 응용 프로그램은 특정 확장만 허용하도록 선택할 수 있지만 보안 수준이 높은 환경에서는 확장이 허용되지 않을 수 있다. 이러한 결정은 응용 프로그램 개발자에게 달려 있으며 특히 이 사양의 영역이 아니다.
      </p>

      <p>
Implementations MUST produce an error when an extension JSON-LD
Context overrides the expanded URL for a term specified in this
specification. To avoid the possibility of accidentally overriding
terms, developers SHOULD scope their extensions. For example,
the following extension scopes the new
<code>PhotoStreamService</code> term so that it may only be used
within the <code>service</code> property:
      </p>

      <pre class="example nohighlight" title="Scoping terms in a JSON-LD Context">
{
  "@context": {
    <span class="highlight">"service": {
      "@id": "https://w3id.org/did#service",
      "@context": {
        "PhotoStreamService": "https://example.com/vocab#PhotoStreamService"
      }
    }</span>
  }
}
      </pre>
      <p>
Developers are urged to ensure that extension JSON-LD Contexts are
highly available. Implementations that cannot fetch a context will
produce an error. Strategies for ensuring that extension JSON-LD
Contexts are always available include using content-addressed URLs
for contexts, bundling context documents with implementations, or
enabling aggressive caching of contexts.
      </p>
    </section>
  </section>

  <section class="normative">
    <h1>
DID Document Syntax
    </h1>

      <p>
A <a>DID document</a> MUST be a single JSON object conforming to [[!RFC8259]].
Many of the concepts in this document were introduced by example using the
JSON-LD syntax, a format for mapping JSON data into the RDF semantic graph
model, as defined by [[!JSON-LD]]. This section formalizes how the data model
(described in Sections <a href="#data-model"></a> and
<a href="#did-documents"></a>) is realized in JSON-LD.
      </p>
      <p>
Although syntactic mappings are provided for JSON and JSON-LD only, applications
and services can use any other data representation syntax, such as JXD (JSON XDI
Data, a serialization format for the
<a href="http://docs.oasis-open.org/xdi/xdi-core/v1.0/csd01/xdi-core-v1.0-csd01.xml">XDI graph model</a>),
XML, YAML, or CBOR, that is capable of expressing the data model.
      </p>

    <section>
      <h2>
JSON
      </h2>

        <p>
The data model, as described in Section <a href="#data-model"></a>, can be
encoded in Javascript Object Notation (JSON) [[RFC8259]] by mapping property
values to JSON types as follows:
        </p>

        <ul>
          <li>
Numeric values representable as IEEE754 SHOULD be represented as a Number type.
          </li>
          <li>
Boolean values SHOULD be represented as a Boolean type.
          </li>
          <li>
Sequence value SHOULD be represented as an Array type.
          </li>
          <li>
Unordered sets of values SHOULD be represented as an Array type.
          </li>
          <li>
Sets of properties SHOULD be represented as an Object type.
          </li>
          <li>
Empty values SHOULD be represented as a null value.
          </li>
          <li>
Other values MUST be represented as a String type.
          </li>
        </ul>
    </section>

    <section>
      <h2>
JSON-LD
      </h2>

        <p>
[[!JSON-LD]] is a JSON-based format used to serialize
<a href="http://www.w3.org/TR/ld-glossary/#linked-data">Linked Data</a>. The
syntax is designed to easily integrate into deployed systems already using
JSON, and provides a smooth upgrade path from JSON to JSON-LD. It is primarily
intended to be a way to use Linked Data in Web-based programming environments,
to build interoperable Web services, and to store Linked Data in JSON-based
storage engines.
        </p>

        <p>
JSON-LD is useful when extending the data model described in this specification.
Instances of the data model are encoded in JSON-LD in the same way they are
encoded in JSON (see Section <a href="#json"></a>), with the addition of the
<code>@context</code> property. The
<a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD Context</a>
is described in detail in the [[!JSON-LD]] specification and its use is
elaborated on in Section <a href="#extensibility"></a>.
        </p>

        <p>
In general, the data model and syntaxes described in this document are designed
such that developers can copy and paste examples into their software systems.
The design goal of this approach is to provide a low barrier to entry while
still ensuring global interoperability between a heterogeneous set of software
systems. This section describes some of these approaches, which will likely go
unnoticed by most developers, but whose details will be of interest to
implementers. Noteworthy features provided by JSON-LD are:
        </p>

        <ul>
          <li>
The <code>@id</code> and <code>@type</code> keywords are aliased to
<code>id</code> and <code>type</code> respectively, enabling developers to use
this specification as idiomatic JSON.
          </li>
          <li>
Data types, such as integers, dates, units of measure, and URLs, are
automatically typed to provide stronger type guarantees for use cases that
require them.
          </li>
          <li>
The <code>@protected</code> properties feature of JSON-LD 1.1 is used to ensure
that terms defined by this specification cannot be overridden. This means that
as long as the same <code>@context</code> declaration is made at the top of a
<a>DID document</a>, interoperability is guaranteed between implementations
that use a JSON-LD processor and implementations that do not.
          </li>
        </ul>
    </section>
  </section>

  <section>
    <h1>
DID Methods
    </h1>

    <section class="normative">
      <h2>
DID Method Schemes
      </h2>

      <p>
<a>DID 메소드</a> 규격은 정확하게 메소드별 <a>DID 체계</a>마다 식별이 가능한 정확한 하나의 메소드 이름이 반드시 정의해야 한다. (<code>method-name</code> 규칙은 <a href="#generic-did-syntax"></a>에 따른다)
      </p>

      <p>
메소드 이름은 <a>DID</a>의 일부이므로, 짧은 메소드 이름이 선호된다. 메소드 이름은 5자 이하여야 한다. 메소드 이름은 <a>DID 메소드</a> 규격이 적용되는 <a>DID 레지스트리</a>의 이름을 반영할 수 있다. (<a href="#unique-did-method-names"></a>.)
      </p>

      <p>
메소드별 <a>DID 체계</a>를 위한 <a>DID 메소드</a> 규격에는 <a>DID</a>의 구성요소인 <code>method-specific-id</code>를 어떻게 생성하는지 반드시 명시가 되어있어야 한다. <code>method-specific-id</code>는 반드시 중앙화 된 레지스트리 서비스를 이용하지 않고 생성할 수 있어야 한다. <code>method-specific-id</code>는 범용(범세계)적으로 고유해야 한다. <code>did</code> 규칙은 <a href="#generic-did-syntax"></a>에 정의되어 있으며, 반드시 전세계적으로 고유해야 한다.
      </p>

      <p>
필요하다면, 메소드별 <a>DID 체계</a>는 다수의 <code>method-specific-id</code> 형식을 정의할 수 있다. (하지만) 가능한 소수의 <code>method-specific-id</code> 형식을 정의하는 것을 권장한다.
      </p>
    </section>

    <section>
      <h2>
DID Operations
      </h2>

      <p>
특정 <a>DID 레지스트리</a>에서 <a>DIDs</a> 및 <a>DID 문서</a>의 전체 기능을 사용하려면 클라이언트에 의해 수행되는 다음 <abbr title="Create, Read, Update, Delete">CRUD</abbr> 작업이 DID 메소드 규격에 반드시 지정되어 있어야 한다. 각 조작은 <a>DID 레지스트리</a>와 상호운용 가능한 클라이언트 구현을 빌드하고 시험할 수준의 세부사항을 지정해야 할 필요가 있다. 이러한 조작은 CKMS(cryptographic key management system)에 필요한 모든 조작을 효과적으로 수행할 수 있다. 예를 들면 키 등록, 키 교체, 키 회전(key rotation), 키 복구, 키 만료 들이다.
      </p>
      <p>
업데이트 또는 비활성화와 같은 특정 작업을 지원하지 않는 <a>DID 메소드</a> 규격은 이러한 제한을 반드시 명확하게 명시해야 한다.
      </p>

      <section>
        <h3>
Create
        </h3>

        <p>
<a>DID 메소드</a> 규격은 클라이언트가 <a>DID</a> 및 관련 <a>DID 문서</a>를 <a>DID 레지스트리</a>에 어떻게 생성할지 명시해야 하며, 여기에는 제어증명 입증을 위한 모든 암호화 작업이 포함된다.
        </p>
      </section>

      <section>
        <h3>
Read/Verify
        </h3>

        <p>
<a>DID 메소드</a> 규격은 클라이언트가 <a>DID</a>를 사용하여 <a>DID 레지스트리</a>에 <a>DID 문서</a>를 요청하는 방법, 클라이언트가 응답의 진위를 확인할 수 있는 방법을 반드시 명시해야 한다.
        </p>
      </section>

      <section>
        <h3>
Update
        </h3>

        <p>
<a>DID 메소드</a> 규격은 클라이언트가 <a>DID 레지스트리</a>의 <a>DID 문서</a>를 갱신 할 수 있는 방법을 반드시 명시해야 한다. 여기에는 제어증명 입증을 위한 모든 암호화 작업, <em>또는</em> 업데이트가 불가능하다는 상태가 포함된다.
        </p>
      </section>

      <section>
        <h3>
Deactivate
        </h3>

        <p>
<a>DID 메소드</a> 규격은 클라이언트가 <a>DID 레지스트리</a>의 <a>DID</a>를 비활성화 할 수 있는 방법을 반드시 명시해야 한다. 여기에는 제어증명 입증을 위한 모든 암호화 작업, <em>또는</em> 비활성화가 불가능하다는 상태가 포함된다.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>
Unique DID Method Names
      </h2>
      <p>
새로운 <a>DID 메소드</a> 규격의 저자는 발표 당시 알려진 모든 <a>DID 메소드</a> 이름들과 중복되지 않는 고유한 메소드 이름을 사용해야만 한다.
      </p>
      <p>
<a>DID 메소드</a> 이름을 할당하거나 승인 할 수 있는 권한을 가진 중앙기관이 없기 때문에 특정 <a>DID 메소드</a> 이름이 고유한 지 확인할 방법이 없다. 이 문제를 해결하기 위해 <a href="https://www.w3.org/community/credentials/">W3C Credentials Community Group</a>은 알려진 <a>DID 메소드</a> 이름과 관련 규격의 비권한 목록을 유지한다(Appendix <a href="#registries"></a> 참조)
      </p>
      <p>
[[DID-METHOD-REGISTRY]]는 새로운 메소드 명칭을 합의할 때 구현자가 참조 할 수 있는 도구이며, 또한 다른 <a>DID 메소드</a>의 <a>DID 리졸버</a>를 구현하는 소프트웨어 개발자가 참조 할 수 있는 정보가 된다. 좀 더 많은 <a>DID 리졸버</a>에 대한 정보는 <a href="#did-resolvers"></a>을 참고 할 것.

[[DID-METHOD-REGISTRY]]는 <a>DID 메소드</a>의 확정적 또는 공식적인 목록이 아니다. 그럼에도 불구하고, [[DID-METHOD-REGISTRY]]에 <a>DID 메소드</a> 이름을 추가하여 다른 구현자와 커뮤니티 구성원이 기존 <a>DID 메소드</a>의 개요를 한곳에서 볼 수 있도록 하는 것을 장려한다. <a>DID 메소드</a> 이름을 추가하기 위한 간략한 기준은 [[DID-METHOD-REGISTRY]]에 문서화되어 있다.
      </p>
    </section>

  </section>

  <section class='normative'>
    <h1>
DID Resolvers
    </h1>

    <p>
A <a>DID resolver</a> is a software or hardware component with an API for
resolving <a>DIDs</a> of at least one <a>DID method</a>. It executes the read
operation for the <a>DID method</a> corresponding to the <a>DID</a> being
resolved to obtain the authoritative <a>DID document</a>. For more information,
see Section <a href="#read-verify"></a>.
    </p>

    <p>
The interfaces and algorithms for resolving <a>DIDs</a> and dereferencing
<a>DID URLs</a> are specified in [[DID-RESOLUTION]].
    </p>

  </section>

  <section class="informative">
    <h1>
Security Considerations
    </h1>

    <p class="note" title="Note to implementers">
During the Implementer’s Draft stage, this
section focuses on security topics that should be important in early
implementations. The editors are also seeking feedback on threats and
threat mitigations that should be reflected in this section or
elsewhere in the spec. As the root identifier records for <a>decentralized
identifiers</a> (DIDs) and <a>DID documents</a> are a vital component of
<a>decentralized identity management</a>. They are also the foundational
building blocks of <a>decentralized public key infrastructure</a> (DPKI)
as an augmentation to conventional X.509 certificates. As such, <a>DIDs</a> are
designed to operate under the general Internet threat model used by
many IETF standards. We assume uncompromised endpoints, but allow
messages to be read or corrupted on the network. Protecting against an
attack when a system is compromised requires external key-signing
hardware. See also Section <a href="#key-revocation-and-recovery"></a>
regarding key revocation and recovery. For their part, the <a>DLTs</a> hosting
<a>DIDs</a> and <a>DID documents</a> have special security properties for preventing
active attacks. Their design uses public/private key cryptography to
allow operation on passively monitored networks without risking
compromise of private keys. This is what makes <a>DID</a> architecture and
decentralized identity possible.
    </p>

    <section>
      <h2>
Requirements of DID Method Specifications
      </h2>

      <p>
The requirements for <a>DID method</a> specifications are as follows:
      </p>
      <ul>
        <li>
<a>DID method</a> specifications MUST include their own Security Considerations
section.
        </li>

        <li>
This section MUST consider all the requirements mentioned in Section 5 of
[[RFC3552]] (page 27) for the <a>DID</a> operations defined in the
specification. In particular:

      <p class="issue">
Discussions at Rebooting the Web of Trust 5 resulted in consensus to
move Authorization to <a>DID method</a> specifications. It is currently
expected that there will be an attempt to create a generalized
authorization mechanism that is build on object capabilities.
      </p>

          <ul>
            <li>
At least the following forms of attack MUST be considered: eavesdropping,
replay, message insertion, deletion, modification, and man-in-the-middle.
            </li>
            <li>
Potential denial of service attacks MUST be identified as well. 
            </li>
            <li>
If the protocol incorporates cryptographic protection mechanisms, clearly
indicate which portions of the data are protected and what the protections are.
For example, integrity only, confidentiality, endpoint authentication, and so
on.
            </li>
            <li>
Give an indication to what sorts of attacks the cryptographic protection is
susceptible. 
            </li>
            <li>
Data which is to be held secret (keying material, random seeds, and so on) is to
be clearly labeled.
            </li>
            <li>
If the technology involves authentication, particularly user-host
authentication, the security of the authentication method MUST be clearly
specified.
            </li>
          </ul>
        </li>

        <li>
This section MUST discuss, per Section 5 of [[RFC3552]], residual risks (such as
the risks from compromise in a related protocol, incorrect implementation, or
cipher) after threat mitigation was deployed.
        </li>

        <li>
This section MUST provide integrity protection and update authentication for all
operations required by Section <a href="#did-operations"></a>.
        </li>

        <li>
Where <a>DID methods</a> make use of peer-to-peer computing resources, such as
with all known <a>DLTs</a>, the expected burdens of those resources SHOULD be
discussed in relation to denial of service.
        </li>

        <li>
Method-specific endpoint authentication MUST be discussed. Where
<a>DID methods</a> make use of <a>DLTs</a> with varying network topology,
sometimes offered as <em>light node</em> or
<em><a href="https://en.bitcoin.it/wiki/Thin_Client_Security">thin client</a></em>
implementations to reduce required computing resources, the security assumptions
of the topology available to implementations of the <a>DID method</a> MUST be
discussed.
        </li>

        <li>
<a>DID methods</a> MUST discuss the policy mechanism by which <a>DIDs</a> are
proven to be uniquely assigned. A <a>DID</a> fits the functional definition
of a URN, as defined in [[RFC8141]]. That is, a <a>DID</a> is a persistent
identifier that is assigned once to a resource and never reassigned to a
different resource. This is particularly important in a security context because
a <a>DID</a> might be used to identify a specific party subject to a specific
set of authorization rights.
        </li>

        <li>
<a>DID methods</a> that introduce new authentication <a>service endpoint</a>
types (see Section <a href="#service-endpoints"></a>) SHOULD consider the
security requirements of the supported authentication protocol.
        </li>
      </ul>
    </section>

    <section>
      <h2>
Choosing DID Resolvers
      </h2>

      <p>
The [[DID-METHOD-REGISTRY]] is an informative list of <a>DID method</a> names
and their corresponding <a>DID method</a> specifications. Implementors need to
bear in mind that there is no central authority to mandate which
<a>DID method</a> specification is to be used with any specific
<a>DID method</a> name, but can use the [[DID-METHOD-REGISTRY]] to make an
informed decision when choosing which <a>DID resolver</a> implementations to
use.
      </p>
    </section>

    <section>
      <h2>
Binding of Identity
      </h2>

      <p>
The following sections describe binding identities to <a>DIDs</a> and
<a>DID documents</a>.
      </p>

      <section>
        <h3>
Proving Control of a DID and DID Document
        </h3>

        <p>
Signatures are one way to allow <a>DID documents</a> to be cryptographically
verifiable.
        </p>

        <p>
By itself, a verified signature on a self-signed <a>DID document</a> does not
prove control of a <a>DID</a>. It only proves that the:
        </p>

        <ul>
          <li>
<a>DID document</a> was not tampered with since it was registered.
          </li>

          <li>
<a>DID controller(s)</a> controlled the private key used for the signature at
the time the signature was generated.
          </li>
        </ul>

        <p>
Proving control of a <a>DID</a>, that is, the binding between the <a>DID</a> and
the <a>DID document</a> that describes it, requires a two step process:
        </p>

        <ol start="1">
          <li>
Resolving the <a>DID</a> to a <a>DID document</a> according to its
<a>DID method</a> specification.
          </li>

          <li>
Verifying that the <code>id</code> property of the resulting <a>DID document</a>
matches the <a>DID</a> that was resolved.
          </li>
        </ol>

        <p>
It should be noted that this process proves control of a <a>DID</a> and
<a>DID document</a> regardless of whether the <a>DID document</a> is signed.
        </p>

        <p>
Signatures on <a>DID documents</a> are optional. <a>DID method</a>
specifications SHOULD explain and specify their implementation if applicable.
        </p>

        <p>
It is good practice to combine timestamps with signatures.
        </p>
      </section>

      <section>
        <h3>
Proving Control of a Public Key
        </h3>

        <p>
There are two methods for proving control of the private key corresponding to a
<a>public key description</a> in the <a>DID document</a>: static and dynamic.
        </p>

        <p>
The static method is to sign the <a>DID document</a> with the private key. This
proves control of the private key at a time no later than the
<a>DID document</a> was registered. If the <a>DID document</a> is not signed,
control of a public key described in the <a>DID document</a> can still be proven
dynamically as follows:
        </p>

        <ol start="1">
          <li>
Send a challenge message containing a <a>public key description</a> from the
<a>DID document</a> and a nonce to an appropriate <a>service endpoint</a>
described in the <a>DID document</a>.
          </li>

          <li>
Verify the signature of the response message against the
<a>public key description</a>.
          </li>
        </ol>
      </section>

      <section>
        <h3>
Authentication and Verifiable Claims
        </h3>

        <p>
A <a>DID</a> and <a>DID document</a> do not inherently carry any
<a href="https://en.wikipedia.org/wiki/Personally_identifiable_information">PII</a>
(personally-identifiable information). The process of binding a <a>DID</a> to
something in the real world, such as a person or a company, for example with
credentials with the same subject as that <a>DID</a>, is out of scope for this
specification. For more information, see the [[VC-DATA-MODEL]] instead.
        </p>
      </section>
    </section>

    <section>
      <h2>
Authentication Service Endpoints
      </h2>

      <p>
If a <a>DID document</a> publishes a <a>service endpoint</a> intended for
authentication or authorization of the <a>DID subject</a> (see Section
<a href="#service-endpoints"></a>), it is the responsibility of the
<a>service endpoint</a> provider, subject, or relying party to comply with the
requirements of the authentication protocols supported at that
<a>service endpoint</a>.
      </p>
    </section>

    <section>
      <h2>
Non-Repudiation
      </h2>

      <p>
Non-repudiation of <a>DIDs</a> and <a>DID document</a> updates is supported
under the assumption that the subject:
      </p>

      <ul>
        <li>
Is monitoring for unauthorized updates (see Section
<a href="#notification-of-did-document-changes"></a>).
        </li>
        <li>
Has had adequate opportunity to revert malicious updates according to the 
access control mechanism for the <a>DID method</a> (see Section
<a href="#authentication"></a>).
        </li>
      <ul>

      <p>
Non-repudiation is further supported if timestamps are included (see Sections
<a href="#created"></a> and <a href="#updated"></a>) and the target <a>DLT</a>
system supports timestamps.
      </p>
    </section>

    <section>
      <h2>
Notification of DID Document Changes
      </h2>

      <p>
One mitigation against unauthorized changes to a <a>DID document</a> is
monitoring and actively notifying the <a>DID subject</a> when there are changes.
This is analogous to helping prevent account takeover on conventional
username/password accounts by sending password reset notifications to the email
addresses on file. In the case of a <a>DID</a>, where there is no intermediary
registrar or account provider to generate the notification, the following
approaches are suggested:
      </p>

      <ul>
        <li>
Subscriptions. If the <a>DID registry</a> on which the <a>DID</a> is registered
directly supports change notifications, this service can be offered to
<a>DID controllers</a>. Notifications could be sent directly to the relevant
<a>service endpoints</a> listed in an existing <a>DID</a>.
        </li>

        <li>
Self-monitoring. A <a>DID subject</a> can employ their own local or online agent
to periodically monitor for changes to a <a>DID document</a>.
        </li>

        <li>
Third-party monitoring. A <a>DID subject</a> could rely on a third-party
monitoring service, however this introduces another vector of attack.
        </li>
      </ul>
    </section>

    <section>
      <h2>
Key and Signature Expiration
      </h2>

      <p>
In a <a>decentralized identifier</a> architecture, there are no centralized
authorities to enforce key or signature expiration policies. Therefore
<a>DID resolvers</a> and other client applications need to validate that keys
were not expired at the time they were used. Because some use cases might have
legitimate reasons why already-expired keys can be extended, make sure a key
expiration does not prevent any further use of the key, and implementations
of a resolver ought to be compatible with such extension behavior.
      </p>
    </section>

    <section>
      <h2>
Key Revocation and Recovery
      </h2>

      <p>
Section <a href="#did-operations"></a> specifies the <a>DID</a> operations to be
supported by a <a>DID method</a> specification, including deactivation of a
<a>DID document</a> by replacing it with an updated <a>DID document</a>. In
general, checking for key revocation on <a>DLT</a>-based methods is expected to
be handled in a manner similar to checking the balance of a cryptocurrency
account on a <a>distributed ledger</a>. That is, if the balance is empty, the
entire <a>DID</a> is deactivated. <a>DID method</a> specifications are expected
to enable support for a quorum of trusted parties to enable key recovery. Some
of the facilities to do so are suggested in Section
<a href="#authorization-and-delegation"></a>. Not all <a>DID method</a>
specifications will recognize control from <a>DIDs</a> registered using other
<a>DID methods</a> and they might restrict third-party control to <a>DIDs</a>
that use the same method. Access control and key recovery in a <a>DID method</a>
specification can also include a time lock feature to protect against key
compromise by maintaining a second track of control for recovery. Further
specification of this type of control is a matter for future work (see Section
<a href="#time-locks-and-did-document-recovery"></a>).
      </p>
    </section>

    <section>
      <h2>
The Role of Human-Friendly Identifiers
      </h2>

      <p>
	      <a>DID들</a>은 중앙 등록 기관이 없어도 글로벌 독창성을 달성한다. 그러나 이것은 인간의 기억력을 희생시키면서 발생한다. 전역적으로 고유한 식별자를 생성 할 수 있는 알고리즘은 의미가없는 임의의 문자열을 자동으로 생성한다. 이것은 Zooko의 Triangle(<a href="https://en.wikipedia.org/wiki/Zooko%27s_triangle">Zooko's Triangle</a>)으로 알려진 식별자에 대한 공리를 보여준다 : "의미, 탈중앙화, 안전. 셋 중 아무거나 둘을 선택하십시오".
      </p>

      <p>
	      물론 인간 친화적인 식별자 (이메일 주소, Twitter 핸들 또는 블로그 URL등과 같은 <a>DID 컨트롤러</a>의 주소, 자연어 이름, 도메인 이름 또는 휴대 전화 번호)에서 시작할 때 <a>DID</a>를 발견하는 것이 바람직한 많은 경우가 있다. 그러나 사람에게 친숙한 식별자를 <a>DID들</a>에 매핑 (및 확인 및 신뢰할 수있는 방식으로)하는 문제는 다른 이야기 이다.
      </p>

      <p>
Solutions to this problem (and there are many) should be defined in separate
specifications that reference this specification. It is strongly recommended
that such specifications carefully consider the:
      </p>

      <ul>
        <li>
Numerous security attacks based on deceiving users about the true human-friendly
identifier for a target entity.
        </li>
        <li>
Privacy consequences of using human-friendly identifiers that are inherently
correlatable, especially if they are globally unique.
        </li>
      <ul>

      <p class="note">
	      DNS 조회를 사용하여 도메인 이름 및 전자 메일 주소에서 <a>DID</a>를 검색하기위한 초안 사양은 [[DNS-DID]]에 있다.
	  </p>
    </section>

    <section>
        <h2>
Immutability
        </h2>

        <p>
		많은 사이버 보안 침해는 현실과 합리적이고 선의의 이용자들의 이상 사이의 격차를 이용하는 데 달려 있다. 다른 생태계와 마찬가지로, <a>DID</a> 생태계는 이것이 일어날 가능성이 있다. 이 사양은 프로토콜이 아닌 데이터 모델에 중점을 두기 때문에 해당 모델의 사용 방식에 대한 여러 측면에 대한 의견을 제시하지 않았다. 그러나 개별 <a>DID 방법들</a>은 필요하지 않은 동작이나 의미를 제거하는 제약 조건을 고려할 수 있다. <a>DID 방법</a>이 <em>잠금</em>(<em>locked down</em>)상태 일수록 동일한 기능 세트를 제공하는 반면 악의적인 행위자가 조작 할 수있는 수준은 줄어 든다.
        </p>
        <p>
		예를 들어, 데이터 모델이 업데이트와 관련하여 제공하는 유연성을 고려해보자. <a>DID 문서</a>를 한 번만 편집하면 문서의 루트 ID 속성을 제외한 모든 항목을 변경할 수 있으며 데이터 모델의 개별 JSON 객체는 root <code>id</code>를 제외한 모든 속성을 변경할 수 있다. 그러나 <a>서비스 엔드 포인트</a>가 일단 정의되면 <code>type</code>을 변경하는 것이 실제로 바람직한가? 아니면 가치를 바꾸는 열쇠가 필요한가? 아니면 객체의 특정 기본 속성이 변경 될 때 새로운 <code>id</code>를 요구하는 것이 더 좋은가? 웹 사이트의 악의적인 인수는 종종 사이트가 자신의 식별자 (호스트 이름)를 유지하지만 그 아래에 미묘하고 위험한 변화를 가져 오는 결과를 목표로 한다. 사양에 따라 사이트의 특정 속성을 변경할 수없는 경우 (예 : IP 주소와 관련된 ASN) 이러한 공격을 수행하는 데 훨씬 더 어렵고 비용이 많이 들며 이상 탐지가 더 쉬울 수 있다.
        </p>
        <p>
		불변성이 일부 사이버 보안 이점을 제공 할 수 있다는 개념은 캐싱 때문에 특히 관련이 있다. 전 세계 진실 소스에 연결된 <a>DID 방법들</a>의 경우 최신 버전의 <a>DID 문서</a>를 적시에 직접 조회 할 수 있다. 그러나 캐시 레이어는 결국 클라이언트와 해당 소스 사이에 있을 수 있다. 만약 그렇다면, 실제로 미묘하게 다른 <a>DID 문서</a>에있는 객체(object)의 속성이 주어진 상태를 가지고 있다고 믿으면 활용을 증대 할 수 있습니다. 일부 조회가 전체 <a>DID 문서</a>이고 다른 조회가 부분적인 데이터 인 경우 더 큰 맥락이 가정되는 경우에 특히 그렇습니다.
    </section>

  </section>

  <section class="informative">
    <h1>
Privacy Considerations
    </h1>

    <p>
      DIDs 및 DID 문서는 설계 상 <a> DID 컨트롤러</a>에 의해 직접 관리되므로, 
      프라이버시 디자인 (Privacy by Design) 원칙을 분산 식별자 아키텍처의 모든 측면에 적용하는 것이 매우 중요하다.
      추가적으로 프라이버시 보호를 권장하거나 적용할 등록 기관, 호스팅 회사 또는 기타 중간 서비스 제공 업체는 없다.
      이 규격의 저자는 개발 전반에 걸쳐 7가지 프라이버시 디자인(Privacy by Design) 원칙을 모두 적용했다.
      예를 들어, 이 규격에서 프라이버시는 예방적이지 교정적이지 않다. 프라이버시는 기본 설정이다. 
      또한 <a>decentralized identifier</a> 아키텍처 자체는 원칙 # 7, "Respect for user privacy — keep it user-centric."를 구현한다. 
      이 섹션에는 구현자(implementers), 대리인(delegates) 및 <a>DID 주체</a>가 염두에 두어야 할 추가 프라이버시 고려 사항이 나열되어 있다.
    </p>

    <section>
      <h2>
Requirements of DID Method Specifications
      </h2>

      <ol start="1">
        <li>
          이 섹션의 일반적인 프라이버시 고려사항만 가리키는 경우, 
          <a>DID 메소드</a> 규격에는 반드시 자체 프라이버시 고려사항 섹션이 포함되어야한다.
        </li>

        <li>
          <a>DID 메소드</a> 규격의 프라이버시 고려사항 섹션은 
          메소드에 따라 적용 할 수있는 [RFC6973]의 5 항의 하위 섹션을 반드시 논의해야한다. 
          고려해야 할 하위 섹션은 ‘감시, 저장된 데이터 손상, 원치 않는 트래픽, 
          잘못된 속성, 상관 관계, 식별, 2차 사용, 공개, 예외’가 있다.
        </li>
      </ol>
    </section>

    <section>
      <h2>
Keep Personally-Identifiable Information (PII) Private
      </h2>

      <p>
<a>DID 메소드</a> 규격이 모든 <a>DIDs</a> 및 <a>DID 문서</a>를 공개적으로 사용할 수 있는 
공개<a>DID 레지스트리</a>에 대해 작성된 경우, 
<a>DID 문서</a>에 PII가 포함되지 않도록 하는 것은  매우 <em>중요하다</em>. 

모든 PII는 <a>DID 주체</a>의 통제  하에 <a>서비스 엔드포인트</a> 뒤에서 유지되어야 한다. 

With this privacy architecture, PII may be exchanged
on a private, peer-to-peer basis using communications channels identified and
secured by <a>public key descriptions</a> in <a>DID documents</a>. 

이 프라이버시 설계를 통해, 
PII는 <a>DID 문서</a>의 <a>공개키 설명</a>으로 식별되고 보안되는 통신 채널을 사용하여, 
피어 투 피어 기반으로 교환 될 수 있다. 

또한 이것은 불변의 분산 장부에 PII가 기록되지 않기 때문에, 
<a>DID 주체</a>와 신뢰 당사자가 <a href="https://en.wikipedia.org/wiki/General_Data_Protection_Regulation">GDPR</a> 
<a href="https://en.wikipedia.org/wiki/Right_to_be_forgotten">right
  to be forgotten</a>를 구현할 수 있다.
      </p>
    </section>

    <section>
      <h2>
DID Correlation Risks and Pseudonymous DIDs
      </h2>

      <p>
        모든 유형의 전역적 고유 식별자와 마찬가지로, <a>DIDs</a> 상관 관계에 사용할 수 있다.
        <a>DID 컨트롤러</a>는 쌍으로 된 고유한 <a>DIDs</a> 사용하거나, 
        모든 관계에 대해 다른 개인용 <a>DID</a>를 공유함으로써 프라이버시 위험을 완화할 수 있다. 
        실제로 각 <a>DID</a>는 익명으로 사용된다.
        익명 <a>DID</a>는 <a>DID 주체</a>가 당사자 간의 상관 관계를 명시적으로 승인한 경우 둘 이상의 당사자끼리만 공유하면 된다. 
        익명 <a>DIDs</a>가 기본 값일 때, 공개 <a>DIDs</a> (공개적으로 발행되었거나 다수의 당사자와 공유된 <a>DIDs</a>)가 
        필요한 경우는 <a>DID 주체</a>가 명시적으로 공개 식별을 원할 때 뿐이다.
      </p>
    </section>

    <section>
      <h2>
DID Document Correlation Risks
      </h2>

      <p>
        해당 <a>DID 문서</a>의 데이터를 연관시킬 수 있으면 익명 <a>DIDs</a>의 안티-상관관계 보호는 쉽게 무너진다. 
        예를 들어, 여러 <a>DID 문서</a>에서 동일한 <a>공개키 설명</a> 또는 
        맞춤형 <a>서비스 엔드포인트</a>를 사용하면 동일한 <a>DID</a>를 사용하는 것과 같은 수준의 상관 정보를 제공 할 수 있다.
        따라서 익명 <a>DID</a>에 대한 <a>DID 문서</a>도 쌍별로 고유한 공개 키를 사용해야 한다. 
        익명 <a>DID</a>에 대해 <a>DID 문서</a>에서 쌍별로 고유한 <a>서비스 엔드포인트</a>를 사용하는 것도 자연스러운 것처럼 보일 수 있다. 
        그러나 고유한 엔드 포인트를 통해 <a>DIDs</a> 간 모든 트래픽을 
        타이밍 상관 관계와 유사한 분석이 용이한 고유한 버킷으로 완벽하게 분리할 수 있다.
        따라서 엔드 포인트 프라이버시를 위한 더 나은 전략은 많은 다른 주체에 의해 제어되는 
        수천 또는 수백만 개의 <a>DIDs</a> 간에 엔드 포인트를 공유하는 것이다.
      </p>
    </section>

    <section>
      <h2>
Herd Privacy
      </h2>

      <p>

        <a>DID 주체</a>가 군중의 다른 사람들과 구별되지 않는 경우, 프라이버시 보호가 가능하다. 
        다른 당사자와 개인적으로 참여하는 행위가 그 자체로 인식 가능한 플래그(flag)인 경우, 프라이버시가 크게 훼손된다.
        <a>DIDs</a>와 <a>DID 메소드</a>는 군중 프라이버시의 보호, 
        특히 합법적으로 가장 필요한 사람들의 프라이버시를 개선하기 위해 작동해야한다. 
        익명성과 가명성을 유지하는 데 도움이 되는 기술과 휴먼 인터페이스를 선택해야 한다. 
        <a href="https://en.wikipedia.org/wiki/Device_fingerprint">디지털 지문</a>을 줄이려면, 
        클라이언트 구현에서 공통 설정을 공유하고, 협의된 옵션을 유선 프로토콜에서 최소로 유지하고, 암호화 된 전송 계층을 사용하고, 메시지를 표준 길이로 채워야 한다.
      </p>
    </section>
  </section>

  <section class="informative">
    <h1>
Future Work
    </h1>

    <section>
      <h2>
Upper Limits on DID Character Length
      </h2>

      <p>
The current specification does not take a position on maximum length
of a <a>DID</a>. The maximum interoperable URL length is currently about 2K
characters. QR codes can handle about 4K characters. Clients using
<a>DIDs</a> will be responsible for storing many <a>DIDs</a>, and some methods
would be able to externalize some of their costs onto clients by
relying on more complicated signature schemes or by adding state into
<a>DIDs</a> intended for temporary use. A future version of this
specification should set reasonable limits on <a>DID</a> character length to
minimize externalities.
      </p>
    </section>

    <section>
      <h2>
Equivalence
      </h2>

      <p>
Including an equivalence property, such as <code>equivID</code>, in <a>DID documents</a>
whose value is an array of <a>DIDs</a> would allow subjects to assert two or
more <a>DIDs</a> that represent the same subject. This capability has
numerous uses, including supporting migration between <a>DID registries</a> and
providing forward compatibility of existing <a>DIDs</a> to future <a>DID
registries</a>. In
theory, equivalent <a>DIDs</a> should have the same identifier rights,
allowing <a href="https://w3c.github.io/vctf/">verifiable claims</a>
made against one <a>DID</a> to apply to equivalent <a>DIDs</a>. Equivalence was not
included in the current specification due to the complexity of
verifying equivalence across different <a>DLTs</a> and different <a>DID
methods</a>, and also of aggregating properties of equivalent <a>DID
documents</a>. However equivalence should be supported in a future
version of this specification.
      </p>
    </section>

    <section>
      <h2>
Timestamps
      </h2>

      <p>
Verifiable timestamps have significant utility for identifier
records. This is a good fit for <a>DLTs</a>, since most offer some type of
timestamp mechanism. Despite some transactional cost, they are the
most censorship-resistant transaction ordering systems in the world,
so they are nearly ideal for <a>DID document</a> timestamping. In some cases
a <a>DLT</a>'s immediate timing is approximate, however their sense of
<a href="https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki%23Abstract">
"median time past" (see Bitcoin BIP 113)</a> can be precisely
defined. A generic <a>DID document</a> timestamping mechanism could would
work across all <a>DLTs</a> and might operate via a mechanism including
either individual transactions or transaction batches. The generic
mechanism was deemed out of scope for this version, although it may
be included in a future version of this specification.
      </p>
    </section>

    <section>
      <h2>
Time Locks and DID Document Recovery
      </h2>

      <p>
Section <a href="#key-revocation-and-recovery"></a> mentions one
possible clever use of time locks to recover control of a <a>DID</a> after a
key compromise. The technique relies on an ability to override the
most recent update to a <a>DID document</a> with Authorization applied by an
earlier version of the <a>DID document</a> in order to defeat the attacker.
This protection depends on adding a <a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki%23Abstract">
time lock (see Bitcoin BIP 65)</a> to protect part of the transaction
chain, enabling a Authorization block to be used to recover control.
We plan to add support for time locks in a future version of this
specification.
      </p>
    </section>

    <section>
      <h2>
Smart Signatures
      </h2>

      <p>
Not all <a>DLTs</a> can support the Authorization logic in section
<a href="#authorization-and-delegation"></a>.
Therefore, in this version of the specification, all Authorization
logic is delegated to <a>DID method</a> specifications. A potential
future solution is a <a href="http://www.weboftrust.info/downloads/smart-signatures.pdf">Smart
Signature</a> specification that specifies the code any conformant
<a>DLT</a> may implement to process signature control logic.
      </p>
    </section>

    <section>
      <h2>
Verifiable Claims
      </h2>

      <p>
Although <a>DIDs</a> and <a>DID documents</a> form a foundation for decentralized
identity, they are only the first step in describing their subjects. The
rest of the descriptive power comes through collecting and
selectively using <a href="https://w3c.github.io/vctf/">verifiable
claims</a>. Future versions of the specification will describe in
more detail how <a>DIDs</a> and <a>DID document</a> can be integrated with &mdash; and help
enable &mdash; the verifiable claims ecosystem.
      </p>
    </section>

    <section>
      <h2>
Alternate Serializations and Graph Models
      </h2>

      <p>
This version of the specification relies on JSON-LD and the RDF graph
model for expressing a <a>DID document</a>. Future versions of this
specification might specify other semantic graph formats for a <a>DID
document</a>.
      </p>
    </section>
  </section>

  <section class="appendix">
    <h1>Current Issues</h1>

    <p>
The list of issues below are under active discussion and are likely to
result in changes to this specification.
    </p>

    <div class="issue" data-number="85">Syntactially differentiate data about the DID versus application data</div>
    <div class="issue" data-number="84">Add `initial-values` matrix parameter to Generic DID Parameters</div>
    <div class="issue" data-number="80">Define conformance classes such as "DID document processor"</div>
    <div class="issue" data-number="76">Bikeshed the DID specification short name</div>
    <div class="issue" data-number="75">tracking revocation of public keys</div>
    <div class="issue" data-number="72">Privacy Considerations - Specifically call out GDPR</div>
    <div class="issue" data-number="70">Enable instant DID use/resolution for DID Methods that include a propagation delay</div>
    <div class="issue" data-number="69">How to integrate certificates with DIDs?</div>
    <div class="issue" data-number="68">When do we publish a FPWD?</div>
    <div class="issue" data-number="67">Supported public key formats?</div>
    <div class="issue" data-number="65">Does DID Document metadata belong in the Document?</div>
    <div class="issue" data-number="64">Encrypted serviceEndpoint values?</div>
    <div class="issue" data-number="63">Add publicKeyHex as a valid publicKey format</div>
    <div class="issue" data-number="62">Add "service-type" DID URL matrix parameter.</div>
    <div class="issue" data-number="61">Add "content-type" and "content-id" DID URL matrix parameters.</div>
    <div class="issue" data-number="60">Add "key-type" DID URL matrix parameter.</div>
    <div class="issue" data-number="59">Add "key" DID URL matrix parameter.</div>
    <div class="issue" data-number="58">Registry handling</div>
    <div class="issue" data-number="57">Clarification of other verification methods in authentication section missing</div>
    <div class="issue" data-number="56">Added support for ethereumAddress in context - fixed #55</div>
    <div class="issue" data-number="55">Add support for ethereumAddress public key type in @context</div>
    <div class="issue" data-number="53">Normative vs. non-normative references</div>
    <div class="issue" data-number="52">(Minor note) update the IANA file</div>
    <div class="issue" data-number="51">[Convention] Method `0` (zero) become a well-known method for retrieving properties/metadata from/about a particular DID Server</div>
    <div class="issue" data-number="49">If an existing DID Document has a Service Endpoint fragment, what are the primary keys to be used if that Service Endpoint needs to be replaced, updated, or deleted?</div>
    <div class="issue" data-number="48">Some comments by Steven Rowat</div>
    <div class="issue" data-number="46">It would be useful to have `services` as a mapping instead of an `array`</div>
    <div class="issue" data-number="45">Is method-specific-id supposed to be equivalent to param-char?</div>
  </section>

  <section class="appendix">
    <h1>
Registries
    </h1>

    <p>
There are multiple registries that define <a>DID methods</a> and extensions to
this specification. These registries are:
    </p>

    <table class="simple">
      <thead>
        <tr>
          <th>
Registry
          </th>
          <th>
Purpose
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
<a href="https://w3c-ccg.github.io/did-method-registry/">DID
Method Registry</a>
          </td>
          <td>
Lists all known <a>DID methods</a> and contains links to their
specifications.
          </td>
        </tr>

        <tr>
          <td>
<a href="https://w3c-ccg.github.io/ld-cryptosuite-registry/">Linked Data
Cryptography Suite Registry</a>
          </td>
          <td>
Defines all known Linked Data Cryptography Suites and Key
Formats.
          </td>
        </tr>
      </tbody>
    </table>
  </section>

  <section class="appendix">
    <h1>
Real World Example
    </h1>

    <p>
A future-facing real-world context is provided below:
    </p>

    <pre class="example nohighlight" title="Advanced DID document example">
{
  "@context": "https://w3id.org/future-method/v1",
  "id": "did:example:123456789abcdefghi",

  "publicKey": [{
    "id": "did:example:123456789abcdefghi#keys-1",
    "type": "RsaVerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }, {
    "id": "did:example:123456789abcdefghi#keys-3",
    "type": "Ieee2410VerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }],

  "authentication": [
    <span class="comment">// this mechanism can be used to authenticate as did:...fghi</span>
    "did:example:123456789abcdefghi#keys-1",
    <span class="comment">// this mechanism can be used to biometrically authenticate as did:...fghi</span>
    "did:example:123456789abcdefghi#keys-3",
    <span class="comment">// this mechanism is *only* authorized for authentication, it may not</span>
    <span class="comment">// be used for any other proof purpose, so its full description is</span>
    <span class="comment">// embedded here rather than using only a reference</span>
    {
      "id": "did:example:123456789abcdefghi#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:example:123456789abcdefghi",
      "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
    }
  ],

  "service": [{
    "id": "did:example:123456789abcdefghi#oidc",
    "type": "OpenIdConnectVersion1.0Service",
    "serviceEndpoint": "https://openid.example.com/"
  }, {
    "id": "did:example:123456789abcdefghi#vcStore",
    "type": "CredentialRepositoryService",
    "serviceEndpoint": "https://repository.example.com/service/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#xdi",
    "type": "XdiService",
    "serviceEndpoint": "https://xdi.example.com/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#hub",
    "type": "HubService",
    "serviceEndpoint": "https://hub.example.com/.identity/did:example:0123456789abcdef/"
  }, {
    "id": "did:example:123456789abcdefghi#messaging",
    "type": "MessagingService",
    "serviceEndpoint": "https://example.com/messages/8377464"
  }, {
    "type": "SocialWebInboxService",
    "id": "did:example:123456789abcdefghi#inbox",
    "serviceEndpoint": "https://social.example.com/83hfh37dj",
    "description": "My public social inbox",
    "spamCost": {
      "amount": "0.50",
      "currency": "USD"
    }
  }, {
    "type": "DidAuthPushModeVersion1",
    "id": "did:example:123456789abcdefghi#push",
    "serviceEndpoint": "http://auth.example.com/did:example:123456789abcdefghi"
  }, {
    "id": "did:example:123456789abcdefghi#bops",
    "type": "BopsService",
    "serviceEndpoint": "https://bops.example.com/enterprise/"
  }]
}
</pre>
  </section>

</body>
</html>
