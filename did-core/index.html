<!DOCTYPE html>
<html lang=kr>

<head>
  <title>
    탈중앙 식별자 Decentralized Identifiers (DIDs) v1.0
  </title>
  <link rel="shortcut icon" type="image/png" href="https://www.w3.org/favicon.ico" />
  <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
  <!--
    === NOTA BENE ===
    For the three scripts below, if your spec resides on dev.w3 you can check them
    out in the same tree and use relative links so that they'll work offline.
   -->

  <script class='remove' src='https://www.w3.org/Tools/respec/respec-w3c-common'>
  </script>
  <!--script src='./respec-w3c-common.js' class='remove'></script-->

  <script class='remove' src="./common.js">
  </script>

  <script class="remove" type="text/javascript">
    var respecConfig = {
      wgPublicList: "public-did-wg",
      wgPatentURI: "https://www.w3.org/2004/01/pp-impl/117488/status",
      wg: "Decentralized Identifier Working Group",
      wgURI: "https://www.w3.org/2019/did-wg/",

      // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus: "WD",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName: "did-core",


      edDraftURI: "https://w3c.github.io/did-core/",

      // subtitle
      subtitle: "Core Data Model and Syntaxes",

      // if you wish the publication date to be other than today, set this
      publishDate: "2019-12-09",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      previousPublishDate: "2019-12-09",
      previousMaturity: "WD",

      // extend the bibliography entries
      localBiblio: ccg.localBiblio,
      github: {
        repoURL: "https://github.com/w3c/did-core/",
        branch: "master"
      },
      includePermalinks: false,


      // editors, add as many as you like
      // only "name" is required
      editors: [{
        name: "Drummond Reed",
        url: "https://www.linkedin.com/in/drummondreed/",
        company: "Evernym",
        companyURL: "https://www.evernym.com/",
        w3cid: 3096
      },
      {
        name: "Manu Sporny",
        url: "http://manu.sporny.org/",
        company: "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/",
        w3cid: 41758
      },
      {
        name: "Markus Sabadello",
        url: "https://www.linkedin.com/in/markus-sabadello-353a0821",
        company: "Danube Tech",
        companyURL: "https://danubetech.com/",
        w3cid: 46729
      }
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors: [{
        name: "Drummond Reed",
        url: "https://www.linkedin.com/in/drummondreed/",
        company: "Evernym",
        companyURL: "https://www.evernym.com/",
        w3cid: 3096
      },
      {
        name: "Manu Sporny",
        url: "http://manu.sporny.org/",
        company: "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/",
        w3cid: 41758
      },
      {
        name: "Dave Longley",
        url: "",
        company: "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/",
        w3cid: 48025
      },
      {
        name: "Christopher Allen",
        url: "https://www.linkedin.com/in/christophera",
        company: "Blockchain Commons",
        companyURL: "https://www.BlockchainCommons.com",
        w3cid: 85560
      },
      {
        name: "Ryan Grant",
        url: "",
        company: "",
        companyURL: ""
      },
      {
        name: "Markus Sabadello",
        url: "https://www.linkedin.com/in/markus-sabadello-353a0821",
        company: "Danube Tech",
        companyURL: "https://danubetech.com/",
        w3cid: 46729
      }
      ]
    };
  </script>
  <style>
    pre .highlight {
      font-weight: bold;
      color: green;
    }

    pre .comment {
      color: SteelBlue;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
</head>

<body>
  <div class="advisement" style="font-size:small">
    <p>
      이 문서는 <a href="https://www.w3.org/TR/did-core/">W3C Decentralized Identifiers (DIDs) v1.0</a>의 한국어
      번역본입니다.
    </p>
    <p>
      이 문서에 오역 및 오타를 포함할 수 있습니다. <b>영어 원문만이 공식적이고 규범적인 효력을 가지고 있습니다.</b><br/>
      문의나 개선사항은 <a href="https://github.com/ssimeetupkorea/ssimeetupkorea.github.io">깃헙 링크</a>나 <a href="mailto:jshim10@illinois.edu">jshim10@illinois.edu</a>로 연락주시기 바랍니다.
    </p>

    <p>
      번역일: 2020-01-01<br />
    </p>
    <dt>번역자 <span style="font-weight: 500;">(가나다순)</span>: </dt>
    <dd><a href="mailto:jshim10@illinois.edu" ]>심재훈</a> (<a href="https://lgcns.co.kr">LG CNS</a>)</dd>
    <dd><a href="mailto:anh1026@kaist.ac.kr" ]>안형철</a></dd>
    <dd><a href="mailto:example@gmail.com" ]>오효근</a></dd>
    <dd><a href="https://www.linkedin.com/in/minho-yoo-1b968837/" ]>유민호</a> (<a href="https://iotrust.kr/">IoTrust Co., Ltd.</a>)</dd>
    <dd><a href="mailto:example@gmail.com" ]>유수웅</a></dd>
    <dd><a href="mailto:example@gmail.com" ]>윤희태</a></dd>
    <dd><a href="mailto:example@gmail.com" ]>임도형</a></dd>
    <dd><a href="mailto:hyunsy822@gmail.com" ]>현수영</a></dd>
  </div>
  <section id='abstract'>
    <p>
      <a>탈중앙 식별자</a>(DIDs)는 검증가능하고 탈중앙화된 디지털 신원을 위한 새로운 형식의 식별자이다.
      이러한 새로운 식별자는 <a>DID 컨트롤러</a>가 DID의 제어권을 증명하고, 중앙화된 레지스트리, 신원 제공자, 인증기관 등으로부터 독립적으로 구현할 수 있도록 설계되었다.
      <a>DID</a>는 <a>DID 주체</a>와 관련된 URL로써, <a>DID 문서</a>라는 방식을 통해 해당 주체와 신뢰할 수 있는 상호작용을 가능하게하는 도구이다.
      <a>DID 문서</a>는 특정 DID를 어떻게 사용하는지에 대해 설명해 놓은 간단한 문서이다.
      각 <a>DID 문서</a>는 암호학적 요소, 검증 메소드, 서비스 엔드포인트 등으로 표현될 수 있다.
      해당요소들은 <a>DID 컨트롤러</a>가 DID의 통제권에 대한 증명을 가능하게 하는 메커니즘 집합을 제공한다.
      서비스 엔드포인트는 <a>DID 주체</a>와의 믿을 수 있는 상호작용을 가능하게 한다.
    </p>
    <p>
      본 문서는 일반 데이터 모델, URL 형식, <a>DID</a>를 위한 일련의 작동방식, <a>DID 문서</a> 그리고 <a>DID 메소드</a>에 대해 명시하고 있다.
    </p>
  </section>

  <section id='sotd'>
    This specification is under active development and implementers are advised
    against implementing the specification unless they are directly involved
    with the W3C DID Working Group. There are use cases [[?DID-USE-CASES]] in active
    development that establish requirements for this document.
    </p>

    <p>
      At present, there exist
      <a href="https://w3c-ccg.github.io/did-method-registry/#the-registry">40
        experimental implementations</a> and a preliminary
      <a href="https://github.com/w3c-ccg/did-test-suite/">test suite</a>
      that will eventually determine whether or not implementations are conformant.
      Readers are advised that Appendix <a href="#current-issues"></a> contains a
      list of concerns and proposed changes that will most likely result in
      alterations to this specification.
    </p>

    <p>
      Comments regarding this document are welcome. Please file issues
      directly on <a href="https://github.com/w3c/did-core/issues/">GitHub</a>,
      or send them
      to <a href="mailto:public-did-wg@w3.org">public-did-wg@w3.org</a> (
      <a href="mailto:public-did-wg-request@w3.org?subject=subscribe">subscribe</a>,
      <a href="https://lists.w3.org/Archives/Public/public-did-wg/">archives</a>).
    </p>

    <p>
      Portions of the work on this specification have been funded by the
      United States Department of Homeland Security's Science and Technology
      Directorate under contracts HSHQDC-16-R00012-H-SB2016-1-002 and
      HSHQDC-17-C-00019. The content of this specification does not
      necessarily reflect the position or the policy of the U.S. Government
      and no official endorsement should be inferred.
    </p>

    <p>
      Work on this specification has also been supported by the Rebooting the
      Web of Trust community facilitated by Christopher Allen, Shannon
      Appelcline, Kiara Robles, Brian Weller, Betty Dhamers, Kaliya Young,
      Kim Hamilton Duffy, Manu Sporny, Drummond Reed, Joe Andrieu, and
      Heather Vescent.
    </p>
  </section>

  <section class="informative">
    <h1>
      Introduction
    </h1>

    <p>
      기존의 ID 관리 시스템(<a href="https://en.wikipedia.org/wiki/Identity_management">identity management</a>)은 기업의 디렉토리
      서비스(<a href="https://en.wikipedia.org/wiki/Directory_service">directory services</a>), 인증 기관(,
      <a href="https://en.wikipedia.org/wiki/Certificate_authority">certificate authorities</a>) 또는 도메인 등록 기관(<a
        href="https://en.wikipedia.org/wiki/Domain_name_registry">domain name registries</a>)과 같은 중앙 집중식 기관을 기반으로 한다.
      암호학적 신뢰 검증의 관점에서 보면, 이들 중앙집중화 된 각 기관은 각각의 신뢰점(<a href="https://en.wikipedia.org/wiki/Trust_anchor">root of
        trust</a>)이 된다. 이러한 시스템들을 통해 ID 관리를 수행하려면 연합 ID 관리(<a
        href="https://en.wikipedia.org/wiki/Federated_identity">federated identity management</a>)를 구축해야 한다.
    </p>

    <p>
      <a>블록체인</a>이라고도 하는 분산원장기술(DLT, <a>Distributed ledger Technology</a>)의 출현은 완전한 <a>탈중앙 ID 관리</a> 기회를 제공한다. 탈중앙 신원
      시스템에서 개체(개인, 조직 및 기타 사항과 같은 제한이 없는 개별 식별 가능 단위)는 공유된 신뢰점을 자유롭게 사용할 수 있다. 전세계에 분산된 원장, 탈중앙 p2p 네트워크, 또는 유사한 기능을 가진
      다른 시스템은 권한의 집중이나 단일 장애점을 도입하지 않고 신뢰점를 관리할 수 있는 수단을 제공한다. <a>DLTs</a>(분산원장기술들)과 <a>탈중앙 ID 관리</a>를 결합한 시스템에서는 누구나
      분산되고, 신뢰점과 독립적인 자신의 식별자들을 생성하고 관리 할 수 있다.
    </p>

    <p>
      개체들은 <a>탈중앙 식별자</a>(<a>DIDs</a>)에 의해 식별되며, 증명(예: 디지털 서명, 생체인식 등)을 통해 인증할 수 있다. <a>DIDs</a>는 <a>DID 문서들</a>(<a>DID
        documents</a>)을 참조한다. <a>DID 문서</a>는 <a>DID</a> 식별자와 주체가 상호 작용을 하기 위한 <a>서비스 엔드포인트</a>들을 포함한다. 프라이버시 디자인[<a
        href="https://en.wikipedia.org/wiki/Privacy_by_design">Privacy by
        Design</a>] 가이드라인에 따라, 개체들은 신원, 페르소나, 그리고 컨텍스트들에 따라 구분하고 싶은 바람을 따라 자신이 원하는 만큼 많은 <a>DIDs</a>(<a>DID 문서</a>와
      <a>서비스 엔드포인트</a>들이 포함된)를 가질 수 있다.
    </p>

    <p>
      <a>DID 메소드</a>는 특정 <a>분산 원장</a> 또는 네트워크에서 <a>DID</a>와 관련된 <a>DID 문서</a>들을 생성, 읽기, 갱신, 그리고 비활성화 하는 메커니즘이다. <a>DID
        메소드들</a>은 별도의 <a>DID 메소드</a> 규격을 사용하여 정의한다.
    </p>

    <p>
      이 설계는 중앙 집중식 레지스트리와 공개키 기반구조(<a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">PKI, public key
        infrastructure</a>)의 중앙 집중식 인증 기관에 대한 식별자의 의존성을 제거 한다. <a>DID 레지스트리</a>가 <a>분산 원장</a>인 경우, 각 개체는 자체 인증 기관의 역할을 할
      수 있으며, 이것을 분권화된 <a
        href="https://github.com/WebOfTrustInfo/rebooting-the-web-of-trust/blob/master/final-documents/dpki.pdf">PKI-
        DPKI(decentralized PKI)</a>라고 한다.
    </p>

    <p class="note">
      참고로 <a>DID 메소드</a>들은 연합, 또는 중앙집중식 ID 관리 시스템에 등록된 식별자로도 사용될 수 있다. 이것을 위해, 모든 유형의 식별자 시스템에 <a>DIDs</a> 지원을 추가할 수 있다.
      이로 인해 중앙집중, 연합 및 <a>탈중앙 식별자</a>들 사이의 상호 운용성이 형성 된다.
    </p>

    <p>
      이 규격의 첫번째 목적은 일반적인 <a>DID 스키마</a>와 일반적인 <a>DID 문서</a>들에서 동작하는 명령어 집합을 모든 <a>DID 레지스트리</a>에 구현될 수 있도록 정의하는 것 이다. 이
      규격의 두번째 목적은 <a>DID 메소드</a>를 위한 적합 요구조건(특정 <a>DID 레지스트리</a>를 위한 특정 <a>DID 스키마</a>와 특정 <a>DID 문서</a>에서 동작하는 명령어 세트를
      정의하는 별도의 규격)을 정의하기 위함이다.
    </p>

    <p class="note">
      개념적으로, 이 규격(Decentralized Identifiers)과 <a>DID 메소드</a> 규격의 관계는 IETF 일반 <a>URI</a> 규격([[RFC3986]])과 특정 <a>URI</a>
      체계([[IANA-URI-SCHEMES]])([[RFC7230]]에 명시된 http:와 https: 체계)의 관계와 유사하다. IETF 일반 URN 규격([[RFC8141]]) 및 특정 URN 네임스페이스
      정의([[RFC4122]]에 정의된 <a>UUID</a> URN 네임스페이스 등과 같은)의 관계와도 역시 유사하다.
      차이점은 <a>DID 메소드</a> 규격은 특정 <a>DID 스키마</a>를 정의하는 것 외에도, 적절한 <a>DID 레지스트리</a>에서 <a>DIDs</a>의 구별방법을 제공하거나, 비활성화하거나,
      <a>DID 문서</a>를 작성하는 방법을 명시한다는 것이다.
    </p>

    <p>
      특정 <a>DID 메소드</a> 규격을 가진 일반 <a>DID</a> 규격의 계층적 설계는 <a>URI</a> 규격과 동일한 개념의 일부를 도입한다:
    </p>
    <ul>
      <li>
        다른 URI 체계의 <a>URIs</a>가 상호운용되지 않는 것처럼, 다른 <a>DID 메소드</a>의 <a>DIDs</a>는 상호운용되지 않을 수 있다.
      </li>
      <li>
        일부 브라우저가 특정 URI 체계만 지원하는 경우와 같이, 특정한 <a>DID 메소드</a>만을 지원하는 관계의 지원을 받기 위해 복수의 <a>DIDs</a>가 필요할 수 있다.
      </li>
      <li>
        모든 브라우저가 동일한 URI 체계를 지원하지 않는 것과 같이, 모든 <a>DID 메소드</a>가 동일한 암호 체계를 지원하지는 않기 때문에, 다른 암호화 체계를 지원하기 위해 복수의
        <a>DIDs</a>가 필요할 수 있다.
      </li>
      <li>
        복수의 <a>DIDs</a>의 관리 및 그리고 어떤 <a>DID</a>가 어떤 관계에 속하는지 추적하는 것은, 어떤 웹 주소가 어떤 웹사이트에 속하는지 추적하거나 어떤 이메일 주소가 어떤 관계에
        속하는지 추적하는 것과 유사한 문제를 야기한다.
      </li>
    </ul>

    <p>
      <a>DID 메소드</a> 및 규격 목록은 [[DID-METHOD-REGISTRY]]를 참조하십시오.
    </p>

    <section class="informative">
      <h2>
        A Simple Example
      </h2>

      <p>
        <a>DID</a>는 3부분으로 구성된 간단한 문자열입니다.:
      </p>
      <ul>
        <li>
          URL scheme identifier (<code>did</code>)
        </li>
        <li>
          Identifier for the <a>DID method</a>
        </li>
        <li>
          DID method-specific identifier.
        </li>
      </ul>

      <pre class="example nohighlight" title="A simple example of a decentralized identifier (DID)">
did:example:123456789abcdefghi
    </pre>

      <p>
        위의 예제 <a>DID</a>는 <a>DID 문서</a>로 해석됩니다. <a>DID 문서</a>에는 <a>DID</a>를 제어하여 개체를 암호학적으로 인증하는 방법 및 개체와 상호 작용하는 데 사용할
        수있는 서비스와 같이 <a>DID</a>와 관련된 정보가 포함되어 있다.
      </p>

      <pre class="example nohighlight" title="Minimal self-managed DID document">
{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:example:123456789abcdefghi",
  "authentication": [{
    <span class="comment">// used to authenticate as did:...fghi</span>
    "id": "did:example:123456789abcdefghi#keys-1",
    "type": "RsaVerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }],
  "service": [{
    <span class="comment">// used to retrieve Verifiable Credentials associated with the DID</span>
    "id":"did:example:123456789abcdefghi#vcs",
    "type": "VerifiableCredentialService",
    "serviceEndpoint": "https://example.com/vc/"
  }]
}
    </pre>
    </section>

    <section class="informative">
      <h2>
        Design Goals
      </h2>

      <p>
        <a>탈중앙 식별자들</a>은 [[?VC-DATA-MODEL]]과 같은 검증가능한 증명생태계와 같은 더 큰 시스템의 구성요소이며, 이 규격의 설계를 주도 했다. 이 절에는 이 규격의 기본 설계 목표가
        요약되어 있다.
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>
              Goal
            </th>
            <th>
              Description
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              Decentralization
            </td>
            <td>
              글로벌 고유 식별자, 공개 확인 키, <a>서비스 엔드포인트</a> 및 기타 메타 데이터의 등록을 포함한, 식별자 관리에서 중앙집중식 기관, 또는 단일실패점 요소를 제거해야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Control
            </td>
            <td>
              주어진 개체, 인간과 비인간 모두에게 외부 기관에 의존하지 않고 디지털 식별자를 직접 제어 할 수있는 권한을 부여하십시오.
            </td>
          </tr>

          <tr>
            <td>
              Privacy
            </td>
            <td>
              개체가 속성 또는 기타 데이터의 최소, 선택적 및 점진적 공개를 포함하여 정보의 프라이버시를 제어 할 수 있도록한다.
            </td>
          </tr>

          <tr>
            <td>
              Security
            </td>
            <td>
              필요한 수준의 보증을 위해 <a>DID 문서</a>에 의존할 수 있도록 RP(relying parties)들에게 충분한 보안을 제공한다.
            </td>
          </tr>

          <tr>
            <td>
              Proof-based
            </td>
            <td>
              다른 개체와 상호작용할 때 <a>DID 주체</a>가 암호화 증명을 제공 할 수 있어야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Discoverability
            </td>
            <td>
              다른 개체가 해당 개체에 대해 더 많이 학습하거나 상호 작용할 수 있도록 <a>DIDs</a>를 검색 할 수 있어야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Interoperability
            </td>
            <td>
              <a>DID</a> 인프라는 상호운용성을 위해 설계된 기존 툴과 소프트웨어 라이브러리를 이용할 수 있도록 상호운용성 표준을 사용해야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Portability
            </td>
            <td>
              시스템과 네트워크에 독립적이어야 하며 기업이 <a>DIDs</a> 및 <a>DID 메소드</a>를 지원하는 모든 시스템과 함께 디지털 식별자를 사용할 수 있도록 해야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Simplicity
            </td>
            <td>
              기술을보다 쉽게 이해하고, 구현 및 배포 할 수 있도록 축소 된 간단한 기능을 선호해야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Extensibility
            </td>
            <td>
              상호운용성(Interoperability), 이식성(Portability) 또는 단순성(Simplicity)을 크게 방해하지 않는 경우 가능한 확장할 수 있다.
            </td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h3>
        Interoperability
      </h3>

      <p>
        <a>DIDs</a>와 <a>DID 문서</a>의 구현 상호운용성은 규격에 부합하는 <a>DIDs</a> 및 <a>DID 문서</a>를 작성하고 분석할 수 있는 구현 능력을 평가하여 시험한다.
        <a>DID 메소드</a>의 상호운용성은 최소한 다음과 같이 최소 규격을 평가함으로써 결정된다.:
      </p>
      <ul>
        <li>
          <a>DID 메소드</a> 이름은 겹치지 않고 유일해야 하며, <a>DID 메소드</a>의 기존용례와 모순된 사용은 하지 못한다.
        </li>
        <li>
          요구되는 기능들이 지원되어져야 한다.
        </li>
        <li>
          설명이 필요한 작업에 대해 설명되어야 한다.
        </li>
        <li>
          규격은 독립적 구현을 위해 충분히 구체적이고 상세하고 완전해야 한다.
        </li>
        <li>
          규격은 보안 및 프라이버시 고려사항을 기술하는 섹션을 포함해야 한다.
        </li>
      </ul>

      <p>
        <a>DIDs</a> 및 <a>DID 문서</a>의 생산자와 소비자를 위한 상호운용성은 <a>DIDs</a> 및 <a>DID 문서</a>가 일치하는지 확인함으로써 보장된다. <a>DID 메소드</a>
        규격에 대한 상호운용성은 각 <a>DID 메소드</a> 규격에 있는 세부사항에 의해 보장된다. 웹 브라우저가 알려진 모든 URIs 스키마를 구현할 필요가 없는 것처럼, <a>DIDs</a>와 함께
        작동하는 호환 소프트웨어는 알려진 모든 <a>DID 메소드</a>를 구현할 필요가 없음을 이해해야한다. 그러나 지정된 <a>DID 메소드</a>의 모든 구현은 해당 메소드에 대해 상호운용성이
        보장해야한다.
      </p>
    </section>

  </section>

  <section id="terminology" class="informative">
    <h1>
      용어
    </h1>

    <div data-include="terms.html" data-oninclude="restrictReferences">
    </div>

  </section>

  <section id="data-model" class="informative">
    <h1>
      Data Model
    </h1>

    <p>
      This section outlines the <a>decentralized identifier</a> data model concepts,
      specifically, how keys, services, and the <a>DID subject</a> are related to the
      <a>DID document</a>.
    </p>

    <p>
      For more information about how the data model can be extended, see Section
      <a href="#extensibility"></a>.
    </p>

    <section>
      <h2>
        Identifier
      </h2>

      <p>
        Identifiers are used in the data model to identify specific instances of people,
        organizations, devices, keys, services, and things in general. Identifiers are
        typically URLs, or more generally, <a>URIs</a>. Non-<a>URI</a>-based identifiers
        are not advised because, while the data model supports them, they are not easy
        to use with other Internet-based identifiers.
      </p>
    </section>

    <section id="did-document">
      <h2>
        DID Document
      </h2>

      <p>
        A <a>DID document</a> is the resource that is associated with a
        <a>decentralized identifier</a> (DID). <a>DID documents</a> typically express
        verification methods (such as public keys) and services that can be used to
        interact with a <a>DID controller</a>.
      </p>

      <p>
        A <a>DID document</a> is serialized according to a particular syntax, as
        outlined in Section <a href="#did-document-syntax"></a>). The <a>DID</a> itself
        is contained in the <code>id</code> property.
      </p>

      <p>
        The properties that can be present in a <a>DID document</a> are outlined in
        Section <a href="#did-documents"></a>.
      </p>

      <p>
        The properties present in a <a>DID document</a> can be updated according to
        the applicable operations outlined in Section <a href="#did-methods"></a>.
      </p>
    </section>

    <section>
      <h2>
        Cryptographic Keys and Other Verification Methods
      </h2>

      <p>
        A <a>DID document</a> can express cryptographic keys and other verification
        methods, which can be used to authenticate or authorize interactions with the
        <a>DID subject</a> or associated parties. The information expressed often
        includes globally unambiguous identifiers and public key material, which can be
        used to verify digital signatures. Other information can be expressed, such as
        status information for the key (for example, whether it is suspended or
        revoked), or other attributes that enable one to determine whether it is a
        hardware-backed cryptographic key.
      </p>

      <p>
        Regarding cryptographic key material, public keys can be included in a
        <a>DID document</a> using, for example, the <code>publicKey</code> or
        <code>authentication</code> properties, depending on what they are to be used
        for. Each public key has an identifier (<code>id</code>) of its own, a
        <code>type</code>, and a <code>controller</code>, as well as other properties
        that depend on the type of key it is. For more information, see Section
        <a href="#public-keys"></a>.
      </p>
    </section>

    <p>
      This specification strives to limit the number of formats for expressing public
      key material in a DID Document to the fewest possible, to increase the
      likelihood of interoperability. The fewer formats that implementers have to
      implement, the more likely it will be that they will support all of them. This
      approach attempts to strike a delicate balance between ease of implementation
      and supporting formats that have historically had broad deployment. The specific
      types of key formats that are supported in this specification are listed in <a href="#public-keys"></a>.
    </p>
  </section>

  <section>
    <h2>
      Services
    </h2>

    <p>
      <a>Service endpoints</a> are used in <a>DID documents</a> to express ways of
      communicating with the <a>DID subject</a> or associated entities. Services
      listed in the <a>DID document</a> can contain information about privacy
      preserving messaging services, or more public information, such as social media
      accounts, personal websites, and email addresses. The metadata associated with
      services are often service-specific. For example, the metadata associated with
      an encrypted messaging service can express how to initiate the encrypted link
      before messaging begins.
    </p>

    <p>
      Pointers to services are expressed using the <code>service</code> property.
      Each service has its own <code>id</code> and <code>type</code>, as well as a
      <code>serviceEndpoint</code> with a <a>URI</a> or other properties describing
      the service.
    </p>

    <p>
      For more information, see Section <a href="#service-endpoints"></a>.
    </p>
  </section>

  </section>

  <section class="normative">
    <h1>
      탈중앙 식별자 (DIDs)
    </h1>
    <p>
      전역에서 유일한 <a>탈중앙 식별자</a>는 새로운 개념은 아니다.
      <a>범용고유식별자</a>(UUIDs)는 1980년대에 처음 개발되었고 향후 개방소프트웨어재단의 <a
        href="https://en.wikipedia.org/wiki/Distributed_Computing_Environment">분산 컴퓨팅 환경</a>에서 표준 기능이 되었다.
      <a>UUID</a>는 충돌 가능성이 무한히 작을 정도로 충분한 엔트로피를 가진 128bit 값을 생성하는 알고리즘을 통해
      중앙화된 등록 서비스 없이도 글로벌 유일성을 가질 수 있다.
      <a>UUID</a>는 [RFC4122]에서 URN(Unified Resource Name)의 특정 형식으로써 공식 명시되어 있다.
    </p>

    <p>
      <a>DID</a>는 아래 사항을 제외하고는 <a>UUID</a>와 유사하다:
    </p>
    <ul>
      <li>
        URL과 동일하게, 주체에 대해 설명하는 일반 자원을 주소 분해(Resolve)하거나 역참조(Dereferenced)한다.
        더 상세한 내용은 섹션 <a href="#did-documents">5. DID Documents</a> 참조.
      </li>
      <li>
        URL을 역참조 할 경우 반환되는 리소스와는 다르게, <a>DID 문서</a>는 일반적으로 <a>DID 주체</a>에 대한 인증을 가능하게 하는 암호학적 요소를 포함하고 있다.
      </li>
    </ul>

    <section id="generic-did-syntax">
      <h2>
        일반 DID 구문
      </h2>

      <p>
        일반 <a>DID 스키마</a>는 [[!RFC3986]]을 준수하는 URI 체계이다.
        <a>DID 스키마</a>는 <a>DID URL</a> 체계 및 권한 구성 요소에만 특화되어 있다.
        <code>path-abempty</code>, <code>query</code>, 그리고 <code>fragment</code> 구성 요소들은 [[!RFC3986]]에서 정의된 ABNF 규칙과
        동일하다.
      </p>

      <p class="note">
        <a>DID</a>라는 용어는 아래와 같이 ABNF의 <code>did</code> 규칙을 따르는 URI만을 의미한다.
        <a>DID</a>는 <a>DID 주체</a>를 항상 식별한다.
        <a>DID URL</a>이라는 용어는 <code>did-url</code> 규칙에 따라 정의되는데, <a>DID</a>로 시작하고 그 뒤에 하나 이상의 구성 요소가 추가되는 URL을 나타낸다.
        <a>DID URL</a>은 찾아야 할 리소스를 항상 식별한다.
      </p>

      <p>
        아래는 <code>ALPHA</code>와 <code>DIGIT</code>을 정의하는 [[!RFC5234]] 구문을 사용하는 ABNF 정의에 대한 것이다.
        ABNF에서 정의되지 않은 다른 모든 규칙 이름들은 RFC3986에 정의되어 있다.
      </p>

      <pre class="nohighlight">
did                = "did:" method-name ":" method-specific-id
method-name        = 1*method-char
method-char        = %x61-7A / DIGIT
method-specific-id = *idchar *( ":" *idchar )
idchar             = ALPHA / DIGIT / "." / "-" / "_"
did-url            = did *( ";" param ) path-abempty [ "?" query ]
                     [ "#" fragment ]
param              = param-name [ "=" param-value ]
param-name         = 1*param-char
param-value        = *param-char
param-char         = ALPHA / DIGIT / "." / "-" / "_" / ":" /
                     pct-encoded
      </pre>

      <p class="issue" data-number="34">
        The grammar currently allows an empty <code>method-specific-id</code>,
        e.g., <code>did:example:</code> would be a valid <a>DID</a> that could identify
        the <a>DID method</a> itself.
      </p>

    </section>

    <section>
      <h2>
        메소드 특화 구문
      </h2>

      <p>
        <a>DID 메소드</a> 명세는 반드시 <code>method-name</code>과 <code>method-specific-id</code> 구문을 정의함으로써 일반 DID 구문을 추가로 제한해야
        한다.
        더 상세한 내용은 섹션 <a href="#did-methods">7. DID Methods</a> 참조.
      </p>
    </section>

    <section>
      <h2>
        일반 DID 매개변수 이름
      </h2>

      <p>
        <a>DID URL</a> 구문은 matrix parameter 구문([[MATRIX-URIS]])을 기반의 매개변수를 위한 간단하고 일반화 된 포멧을 지원한다.
        위의 ABNF는 매개변수 이름에 대해 어떠한 것도 특정하지 않는다 (<code>param-name</code> 규칙)
      </p>
      <p>
        일부 일반 DID 매개변수 이름(예를들면, 서비스 선택을 위한)은 어떠한 특정 <a>DID 메소드</a>와 완전히 독립적이어야 하며,
        반드시 모든 <a>DID</a>와 동일하게 작동해야만 한다.
        그 외(예를들면, 버전관리를 위한)는 특정 <a>DID 메소드</a>에 의해 지원될 수 있지만,
        반드시 <a>DID 메소드</a>가 그것을 지원하는 방식으로 동일하게 작동해야만 한다.
      </p>
      <p>
        메소드에 완전히 특화된 매개변수 이름은 <a href="#method-specific-did-parameter-names">
          4.4 Method-Specific DID Parameter Names</a>에서 설명하고 있다.
      </p>
      <p>
        아래 표는 일반 DID 매개변수 이름 세트를 정의하고 있다:
      </p>
      <table class="simple">
        <thead>
          <tr>
            <th>
              일반 DID 매개변수 이름
            </th>
            <th>
              설명
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              <code>hl</code>
            </td>
            <td>
              [HASHLINK]에 명시된, 무결성 보호를 추가하기 위한 <a>DID 문서</a>의 자원 해시
            </td>
          </tr>
          <tr>
            <td>
              <code>service</code>
            </td>
            <td>
              서비스 ID를 통해 DID 문서로 부터 서비스를 식별
            </td>
          </tr>
          <tr>
            <td>
              <code>version-id</code>
            </td>
            <td>
              해석할 <a>DID 문서</a>의 특정 버전을 식별 (버전 ID는 순차적이거나 <a>UUID</a>이거나 메소드에 특화될 수 있음.
              이 매개변수는 모든 <a>DID 메소드</a>에서 지원하지 않을 수 있음에 주의
            </td>
          </tr>

          <tr>
            <td>
              <code>version-time</code>
            </td>
            <td>
              해석할 <a>DID 문서</a>의 특정 버전 타임스탬프를 식별. 즉, 특정 시간의 <a>DID</a>에 대해 <a>DID 문서</a>가 유효하다는 것을 의미.
              이 매개변수는 모든 <a>DID 메소드</a>에서 지원하지 않을 수 있음에 주의
            </td>
          </tr>
        </tbody>
      </table>

      <p>
        위 매개변수들을 위한 정확한 처리 규칙은 [[DID-RESOLUTION]]에 명시되어 있다.
      </p>

      <p class="note">
        DID URL에 포함되지는 않지만 <a>DID 리졸버</a>에 <em>대역외(Out-of-band)</em>로 전달하는 추가적인 매개변수나 옵션이 있을 수 있다.
        예를들면, Resolution 프로토콜 혹은 다른 어떤 메커니즘을 사용하는 것이다.
        이러한 옵션은 캐싱(Caching) 또는 기대하는 Resolution 결과에 대한 형식을 제어할 수도 있다.
        이것은 HTTP와 유사하게 캐싱 또는 결과 형식이 HTTP URL의 일부가 아닌 HTTP 헤더에 표현되는 것과 같다.
        중요한 구별점은 <a>DID URL</a>의 일부가 아닌 DID 매개변수는 어떠한 자원이 식별되는지를 지정하는 반면,
        <a>DID URL</a>의 일부가 아닌 <a>DID 리졸버</a> 옵션은 해당 자원이 어떻게 역참조하는지를 제어한다는 점이다.
      </p>
    </section>

    <section>
      <h2>
        Method-Specific DID Parameter Names
      </h2>

      <p>
        A <a>DID method</a> specification MAY specify additional method-specific
        parameter names. A method-specific parameter name MUST be prefixed by the method
        name, as defined by the <code>method-name</code> rule.
      </p>

      <p>
        For example, if the method <code>did:foo:</code> defines the parameter bar, the
        parameter name must be <code>foo:bar</code>. An example <a>DID URL</a> using
        this method and this method-specific parameter would be as shown below.
      </p>

      <pre class="example nohighlight">
did:foo:21tDAKCERh95uGgKbJNHYp;foo:bar=high
      </pre>

      <p class="issue" data-number="35">
        Consider using kebab-case style instead of colon separator,
        e.g., <code>foo-bar</code> instead of <code>foo:bar</code>.
      </p>

      <p>
        A method-specific parameter name defined by one <a>DID method</a> MAY be used by
        other <a>DID methods</a>.
      </p>

      <pre class="example nohighlight">
did:example:21tDAKCERh95uGgKbJNHYp;foo:bar=low
      </pre>

      <p>
        Method-specific parameter names MAY be combined with generic parameter names in
        any order.
      </p>

      <pre class="example nohighlight">
did:example:21tDAKCERh95uGgKbJNHYp;service=agent;foo:bar=high
      </pre>

      <p>
        Both <a>DID method</a> namespaces and method-specific parameter namespaces MAY
        include colons, so they might be partitioned hierarchically, as defined by a
        <a>DID method</a> specification. The following example <a>DID URL</a>
        illustrates both.
      </p>

      <pre class="example nohighlight">
did:foo:baz:21tDAKCERh95uGgKbJNHYp;foo:baz:hex=b612
      </pre>
    </section>

    <p class="issue" data-number="36">
      Review what exactly we want to say about method-specific parameters
      defined by one method but used in a <a>DID URL</a> with a different method.
      Also discuss hierarchical method namespaces in DID parameter names.
    </p>

    <section>
      <h2>
        Path
      </h2>

      <p>
        A generic <a>DID path</a> is identical to a URI path and MUST conform to the
        <code>path-abempty</code> ABNF rule in [[!RFC3986]]. A <a>DID path</a> SHOULD be
        used to address resources available through a <a>service endpoint</a>. For more
        information, see Section <a href="#service-endpoints"></a>.
      </p>

      <p>
        A specific <a>DID scheme</a> MAY specify ABNF rules for <a>DID paths</a> that
        are more restrictive than the generic rules in this section.
      </p>

      <pre class="example nohighlight">
did:example:123456/path
      </pre>
    </section>

    <section>
      <h2>
        Query
      </h2>

      <p>
        A generic <a>DID query</a> is identical to a URI query and MUST conform to the
        <code>query</code> ABNF rule in [[!RFC3986]]. A <a>DID query</a> SHOULD be used
        to address resources available through a <a>service endpoint</a>. For more
        information, see Section <a href="#service-endpoints"></a>.
      </p>

      <p>
        A specific <a>DID scheme</a> MAY specify ABNF rules for <a>DID queries</a> that
        are more restrictive than the generic rules in this section.
      </p>

      <pre class="example nohighlight">
did:example:123456?query=true
      </pre>
    </section>

    <section>
      <h2>
        Fragment
      </h2>

      <p>
        A generic <a>DID fragment</a> is identical to a URI fragment and MUST conform to
        the <code>fragment</code> ABNF rule in [[RFC3986]]. Implementers are strongly
        discouraged from using a <a>DID fragment</a> for anything other than a
        method-independent reference into the <a>DID document</a> to identify a
        component of a <a>DID document</a> (for example, a unique
        <a>public key description</a> or <a>service endpoint</a>). To resolve this
        reference, the complete <a>DID URL</a> including the <a>DID fragment</a> MUST be
        used as input to the <a>DID URL</a> dereferencing algorithm for the
        target component in the <a>DID document</a> object. For more information, see
        [[DID-RESOLUTION]].
      </p>

      <p>
        A specific <a>DID scheme</a> MAY specify ABNF rules for <a>DID fragments</a>
        that are more restrictive than the generic rules in this section.
      </p>

      <p>
        Implementations need not rely on graph-based processing of <a>DID documents</a>
        to locate metadata contained in the <a>DID document</a> when the <a>DID</a>
        includes a <a>DID fragment</a>. Tree-based processing can be used instead.
      </p>

      <p>
        Implementations SHOULD NOT prevent the use of <a>JSON Pointer</a>
        ([[!RFC6901]]).
      </p>

      <pre class="example nohighlight">
did:example:123456#oidc
      </pre>
    </section>

    <section>
      <h2>
        Normalization
      </h2>

      <p>
        For the broadest interoperability, make <a>DID</a> normalization as simple and
        universal as possible:
      </p>
      <ul>
        <li>
          The <a>DID scheme</a> name MUST be lowercase.
        </li>

        <li>
          The <a>DID method</a> name MUST be lowercase.
        </li>

        <li>
          Case sensitivity and normalization of the value of the
          <code>method-specific-id</code> rule in Section
          <a href="#generic-did-syntax"></a> MUST be defined by the governing
          <a>DID method</a> specification.
        </li>
      </ul>
    </section>

    <section>
      <h2>
        Persistence
      </h2>

      <p>
        A <a>DID</a> is expected to be persistent and immutable. That is, a <a>DID</a>
        is bound exclusively and permanently to its one and only subject. Even after a
        <a>DID</a> is deactivated, it is intended that it never be repurposed.
      </p>

      <p>
        Ideally, a <a>DID</a> would be a completely abstract decentralized identifier
        (like a <a>UUID</a>) that could be bound to multiple underlying
        <a>DID registries</a> over time, thus maintaining its persistence independent of
        any particular system. However, registering the same identifier on multiple
        <a>DID registries</a> introduces extremely hard entityship and
        <a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types%23SOA">start-of-authority</a>
        (SOA) problems. It also greatly increases implementation complexity for
        developers.
      </p>

      <p>
        To avoid these issues, it is RECOMMENDED that <a>DID method</a> specifications
        only produce <a>DIDs</a> and <a>DID methods</a> bound to strong, stable
        <a>DID registries</a> capable of making the highest level of commitment to
        persistence of the <a>DID</a> and <a>DID method</a> over time.
      </p>

      <p class="note">
        Although not included in this version, future versions of this specification
        might support a <a>DID document</a> <code>equivID</code> property to establish
        verifiable equivalence relations between <a>DIDs</a> representing the same
        subject on multiple <a>DID registries</a>. Such equivalence relations can
        produce the practical equivalent of a single persistent abstract <a>DID</a>. For
        more information, see Section <a href="#future-work"></a>.
      </p>
    </section>
  </section>

  <section class="normative">
    <h1>
      DID Documents
    </h1>

    <p>
      A <a>DID</a> points to a <a>DID document</a>. <a>DID documents</a> are the
      serialization of the <a href="#data-model"></a>.
      The following sections define the properties in a <a>DID document</a>,
      including whether these properties are required or optional.
    </p>

    <section>
      <h2>Contexts</h2>

      <p>
        When two software systems need to exchange data, they need to use terminology
        and a protocol that both systems understand. The <code>@context</code>
        property ensures that two systems operating on the same DID document are using
        mutually agreed terminology.
      </p>

      <p>
        <a>DID documents</a> MUST include the <code>@context</code> property.
      </p>

      <p class="note" title="The JSON-LD Context">
        More information about the
        <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD Context</a>
        in general can be found in the [[JSON-LD]] specification.
      </p>

      <dl>
        <dt><dfn>@context</dfn></dt>
        <dd>
          The value of the <code>@context</code> property MUST be one or more
          <a>URIs</a>, where the value of the first <a>URI</a> is
          <code>https://www.w3.org/ns/did/v1</code>. If more than one
          <a>URI</a> is provided, the <a>URIs</a> MUST be interpreted as an ordered set.
          It is RECOMMENDED that dereferencing the <a>URIs</a> results in a document
          containing machine-readable information about the context.
        </dd>
      </dl>

      <p>
        Example:
      </p>

      <pre class="example nohighlight">
{
  "@context": "https://www.w3.org/ns/did/v1"
}
</pre>
      <p>
        <a>DID method</a> specifications MAY define their own JSON-LD contexts.
        However it is NOT RECOMMENDED to define a new context unless
        necessary to properly implement the method. Method-specific contexts
        MUST NOT override the terms defined in the generic <a>DID</a> context.
      </p>
    </section>

    <section>
      <h2>
        DID Subject
      </h2>

      <p>
        The <a>DID subject</a> is denoted with the <code>id</code> property.
        This is the entity that the <a>DID document</a> is about, i.e.,
        it is the entity identified by the <a>DID</a> and described by the <a>DID document</a>.
      </p>

      <p>
        <a>DID documents</a> MUST include the <code>id</code> property.
      </p>

      <dl>
        <dt><dfn>id</dfn></dt>
        <dd>
          The value of <code>id</code> MUST be a single valid <a>DID</a>.
        </dd>
      </dl>

      <p>
        Example:
      </p>

      <pre class="example nohighlight">
{
  "id": "did:example:21tDAKCERh95uGgKbJNHYp"
}
      </pre>
      <p class="note">
        <a>DID method</a> specifications can create intermediate representations of
        a <a>DID document</a> that do not contain the <code>id</code> key, such as
        when a <a>DID resolver</a> is performing resolution. However, the fully
        resolved <a>DID document</a> always contains a valid <code>id</code> property.
        The value of <code>id</code> in the resolved <a>DID document</a> is expected
        to match the <a>DID</a> that was resolved.
      </p>
    </section>
    <!-- section>
      <h2>Delegates</h2>
        <p class="issue">
The way that Delegates are handled is changing. The feature is still supported,
but via the `authorizationCapability` field rather than the more specialized
`guardian` field.
        </p>
        <p>
A delegate is an entity, such as a parent or aid organization, that creates and
maintains a <a>DID document</a> for a dependent who is not in a position to hold
or control authentication credentials (e.g., cryptographic keys).
        </p>
        <p>
The rules for a delegate are:
        </p>
        <ol start="1">
          <li>
A <a>DID document</a> that includes an
<code>authentication</code> field
(Section <a href="#authentication"></a>) MAY list one or
more delegates via the <code>authorizationCapability</code> field.
          </li>
          <li>
A <a>DID document</a> that does not include an
<code>authentication</code> MUST have a delegate.
          </li>
          <li>
The <code>authorizationCapability</code> field must contain a capability for the
delegate that includes <code>UpdateDidDocument</code> as the capability,
the <a>DID</a> of the delegate as the <code>entity</code>, and MAY include a
more specific set of <code>authentication</code>s that the
delegate MAY use to authenticate when updating the <a>DID document</a>.
          </li>
          <li>
The delegate <a>DID</a> MUST resolve to a <a>DID document</a> that has a
<code>authentication</code> property containing at least one value,
i.e., the delegate relationships must not be nested.
          </li>
        </ol>
        <p>
Example:
        </p>
<pre class="example nohighlight" title="Basic DID document">
{
"@context": "https://www.w3.org/ns/did/v1",
"id": "did:example:123456789abcdefghi",
"authorizationCapability": [{
  // this entity is a delegate and may update any field in this
  // DID document using any authentication mechanism understood
  // by the ledger
  "permission": "UpdateDidDocument",
  "entity": "did:example:zxyvwtrkpn987654321"
}],
"authentication": [{
  // this biometric can be used to authenticate as did:...fghi
  "type": "PseudonymousBiometricTemplate2017",
  "biometricService": "https://example.com/authenticate",
  "biometricTemplateShard": "Mjk4MzQyO...5Mzg0MDI5Mwo="
}],
"service": [{
  "type": "ExampleService",
  "serviceEndpoint": "https://example.com/endpoint/8377464"
}]
}
</pre>
    </section -->

    <section>
      <h2>
        Public Keys
      </h2>

      <p>
        Public keys are used for digital signatures, encryption and other
        cryptographic operations, which in turn are the basis for purposes
        such as authentication (see Section <a href="#authentication"></a>)
        or establishing secure communication with <a>service endpoints</a>
        (see Section <a href="#service-endpoints"></a>). In addition, public
        keys may play a role in authorization mechanisms of <a>DID</a> CRUD
        operations (see Section <a href="#did-operations"></a>), which can be
        defined by <a>DID method</a> specifications.
      </p>

      <p>
        A <a>DID document</a> MAY include a <code>publicKey</code> property. If so:
      </p>

      <dl>
        <dt><dfn>publicKey</dfn></dt>
        <dd>
          The value of the <code>publicKey</code> property MUST be an array of
          public key objects. Each public key object MUST have the
          <code>type</code>, <code>controller</code>, and specific public key
          properties, and SHOULD have an <code>id</code> property. The object
          MAY include additional properties.
        </dd>
      </dl>

      <p>
        The value of the <code>id</code> property (if present) MUST be a URI. The array
        of public keys MUST NOT contain multiple entries with the same
        <code>id</code>. A <a>DID document</a> processor MUST produce an error in that
        case.
      </p>

      <p>
        The value of the <code>type</code> property MUST be exactly one public key value
        (see available key types in Appendix <a href="#registries"></a>).
      </p>

      <p>
        The value of the <code>controller</code> property, which identifies the
        controller of the corresponding private key, MUST be a valid DID.
      </p>

      <p>
        All public key properties MUST be from the Linked Data Cryptographic Suite Registry.
        A registry of key types and formats is available in Appendix <a href="#registries"></a>
      </p>

      <p>
        If a public key does not exist in the <a>DID document</a>, it MUST be
        assumed the key has been revoked or is invalid. The <a>DID document</a> MAY
        contain revoked keys. A <a>DID document</a> that contains a revoked key MUST
        also contain or refer to the revocation information for the key (e.g.,
        a revocation list). Each <a>DID method</a> specification is expected to
        detail how revocation is performed and tracked.
      </p>

      <p>
        All public key formats MUST be expressed in either JSON Web Key (JWK)
        format using the <code>publicKeyJwk</code> property or one of the
        formats listed in the table below. Public key expression MUST NOT use any other key format.
      </p>

      <p class="issue">
        The Working Group is still debating whether the base encoding format used
        will be Base58 (Bitcoin) [[BASE58]], base64url [[RFC7515]] or base16 (hex) [[RFC4648]]. The entries in the
        table below currently assume PEM and Base58 (Bitcoin), but may change to base64url and/or base16 (hex) once
        the group achieves consensus on this particular issue.
      </p>


      <p class="issue">
        The Working Group is still debating whether secp256k1 Schnorr public key values
        will be elaborated upon in this specification and if so, how they will be
        expressed and encoded.
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>
              Key&nbsp;Type
            </th>
            <th>
              Support
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              RSA
            </td>
            <td>
              RSA public key values MUST either be encoded as a JWK or be encoded in
              Privacy Enhanced Mail (PEM) format using the <code>publicKeyPem</code> property.
            </td>
          </tr>
          <tr>
            <td>
              ed25519
            </td>
            <td>
              Ed25519 public key values MUST either be encoded as a JWK or be encoded as
              the raw 32-byte public key value in Base58 Bitcoin format using the
              <code>publicKeyBase58</code> property.
            </td>
          </tr>
          <tr>
            <td>
              secp256k1-koblitz
            </td>
            <td>
              Secp256k1 Koblitz public key values MUST either be encoded as a JWK or be
              encoded as the raw 33-byte public key value in Base58 Bitcoin format using the
              <code>publicKeyBase58</code> property.
            </td>
          </tr>
          <tr>
            <td>
              secp256r1
            </td>
            <td>
              Secp256r1 public key values MUST either be encoded as a JWK or be encoded as
              the raw 32-byte public key value encoded in Base58 Bitcoin format using the
              <code>publicKeyBase58</code> property.
            </td>
          </tr>
          <tr>
            <td>
              Curve25519
            </td>
            <td>
              Curve25519 (also known as X25519) public key values MUST either be encoded as a JWK or be encoded as
              the raw 32-byte public key value in Base58 Bitcoin format using the
              <code>publicKeyBase58</code> property.
            </td>
          </tr>
        </tbody>
      </table>

      <p>
        Example:
      </p>

      <pre class="example nohighlight" title="Various public keys">
{
  "@context": ["https://www.w3.org/ns/did/v1", "https://w3id.org/security/v1"],
  "id": "did:example:123456789abcdefghi",
  <span class="comment">...</span>
  "publicKey": [{
    "id": "did:example:123456789abcdefghi#keys-1",
    "type": "RsaVerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }, {
    "id": "did:example:123456789abcdefghi#keys-2",
    "type": "Ed25519VerificationKey2018",
    "controller": "did:example:pqrstuvwxyz0987654321",
    "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
  }, {
    "id": "did:example:123456789abcdefghi#keys-3",
    "type": "Secp256k1VerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyHex": "02b97c30de767f084ce3080168ee293053ba33b235d7116a3263d29f1450936b71"
  }],
  <span class="comment">...</span>
}
</pre>
      <p>
        A key MAY be <em>embedded</em> or <em>referenced</em> in a <a>DID
          document</a>. For example, the <code>authentication</code> property
        may refer to keys in both ways:
      </p>

      <pre class="example nohighlight" title="Various public keys">
{
<span class="comment">...</span>

  "authentication": [
    <span class="comment">// this key is referenced, it may be used for more than one proof purpose</span>
    "did:example:123456789abcdefghi#keys-1",
    <span class="comment">// this key is embedded and may *only* be used for authentication</span>
    {
      "id": "did:example:123456789abcdefghi#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:example:123456789abcdefghi",
      "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
    }
  ],

<span class="comment">...</span>
}
</pre>
      <p>
        The algorithm to use when processing a <code>publicKey</code>
        property in a <a>DID document</a> is:
      </p>

      <ol class="algorithm">
        <li>
          Let <em>value</em> be the data associated with the
          <code>publicKey</code> property and initialize <em>result</em> to
          <code>null</code>.
        </li>

        <li>
          If <em>value</em> is an object, the key material is embedded. Set
          <em>result</em> to <em>value</em>.
        </li>

        <li>
          If <em>value</em> is a string, the key is included by reference.
          Assume <em>value</em> is a URL.
          <ol>
            <li>
              Dereference the URL and retrieve the <code>publicKey</code>
              properties associated with the URL (e.g., process the
              <code>publicKey</code> property at the top-level of the
              dereferenced document).
            </li>

            <li>
              Iterate through each public key object.
              <ol>
                <li>
                  If the <code>id</code> property of the object matches
                  <em>value</em>, set <em>result</em> to the object.
                </li>
              </ol>
            </li>
          </ol>
        </li>

        <li>
          If <em>result</em> does not contain at least the <code>id</code>,
          <code>type</code>, and <code>controller</code> properties as well as any
          mandatory public cryptographic material, as determined by the
          <em>result</em>'s <code>type</code> property, throw an error.
        </li>
      </ol>

      <p class="note">
        While the <code>controller</code> field may seem redundant in some of the
        examples above, keys may be expressed in a <a>DID document</a> where the
        controller is described in another <a>DID document</a>. Linked Data Proof
        libraries typically expect the <code>controller</code> field to always
        exist and may throw an exception if it is missing. Furthermore, per
        the requirement that <a>DID documents</a> be interpretable as either a graph
        or a tree, a default <code>controller</code> field cannot be inferred by
        using a key's position in a tree.
      </p>

      <p class="note">
        Caching and expiration of the keys in a <a>DID document</a> is entirely the
        responsibility of <a>DID resolvers</a> and other clients. See Section
        <a href="#did-resolvers"></a>.
      </p>
    </section>

    <section id="authentication">
      <h2>
        인증
      </h2>

      <p>
        인증은 <a>DID 컨트롤러</a>가 해당 DID와 연결되어 있다는 것을 암호화 방식으로
        증명할 수 있는 메커니즘이다. <a href="#binding-of-identity"></a>을 참조.
        DID 컨트롤러는 다른 사람이 자신의 DID 문서에 대한 제어 권한을 증명하지 않고도
        <a>DID 문서</a>를 업데이트하도록 (예. <a href="#key-revocation-and-recovery"></a>에서
        설명하고 있는 키 복구 지원 참조) 인증과 권한 부여가 분리되어 있다
        (그러므로 <a>DID 컨트롤러</a>에 대한 위장이 가능함).
      </p>

      <p>
        <a>DID 문서</a>는 무조건 <code>authentication</code> 속성을 포함해야한다. 그렇다면:
      </p>
      <dl>
        <dt><dfn>authentication</dfn></dt>
        <dd>
          <code>authentication</code> 속성 값은 검증 메소드의 배열이어야 한다.
          각각의 검증 방법은 포함되거나 참조될 수 있다.
          검증 방법의 예로는 공개키 방식이 있다 (<a href="#public-keys"></a>참조).
        </dd>
      </dl>

      <p>
        예제:
      </p>

      <pre class="example nohighlight" title="세가지 검증 방법이 포함 된 인증 속성값">
{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:example:123456789abcdefghi",
  <span class="comment">...</span>
  "authentication": [
    <span class="comment">// 이 메소드는 DID(…fghi)로 인증시 사용할 수 있다</span>
    "did:example:123456789abcdefghi#keys-1",
    <span class="comment">// 이 메소드는 DID(…fghi)로 인증시 사용할 수 있다</span>
    "did:example:123456789abcdefghi#biometric-1",
    <span class="comment">// 이 방법은 인증을 위해 *전용*으로 권한을 부여받았으며,</span>
    <span class="comment">// 다른 증명 목적으로 사용될 수 없다.</span>
    <span class="comment">// 전체 설명은 참조를 사용하지 않고 포함된다.</span>
    {
      "id": "did:example:123456789abcdefghi#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:example:123456789abcdefghi",
      "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
    }
  ],
  <span class="comment">...</span>
}
</pre>
    </section>

    <section id="authorization-and-delegation">
      <h2>
        인가 및 위임
      </h2>

      <p>
        인가는 DID 주체를 대신하여 작업이 어떻게 수행되는지에 대해서 설명하는데 쓰이는
        메커니즘이다. 위임은 다른 사람이 <a>DID 주체</a>를 대신할 수 있도록 권한을 부여하는데
        사용하는 메커니즘이다. <a href="#authentication"></a>에서 설명한 바와 같이 인증과
        인가는 분리되어 있다. 이는 키의 분실로 더 이상 키에 액세스 할 수 없거나 키가 유출되어
        <a>DID 컨트롤러</a>의 제3신뢰기관들(trusted third parties)이 공격자의 악의적인
        활동의 무효화(override)가 필요한 경우 키를 복구하기 위해 중요하다.
        <a href="#security-considerations"></a> 참고.
      </p>

      <p>
        각 <a>DID 메소드</a>는 필수적인 암호화 연산을 포함하여 인가 및 위임이 구현되는
        방법을 정의해야 한다.
      </p>

      <p>
        인가 및 위임의 구현 방법에 대하여 최소한 2가지 방법이 제안되어 있으며
        이는 서로 겹쳐 사용할 수 있다:
      </p>

      <ol>
        <li>
          <a>DID 레지스트리</a>는 <a>DID 문서</a>가 제어하는 다른 <a>DID 컨트롤러</a>의
          <a>DID</a>를 표현하거나 추가하여 간략한 <code>controller</code> 패턴을 구현할 수 있다.
        </li>

        <li>
          <a>DID 레지스트리</a>는 인가 및 위임을 정교하게 제어 할 수 있는 기능 기반
          접근 방식으로 구현할 수 있다.
        </li>
      </ol>

      <p>
        예제:
      </p>

      <pre class="example nohighlight" title="controller 속성이 있는 DID 문서">
{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:example:123456789abcdefghi",
  "controller": "did:example:bcehfew7h32f32h7af3",
  "service": [{
    <span class="comment">// DID와 관련된 검증 가능 자격 증명의 검색 시 사용</span>
    "type": "VerifiableCredentialService",
    "serviceEndpoint": "https://example.com/vc/"
  }]
}
        </pre>
    </section>

    <section id="service-endpoints">
      <h2>
        서비스 엔드포인트
      </h2>

      <p>
        <a>DID 문서</a>의 주요 목적은 <a>서비스 엔드포인트</a>를 검색할 수 있게 하는 것이다.
        <a>서비스 엔드포인트</a>는 추가 탐색, 인증, 인가 또는 상호작용을 위한
        <a>탈중앙 ID 관리</a>서비스를 포함하여 <a>DID 주체</a>가 공시하는 모든 유형의
        서비스를 나타낼 수 있다.
      </p>

      <p>
        <a>DID 문서</a>는 <code>service</code> 속성을 포함 할 수도 있다. 그렇다면:
      </p>

      <dl>
        <dt><dfn>service</dfn></dt>
        <dd>
          <code>service</code> 속성의 값은 반드시 <a>서비스 엔드포인트</a>의 배열이어야 한다.
          각 <a>서비스 엔드포인트</a>에는 무조건 <code>type</code>,
          <code>serviceEndpoint</code> 및 <code>id</code> 속성이 포함되어야 하며
          추가적인 속성이 포함될 수 있다.
        </dd>
      </dl>

      <p>
        The value of the <code>id</code> property (if present) MUST be a URI.
        The array of <a>service endpoints</a> MUST NOT contain multiple entries
        with the same <code>id</code>. A <a>DID document</a> processor MUST
        produce an error in that case.
      </p>

      <p>
        <code>serviceEndpoint</code> 속성의 값은 JSON-LD 객체이거나 [[RFC3986]]을 따르는
        유효한 <a>URI</a>이어야하고, [[RFC3986]]의 6장 규칙 및 그 밖의 적용 가능한
        URI 스킴 명세서의 규칙에 따라 정규화되어야 한다.
      </p>

      <p>
        <a>서비스 엔드포인트</a> 프로토콜은 표준 명세서로 공개되어야 한다.
      </p>

      <p>
        예제:
      </p>

      <pre class="example nohighlight" title="다양한 서비스 엔드포인트">
{
  "service": [{
    "id": "did:example:123456789abcdefghi#openid",
    "type": "OpenIdConnectVersion1.0Service",
    "serviceEndpoint": "https://openid.example.com/"
  }, {
    "id": "did:example:123456789abcdefghi#vcr",
    "type": "CredentialRepositoryService",
    "serviceEndpoint": "https://repository.example.com/service/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#xdi",
    "type": "XdiService",
    "serviceEndpoint": "https://xdi.example.com/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#agent",
    "type": "AgentService",
    "serviceEndpoint": "https://agent.example.com/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#hub",
    "type": "IdentityHub",
    "publicKey": "did:example:123456789abcdefghi#key-1",
    "serviceEndpoint": {
      "@context": "https://schema.identity.foundation/hub",
      "type": "UserHubEndpoint",
      "instances": ["did:example:456", "did:example:789"]
    }
  }, {
    "id": "did:example:123456789abcdefghi#messages",
    "type": "MessagingService",
    "serviceEndpoint": "https://example.com/messages/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#inbox",
    "type": "SocialWebInboxService",
    "serviceEndpoint": "https://social.example.com/83hfh37dj",
    "description": "My public social inbox",
    "spamCost": {
      "amount": "0.50",
      "currency": "USD"
    }
  }, {
    "id": "did:example:123456789abcdefghi#authpush",
    "type": "DidAuthPushModeVersion1",
    "serviceEndpoint": "http://auth.example.com/did:example:123456789abcdefg"
  }]
}
</pre>
      <p>
        <a>서비스 엔드포인트</a>에 대한 추가 보안 고려 사항은
        <a href="#did-method-schemes"></a> 및 <a href="#authentication"></a>을 참조
      </p>
      </sectionㅑㅇ>

      <section id="created">
        <h2>
          생성
        </h2>

        <p>
          <a>DID 문서</a>에는 <code>created</code> 속성이 포함되어야 한다. 그렇다면:
        </p>

        <dl>
          <dt><dfn>created</dfn></dt>
          <dd>
            <code>created</code> 속성 값은 <a href="https://www.w3.org/TR/xmlschema11-2/">
              W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a>
            [[!XMLSCHEMA11-2]] 3.3.7장에 정의된 유효한 XML 날짜 및 시간이다.
            날짜 및 시간 값은 "Z" 끝나게 표시되는 UTC 00:00으로 정규화되어야 한다.
          </dd>
        </dl>

        <p>
          예제:
        </p>

        <pre class="example nohighlight">
{
  "created": "2002-10-10T17:00:00Z"
}
</pre>
      </section>

      <section id="updated">
        <h2>
          갱신
        </h2>

        <p>
          식별자 레코드의 표준 메타 데이터에는 가장 최근의 갱신에 대한 타임스탬프가 포함된다.
        </p>

        <p>
          <a>DID 문서</a>에는 <code>updated</code> 속성이 포함되어야 한다. 그렇다면:
        </p>

        <dl>
          <dt><dfn>updated</dfn></dt>
          <dd>
            <code>updated</code> 속성 값은 무조건 <code>created</code> 속성과 동일한
            규칙을 따른다 (<a href="#created"></a> 참조).
          </dd>
        </dl>

        <p>
          예제:
        </p>

        <pre class="example nohighlight">
{
  "updated": "2016-10-17T02:41:00Z"
}
</pre>
      </section>

      <section>
        <h2>
          Proof
        </h2>

        <p>
          <a>DID 문서</a>의 <code>proof</code>은 다음 중 하나에 따라 <a>DID 문서</a>의 무결성을 증명하는 암호화 증명이다:
        </p>

        <ol start="1">
          <li>
            섹션 5.2 <a href="#did-subject">DID 주체</a>에 정의 된 <a>DID 주체</a> 또는:
          </li>

          <li>
            <a href="#authorization-and-delegation">권한 부여 및 위임</a>에 정의 된 DID 컨트롤러 (있는 경우).
          </li>
        </ol>

        <p>
          이 증명은 <a>DID</a>와 <a>DID 문서</a>간의 연관성(binding) 대한 증명이 아니다 (섹션 9.3 신원의 바인딩 참조(<a
            href="#binding-of-identity"></a>)).
        </p>

        <p>
          <a>DID 문서</a>는 <code>proof</code> 속성을 포함 할 수 있다. 그렇다면:
        </p>

        <dl>
          <dt><dfn>proof</dfn></dt>
          <dd>
            <code>proof</code> 값은 무조건 링크 된 데이터 증명(<a href="https://w3c-dvcg.github.io/ld-signatures/">Linked Data
              Proofs</a>)에서 정의한 유효한 JSON-LD 증명이어야한다.
          </dd>
        </dl>

        <p>
          Example:
        </p>

        <pre class="example nohighlight" title="A signature-based proof">
{
  "proof": {
    "type": "LinkedDataSignature2015",
    "created": "2016-02-08T16:02:20Z",
    "creator": "did:example:8uQhQMGzWxR8vw5P3UWH1ja#keys-1",
    "signatureValue": "QNB13Y7Q9...1tzjn4w=="
  }
}
</pre>
      </section>

      <section>
        <h2>
          Extensibility
        </h2>

        <p>
          <a>탈중앙화 식별자</a> 데이터 모델의 목표 중 하나는 비허가형 혁신을 가능하게하는 것이다. 이를 위해서는 데이터 모델을 다양한 방법으로 확장 할 수 있어야 한다:
        </p>

        <ul>
          <li>
            The requirement to model complex multi-entity relationships is
            provided through the use of a graph-based data model.
          </li>

          <li>
            The requirement to enable extending the machine-readable
            vocabularies used to describe information in the data model &mdash;
            without relying on a centralized system &mdash; is accomplished via
            the use of [[LINKED-DATA]].
          </li>

          <li>
            The requirement to support multiple types of cryptographic proof
            formats is accomplished via the use of Linked Data Proofs
            [[LD-PROOFS]], Linked Data Signatures [[LD-SIGNATURES]], and a
            variety of signature suites.
          </li>

          <li>
            The requirement to provide all of the extensibility mechanisms
            outlined above in a data format that is popular among software
            developers and web page authors is enabled via the use of
            [[!JSON-LD]].
          </li>
        </ul>

        <p>
          This approach to data modeling is often called an "open world
          assumption", meaning that anyone can say anything about any other
          thing. This approach often feels in conflict with building simple
          and predictable software systems. Balancing extensibility with
          program correctness is always more challenging with an open world
          assumption than it is with closed software systems.
        </p>

        <p>
          The rest of this section describes how both extensibility and program
          correctness are achieved through a series of examples.
        </p>

        <p>
          다음과 같은 <a>DID 문서</a>로 시작한다고 가정 해 본다:
        </p>

        <pre class="example nohighlight" title="A simple DID document">
{
  "@context": "https://example.org/example-method/v1",
  "id": "did:example:123456789abcdefghi",
  "publicKey": [{ <span class="comment">...</span> }],
  "authentication": [{ <span class="comment">...</span> }],
  "service": [{ <span class="comment">...</span> }]
}
      </pre>
        <p>
          이 섹션에서는 <code>publicKey</code>, <code>authentication</code> 및 <code>service</code> 속성의 내용이 중요하지 않다. 중요한 것은 위의
          개체가 유효한 <a>DID 문서</a>라는 것이다. 개발자가 추가 정보를 표현하기 위해 <a>DID 문서</a>를 확장하고 싶다고 가정 하자. 추가정보는 피사체의 공개 사진 스트림이다.
        </p>

        <p>
          The first thing that a developer would do is create a JSON-LD Context
          containing the new term:
        </p>

        <pre class="example nohighlight" title="An example JSON-LD Context">
{
  "@context": {
    "PhotoStreamService": "https://example.com/vocab#PhotoStreamService"
  }
}
      </pre>
        <p>
          JSON-LD 컨텍스트가 생성되었으므로 개발자는 <a>DID 문서</a> 프로세서에 액세스 할 수있는 어떤 위치에 이를 무조건 게시해야한다. 예를 들어, 우리가 JSON-LD 컨텍스트 위의 다음
          URL에 게시되어 있다고 가정하자 :
          <code>did:example:contexts:987654321</code>. 이 시점에서이 섹션의 첫 번째 예제를 확장하는 것은 위의 컨텍스트를 포함하고 <a>DID 문서</a>에 새 속성을
          추가하는 간단한 문제이다.
        </p>

        <pre class="example nohighlight" title="A DID document with a custom extension">
{
  "@context": "https://example.org/example-method/v1",
  "id": "did:example:123456789abcdefghi",
  "authentication": [ <span class="comment">...</span> ],
  "service": [<span class="highlight">{
    "@context": "did:example:contexts:987654321",
    "id": "did:example:123456789abcdefghi#photos",
    "type": "PhotoStreamService",
    "serviceEndpoint": "https://example.org/photos/379283"
  }</span>]
}
      </pre>
        <p>
          지금까지의 예시에서는 <a>탈중앙화 식별자</a> 데이터 모델을 탈중앙화 방식으로 쉽게 확장 할 수 있음을 보여주었다. 또한 이 방식으로 생성 된 <a>탈중앙화 식별자</a>가 네임 스페이스 충돌
          및
          의미상 모호성을 방지한다.
        </p>

        <p>
          동적 확장성 모델은 구현 부담을 증가시킨다. 이러한 시스템 용으로 작성된 소프트웨어는 응용 프로그램의 위험 프로파일에 따라 확장명이 포함 된 <a>DID 문서</a>를 수락 할 수 있는지 여부를
          결정해야한다. 일부 응용 프로그램은 확장을 허용하지만 무시하도록 선택하고 다른 응용 프로그램은 특정 확장만 허용하도록 선택할 수 있지만 보안 수준이 높은 환경에서는 확장이 허용되지 않을 수 있다.
          이러한 결정은 응용 프로그램 개발자에게 달려 있으며 특히 이 사양의 영역이 아니다.
        </p>

        <p>
          Implementations MUST produce an error when an extension JSON-LD
          Context overrides the expanded URL for a term specified in this
          specification. To avoid the possibility of accidentally overriding
          terms, developers SHOULD scope their extensions. For example,
          the following extension scopes the new
          <code>PhotoStreamService</code> term so that it may only be used
          within the <code>service</code> property:
        </p>

        <pre class="example nohighlight" title="Scoping terms in a JSON-LD Context">
{
  "@context": {
    <span class="highlight">"service": {
      "@id": "https://w3id.org/did#service",
      "@context": {
        "PhotoStreamService": "https://example.com/vocab#PhotoStreamService"
      }
    }</span>
  }
}
      </pre>
        <p>
          Developers are urged to ensure that extension JSON-LD Contexts are
          highly available. Implementations that cannot fetch a context will
          produce an error. Strategies for ensuring that extension JSON-LD
          Contexts are always available include using content-addressed URLs
          for contexts, bundling context documents with implementations, or
          enabling aggressive caching of contexts.
        </p>
      </section>
    </section>
  </section>
  <section class="normative">
    <h1>
      DID Document Syntax
    </h1>

    <p>
      A <a>DID document</a> MUST be a single JSON object conforming to [[!RFC8259]].
      Many of the concepts in this document were introduced by example using the
      JSON-LD syntax, a format for mapping JSON data into the RDF semantic graph
      model, as defined by [[!JSON-LD]]. This section formalizes how the data model
      (described in Sections <a href="#data-model"></a> and
      <a href="#did-documents"></a>) is realized in JSON-LD.
    </p>
    <p>
      Although syntactic mappings are provided for JSON and JSON-LD only, applications
      and services can use any other data representation syntax, such as JXD (JSON XDI
      Data, a serialization format for the
      <a href="http://docs.oasis-open.org/xdi/xdi-core/v1.0/csd01/xdi-core-v1.0-csd01.xml">XDI graph model</a>),
      XML, YAML, or CBOR, that is capable of expressing the data model.
    </p>

    <section>
      <h2>
        JSON
      </h2>

      <p>
        The data model, as described in Section <a href="#data-model"></a>, can be
        encoded in Javascript Object Notation (JSON) [[RFC8259]] by mapping property
        values to JSON types as follows:
      </p>

      <ul>
        <li>
          Numeric values representable as IEEE754 SHOULD be represented as a Number type.
        </li>
        <li>
          Boolean values SHOULD be represented as a Boolean type.
        </li>
        <li>
          Sequence value SHOULD be represented as an Array type.
        </li>
        <li>
          Unordered sets of values SHOULD be represented as an Array type.
        </li>
        <li>
          Sets of properties SHOULD be represented as an Object type.
        </li>
        <li>
          Empty values SHOULD be represented as a null value.
        </li>
        <li>
          Other values MUST be represented as a String type.
        </li>
      </ul>
    </section>

    <section>
      <h2>
        JSON-LD
      </h2>

      <p>
        [[!JSON-LD]] is a JSON-based format used to serialize
        <a href="http://www.w3.org/TR/ld-glossary/#linked-data">Linked Data</a>. The
        syntax is designed to easily integrate into deployed systems already using
        JSON, and provides a smooth upgrade path from JSON to JSON-LD. It is primarily
        intended to be a way to use Linked Data in Web-based programming environments,
        to build interoperable Web services, and to store Linked Data in JSON-based
        storage engines.
      </p>

      <p>
        JSON-LD is useful when extending the data model described in this specification.
        Instances of the data model are encoded in JSON-LD in the same way they are
        encoded in JSON (see Section <a href="#json"></a>), with the addition of the
        <code>@context</code> property. The
        <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD Context</a>
        is described in detail in the [[!JSON-LD]] specification and its use is
        elaborated on in Section <a href="#extensibility"></a>.
      </p>

      <p>
        In general, the data model and syntaxes described in this document are designed
        such that developers can copy and paste examples into their software systems.
        The design goal of this approach is to provide a low barrier to entry while
        still ensuring global interoperability between a heterogeneous set of software
        systems. This section describes some of these approaches, which will likely go
        unnoticed by most developers, but whose details will be of interest to
        implementers. Noteworthy features provided by JSON-LD are:
      </p>

      <ul>
        <li>
          The <code>@id</code> and <code>@type</code> keywords are aliased to
          <code>id</code> and <code>type</code> respectively, enabling developers to use
          this specification as idiomatic JSON.
        </li>
        <li>
          Data types, such as integers, dates, units of measure, and URLs, are
          automatically typed to provide stronger type guarantees for use cases that
          require them.
        </li>
        <li>
          The <code>@protected</code> properties feature of JSON-LD 1.1 is used to ensure
          that terms defined by this specification cannot be overridden. This means that
          as long as the same <code>@context</code> declaration is made at the top of a
          <a>DID document</a>, interoperability is guaranteed between implementations
          that use a JSON-LD processor and implementations that do not.
        </li>
      </ul>
    </section>
  </section>

  <section>
    <h1>
      DID Methods
    </h1>

    <section class="normative">
      <h2>
        DID Method Schemes
      </h2>

      <p>
        <a>DID 메소드</a> 규격은 정확하게 메소드별 <a>DID 체계</a>마다 식별이 가능한 정확한 하나의 메소드 이름이 반드시 정의해야 한다. (<code>method-name</code> 규칙은
        <a href="#generic-did-syntax"></a>에 따른다)
      </p>

      <p>
        메소드 이름은 <a>DID</a>의 일부이므로, 짧은 메소드 이름이 선호된다. 메소드 이름은 5자 이하여야 한다. 메소드 이름은 <a>DID 메소드</a> 규격이 적용되는 <a>DID
          레지스트리</a>의 이름을 반영할 수 있다. (<a href="#unique-did-method-names"></a>.)
      </p>

      <p>
        메소드별 <a>DID 체계</a>를 위한 <a>DID 메소드</a> 규격에는 <a>DID</a>의 구성요소인 <code>method-specific-id</code>를 어떻게 생성하는지 반드시 명시가
        되어있어야 한다. <code>method-specific-id</code>는 반드시 중앙화 된 레지스트리 서비스를 이용하지 않고 생성할 수 있어야 한다.
        <code>method-specific-id</code>는 범용(범세계)적으로 고유해야 한다. <code>did</code> 규칙은 <a href="#generic-did-syntax"></a>에
        정의되어 있으며, 반드시 전세계적으로 고유해야 한다.
      </p>

      <p>
        필요하다면, 메소드별 <a>DID 체계</a>는 다수의 <code>method-specific-id</code> 형식을 정의할 수 있다. (하지만) 가능한 소수의
        <code>method-specific-id</code> 형식을 정의하는 것을 권장한다.
      </p>
    </section>

    <section>
      <h2>
        DID Operations
      </h2>

      <p>
        특정 <a>DID 레지스트리</a>에서 <a>DIDs</a> 및 <a>DID 문서</a>의 전체 기능을 사용하려면 클라이언트에 의해 수행되는 다음 <abbr
          title="Create, Read, Update, Delete">CRUD</abbr> 작업이 DID 메소드 규격에 반드시 지정되어 있어야 한다. 각 조작은 <a>DID 레지스트리</a>와 상호운용
        가능한 클라이언트 구현을 빌드하고 시험할 수준의 세부사항을 지정해야 할 필요가 있다. 이러한 조작은 CKMS(cryptographic key management system)에 필요한 모든 조작을
        효과적으로 수행할 수 있다. 예를 들면 키 등록, 키 교체, 키 회전(key rotation), 키 복구, 키 만료 들이다.
      </p>
      <p>
        업데이트 또는 비활성화와 같은 특정 작업을 지원하지 않는 <a>DID 메소드</a> 규격은 이러한 제한을 반드시 명확하게 명시해야 한다.
      </p>

      <section>
        <h3>
          Create
        </h3>

        <p>
          <a>DID 메소드</a> 규격은 클라이언트가 <a>DID</a> 및 관련 <a>DID 문서</a>를 <a>DID 레지스트리</a>에 어떻게 생성할지 명시해야 하며, 여기에는 제어증명 입증을 위한
          모든 암호화 작업이 포함된다.
        </p>
      </section>

      <section>
        <h3>
          Read/Verify
        </h3>

        <p>
          <a>DID 메소드</a> 규격은 클라이언트가 <a>DID</a>를 사용하여 <a>DID 레지스트리</a>에 <a>DID 문서</a>를 요청하는 방법, 클라이언트가 응답의 진위를 확인할 수 있는
          방법을 반드시 명시해야 한다.
        </p>
      </section>

      <section>
        <h3>
          Update
        </h3>

        <p>
          <a>DID 메소드</a> 규격은 클라이언트가 <a>DID 레지스트리</a>의 <a>DID 문서</a>를 갱신 할 수 있는 방법을 반드시 명시해야 한다. 여기에는 제어증명 입증을 위한 모든 암호화
          작업, <em>또는</em> 업데이트가 불가능하다는 상태가 포함된다.
        </p>
      </section>

      <section>
        <h3>
          Deactivate
        </h3>

        <p>
          <a>DID 메소드</a> 규격은 클라이언트가 <a>DID 레지스트리</a>의 <a>DID</a>를 비활성화 할 수 있는 방법을 반드시 명시해야 한다. 여기에는 제어증명 입증을 위한 모든 암호화
          작업, <em>또는</em> 비활성화가 불가능하다는 상태가 포함된다.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>
        Unique DID Method Names
      </h2>
      <p>
        새로운 <a>DID 메소드</a> 규격의 저자는 발표 당시 알려진 모든 <a>DID 메소드</a> 이름들과 중복되지 않는 고유한 메소드 이름을 사용해야만 한다.
      </p>
      <p>
        <a>DID 메소드</a> 이름을 할당하거나 승인 할 수 있는 권한을 가진 중앙기관이 없기 때문에 특정 <a>DID 메소드</a> 이름이 고유한 지 확인할 방법이 없다. 이 문제를 해결하기 위해 <a
          href="https://www.w3.org/community/credentials/">W3C Credentials Community Group</a>은 알려진 <a>DID 메소드</a> 이름과
        관련 규격의 비권한 목록을 유지한다(Appendix <a href="#registries"></a> 참조)
      </p>
      <p>
        [[DID-METHOD-REGISTRY]]는 새로운 메소드 명칭을 합의할 때 구현자가 참조 할 수 있는 도구이며, 또한 다른 <a>DID 메소드</a>의 <a>DID 리졸버</a>를 구현하는 소프트웨어
        개발자가 참조 할 수 있는 정보가 된다. 좀 더 많은 <a>DID 리졸버</a>에 대한 정보는 <a href="#did-resolvers"></a>을 참고 할 것.

        [[DID-METHOD-REGISTRY]]는 <a>DID 메소드</a>의 확정적 또는 공식적인 목록이 아니다. 그럼에도 불구하고, [[DID-METHOD-REGISTRY]]에 <a>DID 메소드</a>
        이름을 추가하여 다른 구현자와 커뮤니티 구성원이 기존 <a>DID 메소드</a>의 개요를 한곳에서 볼 수 있도록 하는 것을 장려한다. <a>DID 메소드</a> 이름을 추가하기 위한 간략한 기준은
        [[DID-METHOD-REGISTRY]]에 문서화되어 있다.
      </p>
    </section>

  </section>

  <section class='normative'>
    <h1>
      DID Resolvers
    </h1>

    <p>
      A <a>DID resolver</a> is a software or hardware component with an API for
      resolving <a>DIDs</a> of at least one <a>DID method</a>. It executes the read
      operation for the <a>DID method</a> corresponding to the <a>DID</a> being
      resolved to obtain the authoritative <a>DID document</a>. For more information,
      see Section <a href="#read-verify"></a>.
    </p>

    <p>
      The interfaces and algorithms for resolving <a>DIDs</a> and dereferencing
      <a>DID URLs</a> are specified in [[DID-RESOLUTION]].
    </p>

  </section>

  <section class="informative">
    <h1>
      보안 고려사항 (Security Considerations)
    </h1>

    <p class="note" title="개발자 참고사항">
      개발자의 초안 단계에서 이 장은 초기 구현에 중요한 보안 주제에 중점을 둔다.
      또한, 편집자들은 본 장 또는 사양의 다른 부분에 반영되어야만 하는 위협 및 위협 완화에
      대한 피드백을 탐색한다. <a>탈중앙 식별자</a>(DIDs) 및 <a>DID 문서</a>에 대한
      루트 식별자 레코드는 <a>탈중앙 ID 관리</a>의 필수 구성 요소이다. 또한 기존 X.509 인증서를
      보완하는 <a>탈중앙 공개키 인프라</a> (DPKI)의 기본 구성 요소이다. 따라서 <a>DID</a>는
      많은 IETF 표준에서 사용하는 일반적인 인터넷 위협 모델에서 작동하도록 설계되었다. 우리는
      침해되지 않는 엔드포인트를 가정하지만 네트워크상에서 메시지가 읽혀지거나, 손상될 수
      있음을 고려해야 한다. 시스템이 손상되었을 때 공격으로부터 보호하려면 외부 키 서명
      하드웨어가 필요하다. 키 폐기 및 복구에 관한 <a href="#key-revocation-and-recovery"></a>
      참조. <a>DID</a> 및 <a>DID 문서</a>를 호스팅하는 <a>DLT</a>에는 능동적인 공격을
      방지하기 위한 특별한 보안속성이 있다. 이 설계는 공개키 암호화를 사용하여 개인키가
      손상 될 위험없이 수동적으로 모니터링되는 네트워크에서 작동할 수 있다.
      이로 인하여 <a>DID</a> 아키텍처와 분산 ID를 가능하게 한다.
    </p>

    <section>
      <h2>
        DID 메소드 사양의 요구 사항
      </h2>

      <p>
        <a>DID 메소드</a>의 요구사항 명세는 다음과 같다:
      </p>
      <ul>
        <li>
          <a>DID 메소드</a> 사양에는 무조건 자체 보안 고려 사항 항목이 포함되어야 한다.
        </li>

        <li>
          본 장은 무조건 [[RFC3552]] (27p) 5장 <a>DID</a> 연산에 언급된 모든 요구 사항을
          고려해야 한다. 특히:

          <p class="issue">
            차세대 Web of Trust 5에 대한 논의는 권한 부여를 DID 메소드 명세서로 이동하도록
            합의되었다. 현재 객체 기능을 기반으로 한 일반화된 권한 부여 메커니즘을 작성하려는
            시도가 기대된다.
          </p>

          <ul>
            <li>
              최소한 무조건 다음과 같은 형태의 공격을 고려해야만 한다:
              도청(eavesdropping), 재생(replay), 메시지 삽입(message insertion), 삭제(deletion),
              수정(modification), 중간자 공격(man-in-the-middle).
            </li>
            <li>
              또한 잠재적인 서비스 거부 공격(DoS)도 식별해야 한다.
            </li>
            <li>
              프로토콜에 암호화 보호 메커니즘이 통합된 경우 무조건 보호되는 데이터 부분과 보호 대상
              (즉, 무결성 전용, 기밀성 또는 엔드포인트 인증 등)이 명확하게 표시되어야 한다.
            </li>
            <li>
              암호학적 보호가 어떤 종류의 공격에 취약한지 작성해야 한다.
            </li>
            <li>
              비밀로 유지해야하는 데이터 (키 재료, 랜덤시드 등)는 명확하게 표시해야 한다.
            </li>
            <li>
              만일 본 기술에 인증, 특히 사용자-호스트 인증이 포함된 경우
              무조건 인증 방법의 보안을 명확하게 명시해야 한다.

            </li>
          </ul>
        </li>

        <li>
          또한 본 장은 [[RFC3552]] 5장에 따라 위협 완화가 전개 된 후의 잔류 위험
          (예를 들어 관련 프로토콜의 손상, 잘못된 구현 또는 암호)과 관련된 위험에 대해
          논의해야만 한다.
        </li>

        <li>
          본 장은 <a href="#did-operations"></a>에 요구된 필요한 모든 연산에 대하여
          무결성 보호 및 인증 업데이트를 제공해야 한다.
        </li>

        <li>
          <a>DID 메소드</a>가 P2P 컴퓨팅 리소스 (예를 들어 널리 알려진 <a>DLT</a>와 같은)를
          사용하는 경우 해당 리소스의 예상 부담은 서비스 거부(DoS)와 관련하여
          무조건 논의해야만 한다.
        </li>

        <li>
          메소드 별 엔드포인트 인증에 대해 무조건 논의해야 한다. <a>DID 메소드</a>가 다양한
          네트워크 토폴로지와 함께 <a>DLT</a>를 사용하거나 컴퓨팅 리소스를 줄이기 위해 <em>light node</em> 또는
          <em><a href="https://en.bitcoin.it/wiki/Thin_Client_Security">thin client</a></em>
          구현으로 제공되는 경우 <a>DID 메소드</a> 구현에 사용할 수 있는 토폴로지의 보안 가정을
          무조건 논의해야만 한다.
        </li>

        <li>
          <a>DID 메소드</a>은 <a>DID</a>가 고유하게 할당된 것이므로 할당된 정책 메커니즘을
          무조건 논의해야만 한다. <a>DID</a>는 [[RFC8141]]에 정의된 바와 같이 자원에 한 번만
          할당되고 다시 할당되지 않는 영구 식별자인 URN의 기능 정의에 적합하다.
          <a>DID</a>는 특정 권한 집합에 따라 특정 집단을 식별하는 데 사용될 수 있기 때문에
          보안 컨텍스트에서 특히 중요하다.
        </li>

        <li>
          새로운 인증 <a>서비스 엔드포인트</a> 유형을 소개하는
          <a>DID 메소드</a> (<a href="#service-endpoints"></a> 참조)는 지원되는
          인증 프로토콜의 보안 요구 사항을 고려해야 한다.
        </li>
      </ul>
    </section>

    <section>
      <h2>
        DID 리졸버 선택
      </h2>

      <p>
        [[DID-METHOD-REGISTRY]]는 <a>DID 메소드</a> 이름 및 해당 <a>DID 메소드</a> 사양에
        대한 정보를 제공하는 목록이다. 개발자는 특정 <a>DID 메소드</a> 이름과 함께
        사용해야하는 <a>DID 메소드</a> 사양을 위임 할 CA가 없다는 것을 알아두어야 하지만,
        <a>DID 메소드</a> 사양은 특정 <a>DID 메소드</a> 이름과 함께 사용해야 하고
        [[DID-METHOD-REGISTRY]]를 사용하여 사용할 <a>DID 리졸버</a> 구현을 선택할 때
        결정을 내릴 수 있다.

      </p>
    </section>

    <section>
      <h2>
        Binding of Identity
      </h2>

      <p>
        The following sections describe binding identities to <a>DIDs</a> and
        <a>DID documents</a>.
      </p>

      <section>
        <h3>
          Proving Control of a DID and DID Document
        </h3>

        <p>
          Signatures are one way to allow <a>DID documents</a> to be cryptographically
          verifiable.
        </p>

        <p>
          By itself, a verified signature on a self-signed <a>DID document</a> does not
          prove control of a <a>DID</a>. It only proves that the:
        </p>

        <ul>
          <li>
            <a>DID document</a> was not tampered with since it was registered.
          </li>

          <li>
            <a>DID controller(s)</a> controlled the private key used for the signature at
            the time the signature was generated.
          </li>
        </ul>

        <p>
          Proving control of a <a>DID</a>, that is, the binding between the <a>DID</a> and
          the <a>DID document</a> that describes it, requires a two step process:
        </p>

        <ol start="1">
          <li>
            Resolving the <a>DID</a> to a <a>DID document</a> according to its
            <a>DID method</a> specification.
          </li>

          <li>
            Verifying that the <code>id</code> property of the resulting <a>DID document</a>
            matches the <a>DID</a> that was resolved.
          </li>
        </ol>

        <p>
          It should be noted that this process proves control of a <a>DID</a> and
          <a>DID document</a> regardless of whether the <a>DID document</a> is signed.
        </p>

        <p>
          Signatures on <a>DID documents</a> are optional. <a>DID method</a>
          specifications SHOULD explain and specify their implementation if applicable.
        </p>

        <p>
          It is good practice to combine timestamps with signatures.
        </p>
      </section>

      <section>
        <h3>
          Proving Control of a Public Key
        </h3>

        <p>
          There are two methods for proving control of the private key corresponding to a
          <a>public key description</a> in the <a>DID document</a>: static and dynamic.
        </p>

        <p>
          The static method is to sign the <a>DID document</a> with the private key. This
          proves control of the private key at a time no later than the
          <a>DID document</a> was registered. If the <a>DID document</a> is not signed,
          control of a public key described in the <a>DID document</a> can still be proven
          dynamically as follows:
        </p>

        <ol start="1">
          <li>
            Send a challenge message containing a <a>public key description</a> from the
            <a>DID document</a> and a nonce to an appropriate <a>service endpoint</a>
            described in the <a>DID document</a>.
          </li>

          <li>
            Verify the signature of the response message against the
            <a>public key description</a>.
          </li>
        </ol>
      </section>

      <section>
        <h3>
          Authentication and Verifiable Claims
        </h3>

        <p>
          A <a>DID</a> and <a>DID document</a> do not inherently carry any
          <a href="https://en.wikipedia.org/wiki/Personally_identifiable_information">PII</a>
          (personally-identifiable information). The process of binding a <a>DID</a> to
          something in the real world, such as a person or a company, for example with
          credentials with the same subject as that <a>DID</a>, is out of scope for this
          specification. For more information, see the [[VC-DATA-MODEL]] instead.
        </p>
      </section>
    </section>

    <section>
      <h2>
        Authentication Service Endpoints
      </h2>

      <p>
        If a <a>DID document</a> publishes a <a>service endpoint</a> intended for
        authentication or authorization of the <a>DID subject</a> (see Section
        <a href="#service-endpoints"></a>), it is the responsibility of the
        <a>service endpoint</a> provider, subject, or relying party to comply with the
        requirements of the authentication protocols supported at that
        <a>service endpoint</a>.
      </p>
    </section>

    <section>
      <h2>
        Non-Repudiation
      </h2>

      <p>
        Non-repudiation of <a>DIDs</a> and <a>DID document</a> updates is supported
        under the assumption that the subject:
      </p>

      <ul>
        <li>
          Is monitoring for unauthorized updates (see Section
          <a href="#notification-of-did-document-changes"></a>).
        </li>
        <li>
          Has had adequate opportunity to revert malicious updates according to the
          access control mechanism for the <a>DID method</a> (see Section
          <a href="#authentication"></a>).
        </li>
        <ul>

          <p>
            Non-repudiation is further supported if timestamps are included (see Sections
            <a href="#created"></a> and <a href="#updated"></a>) and the target <a>DLT</a>
            system supports timestamps.
          </p>
    </section>

    <section>
      <h2>
        Notification of DID Document Changes
      </h2>

      <p>
        One mitigation against unauthorized changes to a <a>DID document</a> is
        monitoring and actively notifying the <a>DID subject</a> when there are changes.
        This is analogous to helping prevent account takeover on conventional
        username/password accounts by sending password reset notifications to the email
        addresses on file. In the case of a <a>DID</a>, where there is no intermediary
        registrar or account provider to generate the notification, the following
        approaches are suggested:
      </p>

      <ul>
        <li>
          Subscriptions. If the <a>DID registry</a> on which the <a>DID</a> is registered
          directly supports change notifications, this service can be offered to
          <a>DID controllers</a>. Notifications could be sent directly to the relevant
          <a>service endpoints</a> listed in an existing <a>DID</a>.
        </li>

        <li>
          Self-monitoring. A <a>DID subject</a> can employ their own local or online agent
          to periodically monitor for changes to a <a>DID document</a>.
        </li>

        <li>
          Third-party monitoring. A <a>DID subject</a> could rely on a third-party
          monitoring service, however this introduces another vector of attack.
        </li>
      </ul>
    </section>

    <section>
      <h2>
        Key and Signature Expiration
      </h2>

      <p>
        In a <a>decentralized identifier</a> architecture, there are no centralized
        authorities to enforce key or signature expiration policies. Therefore
        <a>DID resolvers</a> and other client applications need to validate that keys
        were not expired at the time they were used. Because some use cases might have
        legitimate reasons why already-expired keys can be extended, make sure a key
        expiration does not prevent any further use of the key, and implementations
        of a resolver ought to be compatible with such extension behavior.
      </p>
    </section>

    <section>
      <h2>
        Key Revocation and Recovery
      </h2>

      <p>
        Section <a href="#did-operations"></a> specifies the <a>DID</a> operations to be
        supported by a <a>DID method</a> specification, including deactivation of a
        <a>DID document</a> by replacing it with an updated <a>DID document</a>. In
        general, checking for key revocation on <a>DLT</a>-based methods is expected to
        be handled in a manner similar to checking the balance of a cryptocurrency
        account on a <a>distributed ledger</a>. That is, if the balance is empty, the
        entire <a>DID</a> is deactivated. <a>DID method</a> specifications are expected
        to enable support for a quorum of trusted parties to enable key recovery. Some
        of the facilities to do so are suggested in Section
        <a href="#authorization-and-delegation"></a>. Not all <a>DID method</a>
        specifications will recognize control from <a>DIDs</a> registered using other
        <a>DID methods</a> and they might restrict third-party control to <a>DIDs</a>
        that use the same method. Access control and key recovery in a <a>DID method</a>
        specification can also include a time lock feature to protect against key
        compromise by maintaining a second track of control for recovery. Further
        specification of this type of control is a matter for future work (see Section
        <a href="#time-locks-and-did-document-recovery"></a>).
      </p>
    </section>

    <section>
      <h2>
        The Role of Human-Friendly Identifiers
      </h2>

      <p>
        <a>DID들</a>은 중앙 등록 기관이 없어도 글로벌 독창성을 달성한다. 그러나 이것은 인간의 기억력을 희생시키면서 발생한다. 전역적으로 고유한 식별자를 생성 할 수 있는 알고리즘은 의미가없는 임의의
        문자열을 자동으로 생성한다. 이것은 Zooko의 Triangle(<a href="https://en.wikipedia.org/wiki/Zooko%27s_triangle">Zooko's
          Triangle</a>)으로 알려진 식별자에 대한 공리를 보여준다 : "의미, 탈중앙화, 안전. 셋 중 아무거나 둘을 선택하십시오".
      </p>

      <p>
        물론 인간 친화적인 식별자 (이메일 주소, Twitter 핸들 또는 블로그 URL등과 같은 <a>DID 컨트롤러</a>의 주소, 자연어 이름, 도메인 이름 또는 휴대 전화 번호)에서 시작할 때
        <a>DID</a>를 발견하는 것이 바람직한 많은 경우가 있다. 그러나 사람에게 친숙한 식별자를 <a>DID들</a>에 매핑 (및 확인 및 신뢰할 수있는 방식으로)하는 문제는 다른 이야기 이다.
      </p>

      <p>
        Solutions to this problem (and there are many) should be defined in separate
        specifications that reference this specification. It is strongly recommended
        that such specifications carefully consider the:
      </p>

      <ul>
        <li>
          Numerous security attacks based on deceiving users about the true human-friendly
          identifier for a target entity.
        </li>
        <li>
          Privacy consequences of using human-friendly identifiers that are inherently
          correlatable, especially if they are globally unique.
        </li>
        <ul>

          <p class="note">
            DNS 조회를 사용하여 도메인 이름 및 전자 메일 주소에서 <a>DID</a>를 검색하기위한 초안 사양은 [[DNS-DID]]에 있다.
          </p>
    </section>

    <section>
      <h2>
        Immutability
      </h2>

      <p>
        많은 사이버 보안 침해는 현실과 합리적이고 선의의 이용자들의 이상 사이의 격차를 이용하는 데 달려 있다. 다른 생태계와 마찬가지로, <a>DID</a> 생태계는 이것이 일어날 가능성이 있다. 이 사양은
        프로토콜이 아닌 데이터 모델에 중점을 두기 때문에 해당 모델의 사용 방식에 대한 여러 측면에 대한 의견을 제시하지 않았다. 그러나 개별 <a>DID 메소드</a>들은 필요하지 않은 동작이나 의미를
        제거하는 제약 조건을 고려할 수 있다. <a>DID 메소드</a>가 <em>잠금</em>(<em>locked down</em>)상태 일수록 동일한 기능 세트를 제공하는 반면 악의적인 행위자가 조작 할
        수있는 수준은 줄어 든다.
      </p>
      <p>
        예를 들어, 데이터 모델이 업데이트와 관련하여 제공하는 유연성을 고려해보자. <a>DID 문서</a>를 한 번만 편집하면 문서의 루트 ID 속성을 제외한 모든 항목을 변경할 수 있으며 데이터 모델의
        개별 JSON 객체는 root <code>id</code>를 제외한 모든 속성을 변경할 수 있다. 그러나 <a>서비스 엔드포인트</a>가 일단 정의되면 <code>type</code>을 변경하는 것이
        실제로 바람직한가? 아니면 가치를 바꾸는 열쇠가 필요한가? 아니면 객체의 특정 기본 속성이 변경 될 때 새로운 <code>id</code>를 요구하는 것이 더 좋은가? 웹 사이트의 악의적인 인수는 종종
        사이트가 자신의 식별자 (호스트 이름)를 유지하지만 그 아래에 미묘하고 위험한 변화를 가져 오는 결과를 목표로 한다. 사양에 따라 사이트의 특정 속성을 변경할 수없는 경우 (예 : IP 주소와 관련된
        ASN) 이러한 공격을 수행하는 데 훨씬 더 어렵고 비용이 많이 들며 이상 탐지가 더 쉬울 수 있다.
      </p>
      <p>
        불변성이 일부 사이버 보안 이점을 제공 할 수 있다는 개념은 캐싱 때문에 특히 관련이 있다. 전 세계 진실 소스에 연결된 <a>DID 메소드</a>들의 경우 최신 버전의 <a>DID 문서</a>를
        적시에
        직접 조회 할 수 있다. 그러나 캐시 레이어는 결국 클라이언트와 해당 소스 사이에 있을 수 있다. 만약 그렇다면, 실제로 미묘하게 다른 <a>DID 문서</a>에있는 객체(object)의 속성이 주어진
        상태를 가지고 있다고 믿으면 활용을 증대 할 수 있습니다. 일부 조회가 전체 <a>DID 문서</a>이고 다른 조회가 부분적인 데이터 인 경우 더 큰 맥락이 가정되는 경우에 특히 그렇습니다.
    </section>

  </section>

  <section class="informative">
    <h1>
      Privacy Considerations
    </h1>

    <p>
      It is critically important to apply the principles of Privacy by Design
      to all aspects of decentralized identifier architecture, because DIDs
      and DID Documents are &mdash; by design &mdash; administered directly by
      the <a>DID controller(s)</a>.
      There is no registrar, hosting company, or other intermediate service
      provider to recommend or apply additional privacy safeguards. The
      authors of this specification have applied all seven Privacy by Design
      principles throughout its development. For example, privacy in this
      specification is preventative not remedial, and privacy is an embedded
      default. Furthermore, <a>decentralized identifier</a> architecture by itself
      embodies principle #7, "Respect for user privacy &mdash; keep it user-centric."
      This section lists additional privacy considerations that implementers,
      delegates, and <a>DID subjects</a> should bear in mind.
    </p>

    <section>
      <h2>
        Requirements of DID Method Specifications
      </h2>

      <ol start="1">
        <li>
          <a>DID method</a> specifications MUST include their own Privacy
          Considerations sections, if only to point to the general privacy
          considerations in this section.
        </li>

        <li>
          The <a>DID method</a> specification's Privacy Considerations section
          MUST discuss any subsection of
          section 5 of [[RFC6973]] that could apply in a method-specific
          manner. The subsections to consider are: surveillance, stored data
          compromise, unsolicited traffic, misattribution, correlation,
          identification, secondary use, disclosure, exclusion.
        </li>
      </ol>
    </section>

    <section>
      <h2>
        Keep Personally-Identifiable Information (PII) Private
      </h2>

      <p>
        If a <a>DID method</a> specification is written for a public <a>DID
          registry</a> where all <a>DIDs</a> and <a>DID documents</a> will be publicly available,
        it is <em>critical</em> that <a>DID documents</a> contain no PII. All PII
        should be kept behind <a>service endpoints</a> under the control
        of the <a>DID subject</a>. With this privacy architecture, PII may be exchanged
        on a private, peer-to-peer basis using communications channels identified and
        secured by <a>public key descriptions</a> in <a>DID documents</a>. This also
        enables <a>DID subjects</a> and relying parties to implement the
        <a href="https://en.wikipedia.org/wiki/General_Data_Protection_Regulation">GDPR</a>
        <a href="https://en.wikipedia.org/wiki/Right_to_be_forgotten">right
          to be forgotten</a>, as no PII will be written to an immutable
        <a>distributed ledger</a>.
      </p>
    </section>

    <section>
      <h2>
        DID Correlation Risks and Pseudonymous DIDs
      </h2>

      <p>
        Like any type of globally unique identifier, <a>DIDs</a> may be used for
        correlation. <a>DID controllers</a> can mitigate this privacy risk by using
        pairwise unique <a>DIDs</a>, i.e., by sharing a different private <a>DID</a> for
        every relationship. In effect, each <a>DID</a> acts as a pseudonym. A
        pseudonymous <a>DID</a> need only be shared with more than one party when
        the <a>DID subject</a> explicitly authorizes correlation between those parties.
        If pseudonymous <a>DIDs</a> are the default, then the only need for a public
        <a>DID</a> &mdash; a <a>DID</a> published openly or shared with a large number of
        parties &mdash; is when the <a>DID subject</a> explicitly desires public identification.
      </p>
    </section>

    <section>
      <h2>
        DID Document Correlation Risks
      </h2>

      <p>
        The anti-correlation protections of pseudonymous <a>DIDs</a> are easily
        defeated if the data in the corresponding <a>DID documents</a> can be
        correlated. For example, using same <a>public key descriptions</a> or
        bespoke <a>service endpoints</a> in multiple <a>DID documents</a> can provide
        as much correlation information as using the same <a>DID</a>. Therefore the <a>DID
          document</a> for a pseudonymous <a>DID</a> also needs to use pairwise-unique
        public keys.

        It might seem natural to also use pairwise-unique <a>service endpoints</a>
        in the <a>DID document</a> for a pseudonymous <a>DID</a>. However, unique
        endpoints allow all traffic between to <a>DIDs</a> to be isolated perfectly into
        unique buckets, where timing correlation and similar analysis is easy.
        Therefore, a better strategy for endpoint privacy may be to share an
        endpoint among thousands or millions of <a>DIDs</a> controlled by many different
        subjects.
      </p>
    </section>

    <section>
      <h2>
        Herd Privacy
      </h2>

      <p>
        When a <a>DID subject</a> is indistinguishable from others in the herd, privacy
        is available. When the act of engaging privately with another party
        is by itself a recognizable flag, privacy is greatly diminished. <a>DIDs</a>
        and <a>DID methods</a> need to work to improve herd privacy, particularly for
        those who legitimately need it most. Choose technologies and human
        interfaces that default to preserving anonymity and pseudonymity. In
        order to reduce <a href="https://en.wikipedia.org/wiki/Device_fingerprint">digital
          fingerprints</a>, share common settings across client
        implementations, keep negotiated options to a minimum on wire
        protocols, use encrypted transport layers, and pad messages to
        standard lengths.
      </p>
    </section>
  </section>

  <section class="informative">
    <h1>
      Future Work
    </h1>

    <section>
      <h2>
        Upper Limits on DID Character Length
      </h2>

      <p>
        The current specification does not take a position on maximum length
        of a <a>DID</a>. The maximum interoperable URL length is currently about 2K
        characters. QR codes can handle about 4K characters. Clients using
        <a>DIDs</a> will be responsible for storing many <a>DIDs</a>, and some methods
        would be able to externalize some of their costs onto clients by
        relying on more complicated signature schemes or by adding state into
        <a>DIDs</a> intended for temporary use. A future version of this
        specification should set reasonable limits on <a>DID</a> character length to
        minimize externalities.
      </p>
    </section>

    <section>
      <h2>
        Equivalence
      </h2>

      <p>
        Including an equivalence property, such as <code>equivID</code>, in <a>DID documents</a>
        whose value is an array of <a>DIDs</a> would allow subjects to assert two or
        more <a>DIDs</a> that represent the same subject. This capability has
        numerous uses, including supporting migration between <a>DID registries</a> and
        providing forward compatibility of existing <a>DIDs</a> to future <a>DID
          registries</a>. In
        theory, equivalent <a>DIDs</a> should have the same identifier rights,
        allowing <a href="https://w3c.github.io/vctf/">verifiable claims</a>
        made against one <a>DID</a> to apply to equivalent <a>DIDs</a>. Equivalence was not
        included in the current specification due to the complexity of
        verifying equivalence across different <a>DLTs</a> and different <a>DID
          methods</a>, and also of aggregating properties of equivalent <a>DID
          documents</a>. However equivalence should be supported in a future
        version of this specification.
      </p>
    </section>

    <section>
      <h2>
        Timestamps
      </h2>

      <p>
        Verifiable timestamps have significant utility for identifier
        records. This is a good fit for <a>DLTs</a>, since most offer some type of
        timestamp mechanism. Despite some transactional cost, they are the
        most censorship-resistant transaction ordering systems in the world,
        so they are nearly ideal for <a>DID document</a> timestamping. In some cases
        a <a>DLT</a>'s immediate timing is approximate, however their sense of
        <a href="https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki%23Abstract">
          "median time past" (see Bitcoin BIP 113)</a> can be precisely
        defined. A generic <a>DID document</a> timestamping mechanism could would
        work across all <a>DLTs</a> and might operate via a mechanism including
        either individual transactions or transaction batches. The generic
        mechanism was deemed out of scope for this version, although it may
        be included in a future version of this specification.
      </p>
    </section>

    <section>
      <h2>
        Time Locks and DID Document Recovery
      </h2>

      <p>
        Section <a href="#key-revocation-and-recovery"></a> mentions one
        possible clever use of time locks to recover control of a <a>DID</a> after a
        key compromise. The technique relies on an ability to override the
        most recent update to a <a>DID document</a> with Authorization applied by an
        earlier version of the <a>DID document</a> in order to defeat the attacker.
        This protection depends on adding a <a
          href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki%23Abstract">
          time lock (see Bitcoin BIP 65)</a> to protect part of the transaction
        chain, enabling a Authorization block to be used to recover control.
        We plan to add support for time locks in a future version of this
        specification.
      </p>
    </section>

    <section>
      <h2>
        Smart Signatures
      </h2>

      <p>
        Not all <a>DLTs</a> can support the Authorization logic in section
        <a href="#authorization-and-delegation"></a>.
        Therefore, in this version of the specification, all Authorization
        logic is delegated to <a>DID method</a> specifications. A potential
        future solution is a <a href="http://www.weboftrust.info/downloads/smart-signatures.pdf">Smart
          Signature</a> specification that specifies the code any conformant
        <a>DLT</a> may implement to process signature control logic.
      </p>
    </section>

    <section>
      <h2>
        Verifiable Claims
      </h2>

      <p>
        Although <a>DIDs</a> and <a>DID documents</a> form a foundation for decentralized
        identity, they are only the first step in describing their subjects. The
        rest of the descriptive power comes through collecting and
        selectively using <a href="https://w3c.github.io/vctf/">verifiable
          claims</a>. Future versions of the specification will describe in
        more detail how <a>DIDs</a> and <a>DID document</a> can be integrated with &mdash; and help
        enable &mdash; the verifiable claims ecosystem.
      </p>
    </section>

    <section>
      <h2>
        Alternate Serializations and Graph Models
      </h2>

      <p>
        This version of the specification relies on JSON-LD and the RDF graph
        model for expressing a <a>DID document</a>. Future versions of this
        specification might specify other semantic graph formats for a <a>DID
          document</a>.
      </p>
    </section>
  </section>

  <section class="appendix">
    <h1>Current Issues</h1>

    <p>
      The list of issues below are under active discussion and are likely to
      result in changes to this specification.
    </p>

    <div class="issue" data-number="85">Syntactially differentiate data about the DID versus application data</div>
    <div class="issue" data-number="84">Add `initial-values` matrix parameter to Generic DID Parameters</div>
    <div class="issue" data-number="80">Define conformance classes such as "DID document processor"</div>
    <div class="issue" data-number="76">Bikeshed the DID specification short name</div>
    <div class="issue" data-number="75">tracking revocation of public keys</div>
    <div class="issue" data-number="72">Privacy Considerations - Specifically call out GDPR</div>
    <div class="issue" data-number="70">Enable instant DID use/resolution for DID Methods that include a propagation
      delay</div>
    <div class="issue" data-number="69">How to integrate certificates with DIDs?</div>
    <div class="issue" data-number="68">When do we publish a FPWD?</div>
    <div class="issue" data-number="67">Supported public key formats?</div>
    <div class="issue" data-number="65">Does DID Document metadata belong in the Document?</div>
    <div class="issue" data-number="64">Encrypted serviceEndpoint values?</div>
    <div class="issue" data-number="63">Add publicKeyHex as a valid publicKey format</div>
    <div class="issue" data-number="62">Add "service-type" DID URL matrix parameter.</div>
    <div class="issue" data-number="61">Add "content-type" and "content-id" DID URL matrix parameters.</div>
    <div class="issue" data-number="60">Add "key-type" DID URL matrix parameter.</div>
    <div class="issue" data-number="59">Add "key" DID URL matrix parameter.</div>
    <div class="issue" data-number="58">Registry handling</div>
    <div class="issue" data-number="57">Clarification of other verification methods in authentication section missing
    </div>
    <div class="issue" data-number="56">Added support for ethereumAddress in context - fixed #55</div>
    <div class="issue" data-number="55">Add support for ethereumAddress public key type in @context</div>
    <div class="issue" data-number="53">Normative vs. non-normative references</div>
    <div class="issue" data-number="52">(Minor note) update the IANA file</div>
    <div class="issue" data-number="51">[Convention] Method `0` (zero) become a well-known method for retrieving
      properties/metadata from/about a particular DID Server</div>
    <div class="issue" data-number="49">If an existing DID Document has a Service Endpoint fragment, what are the
      primary keys to be used if that Service Endpoint needs to be replaced, updated, or deleted?</div>
    <div class="issue" data-number="48">Some comments by Steven Rowat</div>
    <div class="issue" data-number="46">It would be useful to have `services` as a mapping instead of an `array`</div>
    <div class="issue" data-number="45">Is method-specific-id supposed to be equivalent to param-char?</div>
  </section>

  <section class="appendix">
    <h1>
      Registries
    </h1>

    <p>
      There are multiple registries that define <a>DID methods</a> and extensions to
      this specification. These registries are:
    </p>

    <table class="simple">
      <thead>
        <tr>
          <th>
            Registry
          </th>
          <th>
            Purpose
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            <a href="https://w3c-ccg.github.io/did-method-registry/">DID
              Method Registry</a>
          </td>
          <td>
            Lists all known <a>DID methods</a> and contains links to their
            specifications.
          </td>
        </tr>

        <tr>
          <td>
            <a href="https://w3c-ccg.github.io/ld-cryptosuite-registry/">Linked Data
              Cryptography Suite Registry</a>
          </td>
          <td>
            Defines all known Linked Data Cryptography Suites and Key
            Formats.
          </td>
        </tr>
      </tbody>
    </table>
  </section>

  <section class="appendix">
    <h1>
      Real World Example
    </h1>

    <p>
      A future-facing real-world context is provided below:
    </p>

    <pre class="example nohighlight" title="Advanced DID document example">
{
  "@context": "https://w3id.org/future-method/v1",
  "id": "did:example:123456789abcdefghi",

  "publicKey": [{
    "id": "did:example:123456789abcdefghi#keys-1",
    "type": "RsaVerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }, {
    "id": "did:example:123456789abcdefghi#keys-3",
    "type": "Ieee2410VerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }],

  "authentication": [
    <span class="comment">// this mechanism can be used to authenticate as did:...fghi</span>
    "did:example:123456789abcdefghi#keys-1",
    <span class="comment">// this mechanism can be used to biometrically authenticate as did:...fghi</span>
    "did:example:123456789abcdefghi#keys-3",
    <span class="comment">// this mechanism is *only* authorized for authentication, it may not</span>
    <span class="comment">// be used for any other proof purpose, so its full description is</span>
    <span class="comment">// embedded here rather than using only a reference</span>
    {
      "id": "did:example:123456789abcdefghi#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:example:123456789abcdefghi",
      "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
    }
  ],

  "service": [{
    "id": "did:example:123456789abcdefghi#oidc",
    "type": "OpenIdConnectVersion1.0Service",
    "serviceEndpoint": "https://openid.example.com/"
  }, {
    "id": "did:example:123456789abcdefghi#vcStore",
    "type": "CredentialRepositoryService",
    "serviceEndpoint": "https://repository.example.com/service/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#xdi",
    "type": "XdiService",
    "serviceEndpoint": "https://xdi.example.com/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#hub",
    "type": "HubService",
    "serviceEndpoint": "https://hub.example.com/.identity/did:example:0123456789abcdef/"
  }, {
    "id": "did:example:123456789abcdefghi#messaging",
    "type": "MessagingService",
    "serviceEndpoint": "https://example.com/messages/8377464"
  }, {
    "type": "SocialWebInboxService",
    "id": "did:example:123456789abcdefghi#inbox",
    "serviceEndpoint": "https://social.example.com/83hfh37dj",
    "description": "My public social inbox",
    "spamCost": {
      "amount": "0.50",
      "currency": "USD"
    }
  }, {
    "type": "DidAuthPushModeVersion1",
    "id": "did:example:123456789abcdefghi#push",
    "serviceEndpoint": "http://auth.example.com/did:example:123456789abcdefghi"
  }, {
    "id": "did:example:123456789abcdefghi#bops",
    "type": "BopsService",
    "serviceEndpoint": "https://bops.example.com/enterprise/"
  }]
}
</pre>
  </section>

</body>

</html>