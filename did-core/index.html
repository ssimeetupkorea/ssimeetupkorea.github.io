<!DOCTYPE html>
<html lang=kr>

<head>
  <title>
    탈중앙 식별자 Decentralized Identifiers (DIDs) v1.0
  </title>
  <link rel="shortcut icon" type="image/png" href="https://www.w3.org/favicon.ico" />
  <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
  <!--
    === NOTA BENE ===
    For the three scripts below, if your spec resides on dev.w3 you can check them
    out in the same tree and use relative links so that they'll work offline.
   -->

  <script class='remove' src='https://www.w3.org/Tools/respec/respec-w3c-common'></script>
  <!-- <script src='./respec-w3c-common.js' class='remove'></script> -->

  <script class='remove' src="./common.js">
  </script>

  <script class="remove" type="text/javascript">
    var respecConfig = {
      wgPublicList: "public-did-wg",
      wgPatentURI: "https://www.w3.org/2004/01/pp-impl/117488/status",
      wg: "Decentralized Identifier Working Group",
      wgURI: "https://www.w3.org/2019/did-wg/",

      // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus: "WD",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName: "did-core",


      edDraftURI: "https://w3c.github.io/did-core/",

      // subtitle
      subtitle: "Core Data Model and Syntaxes",

      // if you wish the publication date to be other than today, set this
      publishDate: "2019-12-09",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      previousPublishDate: "2019-12-09",
      previousMaturity: "WD",

      // extend the bibliography entries
      localBiblio: ccg.localBiblio,
      github: {
        repoURL: "https://github.com/w3c/did-core/",
        branch: "master"
      },
      includePermalinks: false,


      // editors, add as many as you like
      // only "name" is required
      editors: [{
        name: "Drummond Reed",
        url: "https://www.linkedin.com/in/drummondreed/",
        company: "Evernym",
        companyURL: "https://www.evernym.com/",
        w3cid: 3096
      },
      {
        name: "Manu Sporny",
        url: "http://manu.sporny.org/",
        company: "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/",
        w3cid: 41758
      },
      {
        name: "Markus Sabadello",
        url: "https://www.linkedin.com/in/markus-sabadello-353a0821",
        company: "Danube Tech",
        companyURL: "https://danubetech.com/",
        w3cid: 46729
      }
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors: [{
        name: "Drummond Reed",
        url: "https://www.linkedin.com/in/drummondreed/",
        company: "Evernym",
        companyURL: "https://www.evernym.com/",
        w3cid: 3096
      },
      {
        name: "Manu Sporny",
        url: "http://manu.sporny.org/",
        company: "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/",
        w3cid: 41758
      },
      {
        name: "Dave Longley",
        url: "",
        company: "Digital Bazaar",
        companyURL: "https://digitalbazaar.com/",
        w3cid: 48025
      },
      {
        name: "Christopher Allen",
        url: "https://www.linkedin.com/in/christophera",
        company: "Blockchain Commons",
        companyURL: "https://www.BlockchainCommons.com",
        w3cid: 85560
      },
      {
        name: "Ryan Grant",
        url: "",
        company: "",
        companyURL: ""
      },
      {
        name: "Markus Sabadello",
        url: "https://www.linkedin.com/in/markus-sabadello-353a0821",
        company: "Danube Tech",
        companyURL: "https://danubetech.com/",
        w3cid: 46729
      }
      ]
    };
  </script>
  <style>
    pre .highlight {
      font-weight: bold;
      color: green;
    }

    pre .comment {
      color: SteelBlue;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
</head>

<body>
  <div class="advisement" style="font-size:small">
    <p>
      이 문서는 <a href="https://www.w3.org/TR/did-core/">W3C Decentralized Identifiers (DIDs) v1.0</a>의 한국어
      번역본입니다.
    </p>
    <p>
      이 문서에 오역 및 오타를 포함할 수 있습니다. <b>영어 원문만이 공식적이고 규범적인 효력을 가지고 있습니다.</b><br/>
      문의나 개선사항은 <a href="https://github.com/ssimeetupkorea/ssimeetupkorea.github.io">깃헙 링크</a>나 <a href="mailto:jshim10@illinois.edu">jshim10@illinois.edu</a>로 연락주시기 바랍니다.<br/>
    </p>

    <p>
      번역일: 2020-01-01<br />
    </p>
    <dt><span style="font-weight: 500;">번역자 (가나다순)</span>: </dt>
    <dd><a href="mailto:jshim10@illinois.edu" ]>심재훈</a></dd>
    <dd><a href="mailto:anh1026@kaist.ac.kr" ]>안형철</a></dd>
    <dd><a href="mailto:example@gmail.com" ]>오효근</a></dd>
    <dd><a href="https://www.linkedin.com/in/minho-yoo-1b968837/" ]>유민호</a> (<a href="https://iotrust.kr/">IoTrust Co., Ltd.</a>)</dd>
    <dd><a href="mailto:example@gmail.com" ]>유수웅</a></dd>
    <dd><a href="mailto:example@gmail.com" ]>윤희태</a> (<a href="https://http://blockcrafters.com/">Block Crafters Co., Ltd.</a>)</dd>
    <dd><a href="mailto:example@gmail.com" ]>임도형</a></dd>
    <dd><a href="mailto:hyunsy822@gmail.com" ]>현수영</a></dd>
  </div>
  <section id='abstract'>
    <p>
      <a>탈중앙 식별자</a>(DIDs)는 검증가능하고 탈중앙화된 디지털 신원을 위한 새로운 형식의 식별자이다.
      이러한 새로운 식별자는 <a>DID 컨트롤러</a>가 DID의 제어권을 증명하고, 중앙화된 레지스트리, 신원 제공자, 인증기관 등으로부터 독립적으로 구현할 수 있도록 설계되었다.
      <a>DID</a>는 <a>DID 주체</a>와 관련된 URL로써, <a>DID 문서</a>라는 방식을 통해 해당 주체와 신뢰할 수 있는 상호작용을 가능하게하는 도구이다.
      <a>DID 문서</a>는 특정 DID를 어떻게 사용하는지에 대해 설명해 놓은 간단한 문서이다.
      각 <a>DID 문서</a>는 암호학적 요소, 검증 메소드, 서비스 엔드포인트 등으로 표현될 수 있다.
      해당요소들은 <a>DID 컨트롤러</a>가 DID의 통제권에 대한 증명을 가능하게 하는 메커니즘 집합을 제공한다.
      서비스 엔드포인트는 <a>DID 주체</a>와의 믿을 수 있는 상호작용을 가능하게 한다.
    </p>
    <p>
      본 문서는 일반 데이터 모델, URL 형식, <a>DID</a>를 위한 일련의 작동방식, <a>DID 문서</a> 그리고 <a>DID 메소드</a>에 대해 명시하고 있다.
    </p>
  </section>

  <section hidden id='sotd'>
    This specification is under active development and implementers are advised
    against implementing the specification unless they are directly involved
    with the W3C DID Working Group. There are use cases [[?DID-USE-CASES]] in active
    development that establish requirements for this document.
    </p>

    <p>
      At present, there exist
      <a href="https://w3c-ccg.github.io/did-method-registry/#the-registry">40
        experimental implementations</a> and a preliminary
      <a href="https://github.com/w3c-ccg/did-test-suite/">test suite</a>
      that will eventually determine whether or not implementations are conformant.
      Readers are advised that Appendix <a href="#current-issues"></a> contains a
      list of concerns and proposed changes that will most likely result in
      alterations to this specification.
    </p>

    <p>
      Comments regarding this document are welcome. Please file issues
      directly on <a href="https://github.com/w3c/did-core/issues/">GitHub</a>,
      or send them
      to <a href="mailto:public-did-wg@w3.org">public-did-wg@w3.org</a> (
      <a href="mailto:public-did-wg-request@w3.org?subject=subscribe">subscribe</a>,
      <a href="https://lists.w3.org/Archives/Public/public-did-wg/">archives</a>).
    </p>

    <p>
      Portions of the work on this specification have been funded by the
      United States Department of Homeland Security's Science and Technology
      Directorate under contracts HSHQDC-16-R00012-H-SB2016-1-002 and
      HSHQDC-17-C-00019. The content of this specification does not
      necessarily reflect the position or the policy of the U.S. Government
      and no official endorsement should be inferred.
    </p>

    <p>
      Work on this specification has also been supported by the Rebooting the
      Web of Trust community facilitated by Christopher Allen, Shannon
      Appelcline, Kiara Robles, Brian Weller, Betty Dhamers, Kaliya Young,
      Kim Hamilton Duffy, Manu Sporny, Drummond Reed, Joe Andrieu, and
      Heather Vescent.
    </p>
  </section>

  <section class="informative" id="introduction">
    <h1>
      서론
    </h1>

    <p>
      기존의 ID 관리 시스템(<a href="https://en.wikipedia.org/wiki/Identity_management">identity management</a>)은 기업의 디렉토리
      서비스(<a href="https://en.wikipedia.org/wiki/Directory_service">directory services</a>), 인증 기관(,
      <a href="https://en.wikipedia.org/wiki/Certificate_authority">certificate authorities</a>) 또는 도메인 등록 기관(<a
        href="https://en.wikipedia.org/wiki/Domain_name_registry">domain name registries</a>)과 같은 중앙 집중식 기관을 기반으로 한다.
      암호학적 신뢰 검증의 관점에서 보면, 이들 중앙집중화 된 각 기관은 각각의 신뢰점(<a href="https://en.wikipedia.org/wiki/Trust_anchor">root of
        trust</a>)이 된다. 이러한 시스템들을 통해 ID 관리를 수행하려면 연합 ID 관리(<a
        href="https://en.wikipedia.org/wiki/Federated_identity">federated identity management</a>)를 구축해야 한다.
    </p>

    <p>
      <a>블록체인</a>이라고도 하는 분산원장기술(DLT, <a>Distributed ledger Technology</a>)의 출현은 완전한 <a>탈중앙 ID 관리</a> 기회를 제공한다. 탈중앙 신원
      시스템에서 개체(개인, 조직 및 기타 사항과 같은 제한이 없는 개별 식별 가능 단위)는 공유된 신뢰점을 자유롭게 사용할 수 있다. 전세계에 분산된 원장, 탈중앙 p2p 네트워크, 또는 유사한 기능을 가진
      다른 시스템은 권한의 집중이나 단일 장애점을 도입하지 않고 신뢰점를 관리할 수 있는 수단을 제공한다. <a>DLTs</a>(분산원장기술들)과 <a>탈중앙 ID 관리</a>를 결합한 시스템에서는 누구나
      분산되고, 신뢰점과 독립적인 자신의 식별자들을 생성하고 관리 할 수 있다.
    </p>

    <p>
      개체들은 <a>탈중앙 식별자</a>(<a>DIDs</a>)에 의해 식별되며, 증명(예: 디지털 서명, 생체인식 등)을 통해 인증할 수 있다. <a>DIDs</a>는 <a>DID 문서들</a>(<a>DID
        documents</a>)을 참조한다. <a>DID 문서</a>는 <a>DID</a> 식별자와 주체가 상호 작용을 하기 위한 <a>서비스 엔드포인트</a>들을 포함한다. 프라이버시 디자인[<a
        href="https://en.wikipedia.org/wiki/Privacy_by_design">Privacy by
        Design</a>] 가이드라인에 따라, 개체들은 신원, 페르소나, 그리고 컨텍스트들에 따라 구분하고 싶은 바람을 따라 자신이 원하는 만큼 많은 <a>DIDs</a>(<a>DID 문서</a>와
      <a>서비스 엔드포인트</a>들이 포함된)를 가질 수 있다.
    </p>

    <p>
      <a>DID 메소드</a>는 특정 <a>분산 원장</a> 또는 네트워크에서 <a>DID</a>와 관련된 <a>DID 문서</a>들을 생성, 읽기, 갱신, 그리고 비활성화 하는 메커니즘이다. <a>DID
        메소드들</a>은 별도의 <a>DID 메소드</a> 규격을 사용하여 정의한다.
    </p>

    <p>
      이 설계는 중앙 집중식 레지스트리와 공개키 기반구조(<a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">PKI, public key
        infrastructure</a>)의 중앙 집중식 인증 기관에 대한 식별자의 의존성을 제거 한다. <a>DID 레지스트리</a>가 <a>분산 원장</a>인 경우, 각 개체는 자체 인증 기관의 역할을 할
      수 있으며, 이것을 분권화된 <a
        href="https://github.com/WebOfTrustInfo/rebooting-the-web-of-trust/blob/master/final-documents/dpki.pdf">PKI-
        DPKI(decentralized PKI)</a>라고 한다.
    </p>

    <p class="note">
      참고로 <a>DID 메소드</a>들은 연합, 또는 중앙집중식 ID 관리 시스템에 등록된 식별자로도 사용될 수 있다. 이것을 위해, 모든 유형의 식별자 시스템에 <a>DIDs</a> 지원을 추가할 수 있다.
      이로 인해 중앙집중, 연합 및 <a>탈중앙 식별자</a>들 사이의 상호 운용성이 형성 된다.
    </p>

    <p>
      이 규격의 첫번째 목적은 일반적인 <a>DID 스키마</a>와 일반적인 <a>DID 문서</a>들에서 동작하는 명령어 집합을 모든 <a>DID 레지스트리</a>에 구현될 수 있도록 정의하는 것 이다. 이
      규격의 두번째 목적은 <a>DID 메소드</a>를 위한 적합 요구조건(특정 <a>DID 레지스트리</a>를 위한 특정 <a>DID 스키마</a>와 특정 <a>DID 문서</a>에서 동작하는 명령어 세트를
      정의하는 별도의 규격)을 정의하기 위함이다.
    </p>

    <p class="note">
      개념적으로, 이 규격(Decentralized Identifiers)과 <a>DID 메소드</a> 규격의 관계는 IETF 일반 <a>URI</a> 규격([[RFC3986]])과 특정 <a>URI</a>
      체계([[IANA-URI-SCHEMES]])([[RFC7230]]에 명시된 http:와 https: 체계)의 관계와 유사하다. IETF 일반 URN 규격([[RFC8141]]) 및 특정 URN 네임스페이스
      정의([[RFC4122]]에 정의된 <a>UUID</a> URN 네임스페이스 등과 같은)의 관계와도 역시 유사하다.
      차이점은 <a>DID 메소드</a> 규격은 특정 <a>DID 스키마</a>를 정의하는 것 외에도, 적절한 <a>DID 레지스트리</a>에서 <a>DIDs</a>의 구별방법을 제공하거나, 비활성화하거나,
      <a>DID 문서</a>를 작성하는 방법을 명시한다는 것이다.
    </p>

    <p>
      특정 <a>DID 메소드</a> 규격을 가진 일반 <a>DID</a> 규격의 계층적 설계는 <a>URI</a> 규격과 동일한 개념의 일부를 도입한다:
    </p>
    <ul>
      <li>
        다른 URI 체계의 <a>URIs</a>가 상호운용되지 않는 것처럼, 다른 <a>DID 메소드</a>의 <a>DIDs</a>는 상호운용되지 않을 수 있다.
      </li>
      <li>
        일부 브라우저가 특정 URI 체계만 지원하는 경우와 같이, 특정한 <a>DID 메소드</a>만을 지원하는 관계의 지원을 받기 위해 복수의 <a>DIDs</a>가 필요할 수 있다.
      </li>
      <li>
        모든 브라우저가 동일한 URI 체계를 지원하지 않는 것과 같이, 모든 <a>DID 메소드</a>가 동일한 암호 체계를 지원하지는 않기 때문에, 다른 암호화 체계를 지원하기 위해 복수의
        <a>DIDs</a>가 필요할 수 있다.
      </li>
      <li>
        복수의 <a>DIDs</a>의 관리 및 그리고 어떤 <a>DID</a>가 어떤 관계에 속하는지 추적하는 것은, 어떤 웹 주소가 어떤 웹사이트에 속하는지 추적하거나 어떤 이메일 주소가 어떤 관계에
        속하는지 추적하는 것과 유사한 문제를 야기한다.
      </li>
    </ul>

    <p>
      <a>DID 메소드</a> 및 규격 목록은 [[DID-METHOD-REGISTRY]]를 참조하십시오.
    </p>

    <section class="informative" id="simple-example">
      <h2>
        간단한 예제
      </h2>

      <p>
        <a>DID</a>는 3부분으로 구성된 간단한 문자열이다:
      </p>
      <ul>
        <li>
          URL scheme identifier (<code>did</code>)
        </li>
        <li>
          Identifier for the <a>DID method</a>
        </li>
        <li>
          DID method-specific identifier.
        </li>
      </ul>

      <pre class="example nohighlight" title="A simple example of a decentralized identifier (DID)">
did:example:123456789abcdefghi
    </pre>

      <p>
        위의 예제 <a>DID</a>는 <a>DID 문서</a>로 해석될 수 있다. <a>DID 문서</a>에는 <a>DID</a>를 제어하여 개체를 암호학적으로 인증하는 방법 및 개체와 상호 작용하는 데 사용할
        수있는 서비스와 같이 <a>DID</a>와 관련된 정보가 포함되어 있다.
      </p>

      <pre class="example nohighlight" title="Minimal self-managed DID document">
{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:example:123456789abcdefghi",
  "authentication": [{
    <span class="comment">// used to authenticate as did:...fghi</span>
    "id": "did:example:123456789abcdefghi#keys-1",
    "type": "RsaVerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }],
  "service": [{
    <span class="comment">// used to retrieve Verifiable Credentials associated with the DID</span>
    "id":"did:example:123456789abcdefghi#vcs",
    "type": "VerifiableCredentialService",
    "serviceEndpoint": "https://example.com/vc/"
  }]
}
    </pre>
    </section>

    <section class="informative" id="design-goals">
      <h2>
        디자인 목표
      </h2>

      <p>
        <a>탈중앙 식별자들</a>은 [[?VC-DATA-MODEL]]과 같은 검증가능한 증명생태계와 같은 더 큰 시스템의 구성요소이며, 이 규격의 설계를 주도 했다. 이 절에는 이 규격의 기본 설계 목표가
        요약되어 있다.
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>
              Goal
            </th>
            <th>
              Description
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              Decentralization
            </td>
            <td>
              글로벌 고유 식별자, 공개 확인 키, <a>서비스 엔드포인트</a> 및 기타 메타 데이터의 등록을 포함한, 식별자 관리에서 중앙집중식 기관, 또는 단일실패점 요소를 제거해야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Control
            </td>
            <td>
              주어진 개체, 인간과 비인간 모두에게 외부 기관에 의존하지 않고 디지털 식별자를 직접 제어 할 수있는 권한을 부여하십시오.
            </td>
          </tr>

          <tr>
            <td>
              Privacy
            </td>
            <td>
              개체가 속성 또는 기타 데이터의 최소, 선택적 및 점진적 공개를 포함하여 정보의 프라이버시를 제어 할 수 있도록한다.
            </td>
          </tr>

          <tr>
            <td>
              Security
            </td>
            <td>
              필요한 수준의 보증을 위해 <a>DID 문서</a>에 의존할 수 있도록 RP(relying parties)들에게 충분한 보안을 제공한다.
            </td>
          </tr>

          <tr>
            <td>
              Proof-based
            </td>
            <td>
              다른 개체와 상호작용할 때 <a>DID 주체</a>가 암호화 증명을 제공 할 수 있어야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Discoverability
            </td>
            <td>
              다른 개체가 해당 개체에 대해 더 많이 학습하거나 상호 작용할 수 있도록 <a>DIDs</a>를 검색 할 수 있어야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Interoperability
            </td>
            <td>
              <a>DID</a> 인프라는 상호운용성을 위해 설계된 기존 툴과 소프트웨어 라이브러리를 이용할 수 있도록 상호운용성 표준을 사용해야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Portability
            </td>
            <td>
              시스템과 네트워크에 독립적이어야 하며 기업이 <a>DIDs</a> 및 <a>DID 메소드</a>를 지원하는 모든 시스템과 함께 디지털 식별자를 사용할 수 있도록 해야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Simplicity
            </td>
            <td>
              기술을보다 쉽게 이해하고, 구현 및 배포 할 수 있도록 축소 된 간단한 기능을 선호해야 한다.
            </td>
          </tr>

          <tr>
            <td>
              Extensibility
            </td>
            <td>
              상호운용성(Interoperability), 이식성(Portability) 또는 단순성(Simplicity)을 크게 방해하지 않는 경우 가능한 확장할 수 있다.
            </td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="interoperability">
      <h3>
        상호운용성
      </h3>

      <p>
        <a>DIDs</a>와 <a>DID 문서</a>의 구현 상호운용성은 규격에 부합하는 <a>DIDs</a> 및 <a>DID 문서</a>를 작성하고 분석할 수 있는 구현 능력을 평가하여 시험한다.
        <a>DID 메소드</a>의 상호운용성은 최소한 다음과 같이 최소 규격을 평가함으로써 결정된다.:
      </p>
      <ul>
        <li>
          <a>DID 메소드</a> 이름은 겹치지 않고 유일해야 하며, <a>DID 메소드</a>의 기존용례와 모순된 사용은 하지 못한다.
        </li>
        <li>
          요구되는 기능들이 지원되어져야 한다.
        </li>
        <li>
          설명이 필요한 작업에 대해 설명되어야 한다.
        </li>
        <li>
          규격은 독립적 구현을 위해 충분히 구체적이고 상세하고 완전해야 한다.
        </li>
        <li>
          규격은 보안 및 프라이버시 고려사항을 기술하는 섹션을 포함해야 한다.
        </li>
      </ul>

      <p>
        <a>DIDs</a> 및 <a>DID 문서</a>의 생산자와 소비자를 위한 상호운용성은 <a>DIDs</a> 및 <a>DID 문서</a>가 일치하는지 확인함으로써 보장된다. <a>DID 메소드</a>
        규격에 대한 상호운용성은 각 <a>DID 메소드</a> 규격에 있는 세부사항에 의해 보장된다. 웹 브라우저가 알려진 모든 URIs 스키마를 구현할 필요가 없는 것처럼, <a>DIDs</a>와 함께
        작동하는 호환 소프트웨어는 알려진 모든 <a>DID 메소드</a>를 구현할 필요가 없음을 이해해야한다. 그러나 지정된 <a>DID 메소드</a>의 모든 구현은 해당 메소드에 대해 상호운용성이
        보장해야한다.
      </p>
    </section>

  </section>

  <section id="terminology" class="informative">
    <h1>
      용어
    </h1>

    <div data-include="terms.html" data-oninclude="restrictReferences">
    </div>

  </section>

  <section id="data-model" class="informative">
    <h1>
      데이터 모델
    </h1>

    <p>
      이 섹션에서는 <a>decentralized identifier</a> 데이터 모델 개념,
      특히, 키와 서비스 그리고 <a>DID 주체</a>가 <a>DID 문서</a>와 어떻게 관련되어 있는지에 대해 개략적으로 설명한다.
    </p>
      

    <p>
      데이터 모델을 확장하는 방법에 대한 자세한 내용은 
<a href="#extensibility"></a>을 참조한다.
    </p>

    <section id="identifier">
      <h2>
        식별자
      </h2>

      <p>
        데이터 모델에서 식별자는 일반적으로 사람, 조직, 장치, 키, 서비스 및 사물의 특정 인스턴스를 식별하기 위해 사용된다. 
        식별자는 대부분 URLs이며, 좀 더 일반적으로는 <a>URIs</a>이다. 
        비 <a>URI</a> 기반 식별자는 데이터 모델이 이를 지원하기는 하지만, 
        다른 인터넷 기반 식별자와 함께 사용하기 쉽지 않기 때문에 권장되지 않는다.
      </p>
    </section>

    <section id="did-document">
      <h2>
        DID 문서
      </h2>

      <p>
        <a>DID 문서</a>는 <a>decentralized identifier</a>(DID)와 관련된 리소스다. 
        <a>DID 문서</a>는 일반적으로 검증 메소드(public key 등) 및 <a>DID 컨트롤러</a>와 상호 작용 하는데 사용할 수 있는 서비스를 포함한다.
        </p>

        <p>
          <a>DID 문서</a>는 특정 구문에 따라 일련화된다(<a href="#did-document-syntax"></a> 참조). <a>DID</a> 자체는 <code>id</code> 속성에 포함되어 있다. 
      
          </p>

          <p>
            <a>DID 문서</a>에 존재할 수 있는 속성은 <a href="#did-documents"></a>에 자세히 설명되어 있다.
          </p>

          <p>
            <a>DID 문서</a>에 있는 속성은 해당 <a href="#did-methods"></a> 에 따라 업데이트 할 수 있다.
          </p>
    </section>

    <section id="cryptographic-keys-and-other-verification-methods">
      <h2>
        암호화 키 및 기타 검증 메소드
      </h2>

      <p>
        <a>DID 문서</a>는 <a>DID 주체</a> 또는 관련된 것들과의 상호작용을 인증 하거나 승인하는 데 사용할 수 있는 
        암호화 키 및 기타 검증 메소드를 나타낼 수 있다. 
        표현된 정보에는 디지털 서명을 확인하는 데 전역적으로 사용할 수 있는 
        명확한 식별자와 공개키 자료가 포함된다. 
        키의 상태 정보(예: 정지 또는 취소된 경우)나 하드웨어 기반 암호화 키인지 여부를 결정할 수 있는 속성 등 
        기타 정보를 표시할 수 있다.
      </p>

      <p> 
        암호화 키 자료와 관련하여, 공개키는 사용할 대상에 따라 
        <code>publicKey</code> 또는 <code>authentication</code> 속성을 사용하는 <a>DID 문서</a>에 포함될 수 있다. 
  
        각 공개키는 고유한 식별자(<code>id</code>), <code>type</code>, 그리고 <code>controller</code> 뿐만아니라 
        키 유형에 따라 다른 속성을 갖는다. 자세한 내용은 <a href="#public-keys"></a>를 참조한다.
      </p>
    </section>

    <p>
      이 규격은 DID 문서에서 공개키 자료를 표현하기 위한 형식의 수를 가능한 적게 제한하여 상호 운용성을 높이려고 노력한다. 
      구현자가 구현해야하는 형식이 적을수록 모든 형식을 지원할 가능성이 높다. 
      이 접근 방식은 구현의 용이성과 역사적으로 광범위하게 배포된 지원 형식간에 미묘한 균형을 유지한다. 
      이 규격에서 지원되는 특정 유형의 키 형식은 <a href="#public-keys"></a>에 나와 있다.
    </p>
  </section>

  <section id="services">
    <h2>
      서비스
    </h2>

    <p>
      <a>서비스 엔드포인트</a>는 <a>DID 주체</a> 또는 관련 개체와 통신할 수 있는 방법을 나타내기 위해 <a>DID 문서</a>에서 사용된다. 
      <a>DID 문서</a>에 나열된 서비스에는 개인 정보 보호 메시징 서비스에 대한 정보 
      또는 소셜 미디어 계정, 개인 웹사이트, 이메일 주소와 같은 공개 정보가 포함될 수 있다. 
      서비스와 관련된 메타 데이터는 보통 서비스마다 다르다. 예를 들어, 암호화된 메시징 서비스와 관련된 메타 데이터는 
      메시지는 보내기 전에 암호화된 링크를 시작하는 방법을 나타낼 수 있다. 
    </p>

    <p>
      서비스에 대한 포인터는 <code>service</code> 속성을 사용하여 표현한다. 
      각 서비스에는 고유한 <code>id</code> 와 <code>type</code> 뿐만 아니라, <a>URI</a> 또는 
      서비스를 설명하는 추가적 특성이 있는 <code>serviceEndpoint</code> 가 있다. 
    </p>

    <p>
      자세한 내용은 <a href="#service-endpoints"></a>를 참조한다.
    </p>
  </section>

  </section>

  <section class="normative">
    <h1>
      탈중앙 식별자 (DIDs)
    </h1>
    <p>
      전역에서 유일한 <a>탈중앙 식별자</a>는 새로운 개념은 아니다.
      <a>범용고유식별자</a>(UUIDs)는 1980년대에 처음 개발되었고 향후 개방소프트웨어재단의 <a
        href="https://en.wikipedia.org/wiki/Distributed_Computing_Environment">분산 컴퓨팅 환경</a>에서 표준 기능이 되었다.
      <a>UUID</a>는 충돌 가능성이 무한히 작을 정도로 충분한 엔트로피를 가진 128bit 값을 생성하는 알고리즘을 통해
      중앙화된 등록 서비스 없이도 글로벌 유일성을 가질 수 있다.
      <a>UUID</a>는 [RFC4122]에서 URN(Unified Resource Name)의 특정 형식으로써 공식 명시되어 있다.
    </p>

    <p>
      <a>DID</a>는 아래 사항을 제외하고는 <a>UUID</a>와 유사하다:
    </p>
    <ul>
      <li>
        URL과 동일하게, 주체에 대해 설명하는 일반 자원을 주소 분해(Resolve)하거나 역참조(Dereferenced)한다.
        더 상세한 내용은 섹션 <a href="#did-documents"></a> 참조.
      </li>
      <li>
        URL을 역참조 할 경우 반환되는 리소스와는 다르게, <a>DID 문서</a>는 일반적으로 <a>DID 주체</a>에 대한 인증을 가능하게 하는 암호학적 요소를 포함하고 있다.
      </li>
    </ul>

    <section id="generic-did-syntax">
      <h2>
        일반 DID 구문
      </h2>

      <p>
        일반 <a>DID 스키마</a>는 [[!RFC3986]]을 준수하는 URI 체계이다.
        <a>DID 스키마</a>는 <a>DID URL</a> 체계 및 권한 구성 요소에만 특화되어 있다.
        <code>path-abempty</code>, <code>query</code>, 그리고 <code>fragment</code> 구성 요소들은 [[!RFC3986]]에서 정의된 ABNF 규칙과
        동일하다.
      </p>

      <p class="note">
        <a>DID</a>라는 용어는 아래와 같이 ABNF의 <code>did</code> 규칙을 따르는 URI만을 의미한다.
        <a>DID</a>는 <a>DID 주체</a>를 항상 식별한다.
        <a>DID URL</a>이라는 용어는 <code>did-url</code> 규칙에 따라 정의되는데, <a>DID</a>로 시작하고 그 뒤에 하나 이상의 구성 요소가 추가되는 URL을 나타낸다.
        <a>DID URL</a>은 찾아야 할 리소스를 항상 식별한다.
      </p>

      <p>
        아래는 <code>ALPHA</code>와 <code>DIGIT</code>을 정의하는 [[!RFC5234]] 구문을 사용하는 ABNF 정의에 대한 것이다.
        ABNF에서 정의되지 않은 다른 모든 규칙 이름들은 RFC3986에 정의되어 있다.
      </p>

      <pre class="nohighlight">
did                = "did:" method-name ":" method-specific-id
method-name        = 1*method-char
method-char        = %x61-7A / DIGIT
method-specific-id = *idchar *( ":" *idchar )
idchar             = ALPHA / DIGIT / "." / "-" / "_"
did-url            = did *( ";" param ) path-abempty [ "?" query ]
                     [ "#" fragment ]
param              = param-name [ "=" param-value ]
param-name         = 1*param-char
param-value        = *param-char
param-char         = ALPHA / DIGIT / "." / "-" / "_" / ":" /
                     pct-encoded
      </pre>

      <p class="issue" data-number="34">
        The grammar currently allows an empty <code>method-specific-id</code>,
        e.g., <code>did:example:</code> would be a valid <a>DID</a> that could identify
        the <a>DID method</a> itself.
      </p>

    </section>

    <section>
      <h2>
        메소드 특화 구문
      </h2>

      <p>
        <a>DID 메소드</a> 명세는 반드시 <code>method-name</code>과 <code>method-specific-id</code> 구문을 정의함으로써 일반 DID 구문을 추가로 제한해야
        한다.
        더 상세한 내용은 섹션 <a href="#did-methods"></a> 참조.
      </p>
    </section>

    <section>
      <h2>
        일반 DID 매개변수 이름
      </h2>

      <p>
        <a>DID URL</a> 구문은 matrix parameter 구문([[MATRIX-URIS]])을 기반의 매개변수를 위한 간단하고 일반화 된 포멧을 지원한다.
        위의 ABNF는 매개변수 이름에 대해 어떠한 것도 특정하지 않는다 (<code>param-name</code> 규칙)
      </p>
      <p>
        일부 일반 DID 매개변수 이름(예를들면, 서비스 선택을 위한)은 어떠한 특정 <a>DID 메소드</a>와 완전히 독립적이어야 하며,
        반드시 모든 <a>DID</a>와 동일하게 작동해야만 한다.
        그 외(예를들면, 버전관리를 위한)는 특정 <a>DID 메소드</a>에 의해 지원될 수 있지만,
        반드시 <a>DID 메소드</a>가 그것을 지원하는 방식으로 동일하게 작동해야만 한다.
      </p>
      <p>
        메소드에 완전히 특화된 매개변수 이름은 <a href="#method-specific-did-parameter-names"></a>에서 설명하고 있다.
      </p>
      <p>
        아래 표는 일반 DID 매개변수 이름 세트를 정의하고 있다:
      </p>
      <table class="simple">
        <thead>
          <tr>
            <th>
              일반 DID 매개변수 이름
            </th>
            <th>
              설명
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              <code>hl</code>
            </td>
            <td>
              [[HASHLINK]]에 명시된, 무결성 보호를 추가하기 위한 <a>DID 문서</a>의 자원 해시
            </td>
          </tr>
          <tr>
            <td>
              <code>service</code>
            </td>
            <td>
              서비스 ID를 통해 DID 문서로 부터 서비스를 식별
            </td>
          </tr>
          <tr>
            <td>
              <code>version-id</code>
            </td>
            <td>
              해석할 <a>DID 문서</a>의 특정 버전을 식별 (버전 ID는 순차적이거나 <a>UUID</a>이거나 메소드에 특화될 수 있음.
              이 매개변수는 모든 <a>DID 메소드</a>에서 지원하지 않을 수 있음에 주의
            </td>
          </tr>

          <tr>
            <td>
              <code>version-time</code>
            </td>
            <td>
              해석할 <a>DID 문서</a>의 특정 버전 타임스탬프를 식별. 즉, 특정 시간의 <a>DID</a>에 대해 <a>DID 문서</a>가 유효하다는 것을 의미.
              이 매개변수는 모든 <a>DID 메소드</a>에서 지원하지 않을 수 있음에 주의
            </td>
          </tr>
        </tbody>
      </table>

      <p>
        위 매개변수들을 위한 정확한 처리 규칙은 [[DID-RESOLUTION]]에 명시되어 있다.
      </p>

      <p class="note">
        DID URL에 포함되지는 않지만 <a>DID 리졸버</a>에 <em>대역외(Out-of-band)</em>로 전달하는 추가적인 매개변수나 옵션이 있을 수 있다.
        예를들면, Resolution 프로토콜 혹은 다른 어떤 메커니즘을 사용하는 것이다.
        이러한 옵션은 캐싱(Caching) 또는 기대하는 Resolution 결과에 대한 형식을 제어할 수도 있다.
        이것은 HTTP와 유사하게 캐싱 또는 결과 형식이 HTTP URL의 일부가 아닌 HTTP 헤더에 표현되는 것과 같다.
        중요한 구별점은 <a>DID URL</a>의 일부가 아닌 DID 매개변수는 어떠한 자원이 식별되는지를 지정하는 반면,
        <a>DID URL</a>의 일부가 아닌 <a>DID 리졸버</a> 옵션은 해당 자원이 어떻게 역참조하는지를 제어한다는 점이다.
      </p>
    </section>

    <section>
      <h2>
        Method-Specific DID Parameter Names
      </h2>

      <p>
        A <a>DID method</a> specification MAY specify additional method-specific
        parameter names. A method-specific parameter name MUST be prefixed by the method
        name, as defined by the <code>method-name</code> rule.
      </p>

      <p>
        For example, if the method <code>did:foo:</code> defines the parameter bar, the
        parameter name must be <code>foo:bar</code>. An example <a>DID URL</a> using
        this method and this method-specific parameter would be as shown below.
      </p>

      <pre class="example nohighlight">
did:foo:21tDAKCERh95uGgKbJNHYp;foo:bar=high
      </pre>

      <p class="issue" data-number="35">
        Consider using kebab-case style instead of colon separator,
        e.g., <code>foo-bar</code> instead of <code>foo:bar</code>.
      </p>

      <p>
        A method-specific parameter name defined by one <a>DID method</a> MAY be used by
        other <a>DID methods</a>.
      </p>

      <pre class="example nohighlight">
did:example:21tDAKCERh95uGgKbJNHYp;foo:bar=low
      </pre>

      <p>
        Method-specific parameter names MAY be combined with generic parameter names in
        any order.
      </p>

      <pre class="example nohighlight">
did:example:21tDAKCERh95uGgKbJNHYp;service=agent;foo:bar=high
      </pre>

      <p>
        Both <a>DID method</a> namespaces and method-specific parameter namespaces MAY
        include colons, so they might be partitioned hierarchically, as defined by a
        <a>DID method</a> specification. The following example <a>DID URL</a>
        illustrates both.
      </p>

      <pre class="example nohighlight">
did:foo:baz:21tDAKCERh95uGgKbJNHYp;foo:baz:hex=b612
      </pre>
    </section>

    <p class="issue" data-number="36">
      Review what exactly we want to say about method-specific parameters
      defined by one method but used in a <a>DID URL</a> with a different method.
      Also discuss hierarchical method namespaces in DID parameter names.
    </p>

    <section>
      <h2>
        Path
      </h2>

      <p>
        A generic <a>DID path</a> is identical to a URI path and MUST conform to the
        <code>path-abempty</code> ABNF rule in [[!RFC3986]]. A <a>DID path</a> SHOULD be
        used to address resources available through a <a>service endpoint</a>. For more
        information, see Section <a href="#service-endpoints"></a>.
      </p>

      <p>
        A specific <a>DID scheme</a> MAY specify ABNF rules for <a>DID paths</a> that
        are more restrictive than the generic rules in this section.
      </p>

      <pre class="example nohighlight">
did:example:123456/path
      </pre>
    </section>

    <section>
      <h2>
        Query
      </h2>

      <p>
        A generic <a>DID query</a> is identical to a URI query and MUST conform to the
        <code>query</code> ABNF rule in [[!RFC3986]]. A <a>DID query</a> SHOULD be used
        to address resources available through a <a>service endpoint</a>. For more
        information, see Section <a href="#service-endpoints"></a>.
      </p>

      <p>
        A specific <a>DID scheme</a> MAY specify ABNF rules for <a>DID queries</a> that
        are more restrictive than the generic rules in this section.
      </p>

      <pre class="example nohighlight">
did:example:123456?query=true
      </pre>
    </section>

    <section>
      <h2>
        Fragment
      </h2>

      <p>
        A generic <a>DID fragment</a> is identical to a URI fragment and MUST conform to
        the <code>fragment</code> ABNF rule in [[RFC3986]]. Implementers are strongly
        discouraged from using a <a>DID fragment</a> for anything other than a
        method-independent reference into the <a>DID document</a> to identify a
        component of a <a>DID document</a> (for example, a unique
        <a>public key description</a> or <a>service endpoint</a>). To resolve this
        reference, the complete <a>DID URL</a> including the <a>DID fragment</a> MUST be
        used as input to the <a>DID URL</a> dereferencing algorithm for the
        target component in the <a>DID document</a> object. For more information, see
        [[DID-RESOLUTION]].
      </p>

      <p>
        A specific <a>DID scheme</a> MAY specify ABNF rules for <a>DID fragments</a>
        that are more restrictive than the generic rules in this section.
      </p>

      <p>
        Implementations need not rely on graph-based processing of <a>DID documents</a>
        to locate metadata contained in the <a>DID document</a> when the <a>DID</a>
        includes a <a>DID fragment</a>. Tree-based processing can be used instead.
      </p>

      <p>
        Implementations SHOULD NOT prevent the use of <a>JSON Pointer</a>
        ([[!RFC6901]]).
      </p>

      <pre class="example nohighlight">
did:example:123456#oidc
      </pre>
    </section>

    <section>
      <h2>
        Normalization
      </h2>

      <p>
        For the broadest interoperability, make <a>DID</a> normalization as simple and
        universal as possible:
      </p>
      <ul>
        <li>
          The <a>DID scheme</a> name MUST be lowercase.
        </li>

        <li>
          The <a>DID method</a> name MUST be lowercase.
        </li>

        <li>
          Case sensitivity and normalization of the value of the
          <code>method-specific-id</code> rule in Section
          <a href="#generic-did-syntax"></a> MUST be defined by the governing
          <a>DID method</a> specification.
        </li>
      </ul>
    </section>

    <section>
      <h2>
        Persistence
      </h2>

      <p>
        A <a>DID</a> is expected to be persistent and immutable. That is, a <a>DID</a>
        is bound exclusively and permanently to its one and only subject. Even after a
        <a>DID</a> is deactivated, it is intended that it never be repurposed.
      </p>

      <p>
        Ideally, a <a>DID</a> would be a completely abstract decentralized identifier
        (like a <a>UUID</a>) that could be bound to multiple underlying
        <a>DID registries</a> over time, thus maintaining its persistence independent of
        any particular system. However, registering the same identifier on multiple
        <a>DID registries</a> introduces extremely hard entityship and
        <a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types%23SOA">start-of-authority</a>
        (SOA) problems. It also greatly increases implementation complexity for
        developers.
      </p>

      <p>
        To avoid these issues, it is RECOMMENDED that <a>DID method</a> specifications
        only produce <a>DIDs</a> and <a>DID methods</a> bound to strong, stable
        <a>DID registries</a> capable of making the highest level of commitment to
        persistence of the <a>DID</a> and <a>DID method</a> over time.
      </p>

      <p class="note">
        Although not included in this version, future versions of this specification
        might support a <a>DID document</a> <code>equivID</code> property to establish
        verifiable equivalence relations between <a>DIDs</a> representing the same
        subject on multiple <a>DID registries</a>. Such equivalence relations can
        produce the practical equivalent of a single persistent abstract <a>DID</a>. For
        more information, see Section <a href="#future-work"></a>.
      </p>
    </section>
  </section>

  <section class="normative" id="did-documents">
    <h1>
      DID 문서
    </h1>

    <p>
      <a>DID</a>는 <a>DID 문서</a>를 가리킨다. 
      <a>DID 문서</a>들은 <a href="#data-model"></a>을 직렬화 한 것이다. 
      이번 섹션에서는 <a>DID 문서</a>의 속성과 이 속성들이 필수인지 옵션인지를 정의한다.
    </p>

    <section id="contexts">
      <h2>Contexts</h2>

      <p>
        두 개의 소프트웨어 시스템이 데이터를 교환해야 하는 경우 
        두 시스템이 이해할 수 있는 용어와 프로토콜을 사용해야 한다. 
        <code>@context</code> 속성은 동일한 DID 문서에서 작동하는 두 시스템이 서로 동의하는 용어를 사용하도록 한다.
      </p>

      <p>
        <a>DID 문서</a>는 반드시 <code>@context</code> 속성을 포함해야 한다.
      </p>

      <p class="note" title="The JSON-LD Context">
        <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD Context</a>에 대한 
        자세한 정보는 [[JSON-LD]] 사양에서 확인할 수 있다.
      </p>

      <dl>
        <dt><dfn>@context</dfn></dt>
        <dd>
          <code>@context</code> 속성의 값은 반드시 하나 이상의 <a>URIs</a> 여야 하며, 
          여기서 첫 번째 <a>URI</a>의 값은 <code>https://www.w3.org/ns/did/v1</code> 이다. 
          둘 이상의 <a>URI</a>가 제공될 경우, <a>URIs</a>는 반드시  순서있는 배열로 해석되어야 한다. 
          <a>URIs</a>를 역 참조하여 컨텍스트에 대한 기계 판독 가능한 정보가 포함된 문서를 생성 하는 것이 좋다. 
        </dd>
      </dl>

      <p>
        Example:
      </p>

      <pre class="example nohighlight">
{
  "@context": "https://www.w3.org/ns/did/v1"
}
</pre>
<p>
  <a>DID 문서</a> 규격은 자체 JSON-LD 컨텍스트를 정의 할 수 있다. 
  하지만 메소드를 올바르게 구현하는 데 필요한 경우가 아니면 새 컨텍스트를 정의하는 것은 권장하지 않는다. 
  메소드별 컨텍스트는 일반 <a>DID</a> 컨텍스트에 정의된 용어를 재정의하면 안된다.
</p>
    </section>

    <section id="did-subject">
      <h2>
DID 주체
      </h2>

      <p>
<a>DID 주체</a>는 <code>id</code> 속성으로 표시된다.
DID 주체는 <a>DID</a>가 식별하고 <a>DID 문서</a>가 설명하고자 하는 항목을 말한다.
      </p>

      <p>
<a>DID 문서들</a>은 반드시 <code>id</code> 속성을 포함해야 한다.
      </p>

      <dl>
          <dt><dfn>id</dfn></dt>
          <dd>
<code>id</code>의 값은 반드시 하나의 유효한 <a>DID</a>이어야 한다.
          </dd>
      </dl>

      <p>
예시:
      </p>

      <pre class="example nohighlight">
{
  "id": "did:example:21tDAKCERh95uGgKbJNHYp"
}
      </pre>
      <p class="note">
어떤 <a>DID 메소드</a> 규격은 <a>DID 리졸버</a>가 DID 해석을 수행하는 것과 같은 경우에
<code>id</code>라는 키를 가지고 있지 않은 중간 형태의 <a>DID 문서</a>를 생성할 수도 있다. 
그러나, (중간 형태가 아닌) 완전하게 해석된 <a>DID 문서</a>는 항상 유효한 <code>id</code> 속성을 가지고 있다.
해석된 <a>DID 문서</a>에 있는 <code>id</code>의 값은 해석한 <a>DID</a>와 같아야 한다.
      </p>
    </section>
    <!-- section>
      <h2>Delegates</h2>
        <p class="issue">
The way that Delegates are handled is changing. The feature is still supported,
but via the `authorizationCapability` field rather than the more specialized
`guardian` field.
        </p>
        <p>
A delegate is an entity, such as a parent or aid organization, that creates and
maintains a <a>DID document</a> for a dependent who is not in a position to hold
or control authentication credentials (e.g., cryptographic keys).
        </p>
        <p>
The rules for a delegate are:
        </p>
        <ol start="1">
          <li>
A <a>DID document</a> that includes an
<code>authentication</code> field
(Section <a href="#authentication"></a>) MAY list one or
more delegates via the <code>authorizationCapability</code> field.
          </li>
          <li>
A <a>DID document</a> that does not include an
<code>authentication</code> MUST have a delegate.
          </li>
          <li>
The <code>authorizationCapability</code> field must contain a capability for the
delegate that includes <code>UpdateDidDocument</code> as the capability,
the <a>DID</a> of the delegate as the <code>entity</code>, and MAY include a
more specific set of <code>authentication</code>s that the
delegate MAY use to authenticate when updating the <a>DID document</a>.
          </li>
          <li>
The delegate <a>DID</a> MUST resolve to a <a>DID document</a> that has a
<code>authentication</code> property containing at least one value,
i.e., the delegate relationships must not be nested.
          </li>
        </ol>
        <p>
Example:
        </p>
<pre class="example nohighlight" title="Basic DID document">
{
"@context": "https://www.w3.org/ns/did/v1",
"id": "did:example:123456789abcdefghi",
"authorizationCapability": [{
  // this entity is a delegate and may update any field in this
  // DID document using any authentication mechanism understood
  // by the ledger
  "permission": "UpdateDidDocument",
  "entity": "did:example:zxyvwtrkpn987654321"
}],
"authentication": [{
  // this biometric can be used to authenticate as did:...fghi
  "type": "PseudonymousBiometricTemplate2017",
  "biometricService": "https://example.com/authenticate",
  "biometricTemplateShard": "Mjk4MzQyO...5Mzg0MDI5Mwo="
}],
"service": [{
  "type": "ExampleService",
  "serviceEndpoint": "https://example.com/endpoint/8377464"
}]
}
</pre>
    </section -->

    <section id="public-keys">
      <h2>
공개키
      </h2>

      <p>
공개키는 인증(<a href="#authentication"></a> 참조)이나 <a>서비스 엔드포인트</a>
(<a href="#service-endpoints"></a> 참조)와의 안전한 통신 채널을 수립하는데 기초가 되는 
전자서명, 암호화 그리고 암호 연산에 사용된다. 또한, 공개키는 <a>DID 메소드</a> 규격에 정의되는 
<a>DID</a>의 CRUD 작업(<a href="#did-operations"></a>참조)에 있어서 
권한 부여 메커니즘으로 활용되기도 한다.
      </p>

      <p>
<a>DID 문서</a>는 <code>publicKey</code> 속성을 포함 할 수도 있다. 만약 포함한다면:
      </p>

      <dl>
          <dt><dfn>publicKey</dfn></dt>
          <dd>
<code>publicKey</code> 속성의 값은 반드시 공개키 객체들의 배열이어야 한다. 
각 공개키 객체는 <code>type</code>, <code>controller</code> 속성 및 각 공개키에 특화된
속성을 반드시 포함하고 있어야 하며, <code>id</code> 속성을 포함해야 한다. 공개키 객체는 추가적인
속성도 포함할 수 있다.
          </dd>
      </dl>

      <p>
(만약 존재한다면) <code>id</code> 속성의 값은 반드시 URI이어야 한다. 공개키의 배열에는 
중복되는 <code>id</code>가 무조건 없어야 한다. 그런 경우, <a>DID 문서</a> 프로세서에서
반드시 에러를 발생시켜야만 한다.
      </p>

      <p>
<code>type</code> 속성의 값은 반드시 하나의 공개키 값이어야 한다
(사용 가능한 키 타입은 부록의 <a href="#registries"></a> 참조).
      </p>

      <p>
개인키와 관련된 컨트롤러를 식별하는 <code>controller</code> 속성의 값은 반드시 유효한 DID여야 한다.
      </p>

      <p>
모든 공개키의 속성들은 반드시 연결 데이터 암호화 수트 레지스트리(Linked Data Cryptographic Suite Registry)에 
정의되어 있는 값이어야만 한다.
키 타입과 형식의 등록 정보는 부록 <a href="#registries"></a>에서 확인할 수 있다.
      </p>

      <p>
만약 공개키가 <a>DID 문서</a>에 존재하지 않는다면, 반드시 그 키가 폐기되었거나 유효하지 않다고
간주해야 한다. 그 <a>DID 문서</a>에는 폐기된 키들을 포함하고 있을 수도 있다. 
폐기된 키를 포함하고 있는 <a>DID 문서</a>는 반드시 그 키에 대한 폐기 정보들 포함하거나 참조하고 있어야 한다
(예. 폐기된 키 리스트). 각각의 <a>DID 메소드</a> 규격에는 키가 어떻게 폐기되고 
그 정보가 어떻게 추적되는지 설명되어야 한다.
      </p>

      <p>
모든 공개키의 형식은 반드시 <code>publicKeyJwk</code> 속성을 사용한 JWK (JSON Web Key) 포맷이거나,
아래 표예 설명한 포맷 중에 하나여야 한다. 공개키의 표현형은 어떤 경우에도 다른 키의 포맷을 사용할 수 없다.
      </p>

      <p class="issue">
        The Working Group is still debating whether the base encoding format used
        will be Base58 (Bitcoin) [[BASE58]], base64url [[RFC7515]] or base16 (hex) [[RFC4648]]. The entries in the
        table below currently assume PEM and Base58 (Bitcoin), but may change to base64url and/or base16 (hex) once
        the group achieves consensus on this particular issue.
      </p>


      <p class="issue">
        The Working Group is still debating whether secp256k1 Schnorr public key values
        will be elaborated upon in this specification and if so, how they will be
        expressed and encoded.
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>
              Key&nbsp;Type
            </th>
            <th>
              Support
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              RSA
            </td>
            <td>
RSA 공개키 값은 반드시 JWK로 인코딩하거나 <code>publicKeyPem</code> 속성을 사용하여 
PEM(Privacy Enhanced Mail) 포맷으로 인코딩해야 한다.
            </td>
          </tr>
          <tr>
            <td>
              ed25519
            </td>
            <td>
Ed25519 공개키 값은 반드시 JWK로 인코딩하거나 <code>publicKeyBase58</code> 속성을 사용하여
원시형태(raw)의 32 바이트 공개키 값을 Base58 비트코인 포맷으로 인코딩해야 한다.
            </td>
          </tr>
          <tr>
            <td>
              secp256k1-koblitz
            </td>
            <td>
Secp256k1 Koblitz 공개키 값은 반드시 JWK로 인코딩하거나 <code>publicKeyBase58</code> 속성을 사용하여
원시형태의 33바이트 공개키 값을 Base58 비트코인 포맷으로 인코딩해야 한다.
            </td>
          </tr>
          <tr>
            <td>
              secp256r1
            </td>
            <td>
Secp256r1 공개키 값은 반드시 JWK로 인코딩하거나 <code>publicKeyBase58</code> 속성을 사용하여
원시형태의 32바이트 공개키 값을 Base58 비트코인 포멧으로 인코딩해야 한다.
            </td>
          </tr>
          <tr>
            <td>
              Curve25519
            </td>
            <td>
(X25519로도 알려진) Curve25519 공개키 값은 반드시 JWK로 인코딩하거나 
<code>publicKeyBase58</code> 속성을 사용하여 원시형태의 32바이트 공개키 값을 Base58 비트코인 포맷으로 
인코딩해야 한다.
            </td>
          </tr>
        </tbody>
      </table>

      <p>
예시:
      </p>

      <pre class="example nohighlight" title="Various public keys">
{
  "@context": ["https://www.w3.org/ns/did/v1", "https://w3id.org/security/v1"],
  "id": "did:example:123456789abcdefghi",
  <span class="comment">...</span>
  "publicKey": [{
    "id": "did:example:123456789abcdefghi#keys-1",
    "type": "RsaVerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }, {
    "id": "did:example:123456789abcdefghi#keys-2",
    "type": "Ed25519VerificationKey2018",
    "controller": "did:example:pqrstuvwxyz0987654321",
    "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
  }, {
    "id": "did:example:123456789abcdefghi#keys-3",
    "type": "Secp256k1VerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyHex": "02b97c30de767f084ce3080168ee293053ba33b235d7116a3263d29f1450936b71"
  }],
  <span class="comment">...</span>
}
</pre>
      <p>
키는 <a>DID 문서</a>에 <em>포함</em>되어 있거나 <em>참조</em>되어 있을 수 있다. 
예를 들어, 아래의 <code>authentication</code> 속성은 두 가지 방식으로 키를 참조한다:
      </p>

      <pre class="example nohighlight" title="Various public keys">
{
<span class="comment">...</span>

  "authentication": [
    <span class="comment">// 이 키는 하나 이상의 목적으로 사용될 수 있도록 참조 방식을 사용한다</span>
    "did:example:123456789abcdefghi#keys-1",
    <span class="comment">// 이 키는 문서에 포함되어 있으며, *오직* 인증 목적으로만 사용할 수 있다</span>
    {
      "id": "did:example:123456789abcdefghi#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:example:123456789abcdefghi",
      "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
    }
  ],

<span class="comment">...</span>
}
</pre>
      <p>
<a>DID 문서</a>에서 <code>publicKey</code> 속성을 처리할 때 사용하는 알고리즘은 다음과 같다:
      </p>

      <ol class="algorithm">
        <li>
<em>value</em>는 <code>publicKey</code> 속성과 관련된 데이터로 세팅되고, 
<em>result</em>는 <code>null</code>로 초기화된다.
        </li>

        <li>
만약 <em>value</em>가 객체이면, 키 재료는 문서에 포함되어 있는 것이다. 
<em>result</em>를 <em>value</em>로 세팅한다.
        </li>

        <li>
만약 <em>value</em>가 문자열이라면, 키는 참조 형식을 사용하는 것이다.
<em>value</em>는 URL이라고 가정한다.
          <ol>
            <li>
URL이 참조하고 있는 곳을 찾아서, 그 URL과 연관된 <code>publicKey</code> 속성을 가져온다
(예를 들어 참조되고 있는 문서의 최상위부터 <code>publicKey</code> 속성을 처리한다).
            </li>

            <li>
각 공개키 객체에 대해 다음을 반복한다.
              <ol>
                <li>
만약 객체의 <code>id</code> 속성이 <em>value</em>와 같다면, 
<em>result</em>를 그 객체로 세팅한다.
                </li>
              </ol>
            </li>
          </ol>
        </li>

        <li>
만약 <em>result</em>가 <code>id</code>, <code>type</code>, <code>controller</code>와 같은 
속성을 포함하고 있지 않거나 <em>result</em>의 <code>type</code> 속성에 따른 
필수 공개 암호 재료를 포함하고 있지 않다면 에러를 발생시킨다.
        </li>
      </ol>

      <p class="note">
위의 예시에서 <code>controller</code> 항목이 불필요해 보이지만, 키가 정의되는 <a>DID 문서</a>와 
컨트롤러가 설명된 <a>DID 문서</a>가 다를 수 있기 때문에 필요하다. 연결 데이터 증명(Linked Data Proof)
라이브러리는 보통 <code>controller</code> 항목이 항상 존재한다고 가정하고 있으며, 
만약 <code>controller</code> 필드가 없다면 예외를 발생시킬 수 있다. 게다가 <a>DID 문서</a>는 
그래프나 트리 형태로 해석될 수 있다는 요구사항과 관련하여, 
트리에서 키의 위치(position)를 이용해서 기본 <code>controller</code> 항목을 추론할 수 없다.
      </p>

      <p class="note">
<a>DID 문서</a>에 설명된 키를 캐싱하고 만료시키는 것은 전적으로 <a>DID 리졸버</a>와 
다른 클라이언트 프로그램의 책임이다. <a href="#did-resolvers"></a> 참조.
      </p>
    </section>

    <section id="authentication">
      <h2>
        인증
      </h2>

      <p>
        인증은 <a>DID 컨트롤러</a>가 해당 DID와 연결되어 있다는 것을 암호화 방식으로
        증명할 수 있는 메커니즘이다. <a href="#binding-of-identity"></a>을 참조.
        DID 컨트롤러는 다른 사람이 자신의 DID 문서에 대한 제어 권한을 증명하지 않고도
        <a>DID 문서</a>를 업데이트하도록 (예. <a href="#key-revocation-and-recovery"></a>에서
        설명하고 있는 키 복구 지원 참조) 인증과 권한 부여가 분리되어 있다
        (그러므로 <a>DID 컨트롤러</a>에 대한 위장이 가능함).
      </p>

      <p>
        <a>DID 문서</a>는 무조건 <code>authentication</code> 속성을 포함해야한다. 그렇다면:
      </p>
      <dl>
        <dt><dfn>authentication</dfn></dt>
        <dd>
          <code>authentication</code> 속성 값은 검증 메소드의 배열이어야 한다.
          각각의 검증 방법은 포함되거나 참조될 수 있다.
          검증 방법의 예로는 공개키 방식이 있다 (<a href="#public-keys"></a>참조).
        </dd>
      </dl>

      <p>
        예제:
      </p>

      <pre class="example nohighlight" title="세가지 검증 방법이 포함 된 인증 속성값">
{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:example:123456789abcdefghi",
  <span class="comment">...</span>
  "authentication": [
    <span class="comment">// 이 메소드는 DID(…fghi)로 인증시 사용할 수 있다</span>
    "did:example:123456789abcdefghi#keys-1",
    <span class="comment">// 이 메소드는 DID(…fghi)로 인증시 사용할 수 있다</span>
    "did:example:123456789abcdefghi#biometric-1",
    <span class="comment">// 이 방법은 인증을 위해 *전용*으로 권한을 부여받았으며,</span>
    <span class="comment">// 다른 증명 목적으로 사용될 수 없다.</span>
    <span class="comment">// 전체 설명은 참조를 사용하지 않고 포함된다.</span>
    {
      "id": "did:example:123456789abcdefghi#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:example:123456789abcdefghi",
      "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
    }
  ],
  <span class="comment">...</span>
}
</pre>
    </section>

    <section id="authorization-and-delegation">
      <h2>
        인가 및 위임
      </h2>

      <p>
        인가는 DID 주체를 대신하여 작업이 어떻게 수행되는지에 대해서 설명하는데 쓰이는
        메커니즘이다. 위임은 다른 사람이 <a>DID 주체</a>를 대신할 수 있도록 권한을 부여하는데
        사용하는 메커니즘이다. <a href="#authentication"></a>에서 설명한 바와 같이 인증과
        인가는 분리되어 있다. 이는 키의 분실로 더 이상 키에 액세스 할 수 없거나 키가 유출되어
        <a>DID 컨트롤러</a>의 제3신뢰기관들(trusted third parties)이 공격자의 악의적인
        활동의 무효화(override)가 필요한 경우 키를 복구하기 위해 중요하다.
        <a href="#security-considerations"></a> 참고.
      </p>

      <p>
        각 <a>DID 메소드</a>는 필수적인 암호화 연산을 포함하여 인가 및 위임이 구현되는
        방법을 정의해야 한다.
      </p>

      <p>
        인가 및 위임의 구현 방법에 대하여 최소한 2가지 방법이 제안되어 있으며
        이는 서로 겹쳐 사용할 수 있다:
      </p>

      <ol>
        <li>
          <a>DID 레지스트리</a>는 <a>DID 문서</a>가 제어하는 다른 <a>DID 컨트롤러</a>의
          <a>DID</a>를 표현하거나 추가하여 간략한 <code>controller</code> 패턴을 구현할 수 있다.
        </li>

        <li>
          <a>DID 레지스트리</a>는 인가 및 위임을 정교하게 제어 할 수 있는 기능 기반
          접근 방식으로 구현할 수 있다.
        </li>
      </ol>

      <p>
        예제:
      </p>

      <pre class="example nohighlight" title="controller 속성이 있는 DID 문서">
{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:example:123456789abcdefghi",
  "controller": "did:example:bcehfew7h32f32h7af3",
  "service": [{
    <span class="comment">// DID와 관련된 검증 가능 자격 증명의 검색 시 사용</span>
    "type": "VerifiableCredentialService",
    "serviceEndpoint": "https://example.com/vc/"
  }]
}
        </pre>
    </section>

    <section id="service-endpoints">
      <h2>
        서비스 엔드포인트
      </h2>

      <p>
        <a>DID 문서</a>의 주요 목적은 <a>서비스 엔드포인트</a>를 검색할 수 있게 하는 것이다.
        <a>서비스 엔드포인트</a>는 추가 탐색, 인증, 인가 또는 상호작용을 위한
        <a>탈중앙 ID 관리</a>서비스를 포함하여 <a>DID 주체</a>가 공시하는 모든 유형의
        서비스를 나타낼 수 있다.
      </p>

      <p>
        <a>DID 문서</a>는 <code>service</code> 속성을 포함 할 수도 있다. 그렇다면:
      </p>

      <dl>
        <dt><dfn>service</dfn></dt>
        <dd>
          <code>service</code> 속성의 값은 반드시 <a>서비스 엔드포인트</a>의 배열이어야 한다.
          각 <a>서비스 엔드포인트</a>에는 무조건 <code>type</code>,
          <code>serviceEndpoint</code> 및 <code>id</code> 속성이 포함되어야 하며
          추가적인 속성이 포함될 수 있다.
        </dd>
      </dl>

      <p>
        The value of the <code>id</code> property (if present) MUST be a URI.
        The array of <a>service endpoints</a> MUST NOT contain multiple entries
        with the same <code>id</code>. A <a>DID document</a> processor MUST
        produce an error in that case.
      </p>

      <p>
        <code>serviceEndpoint</code> 속성의 값은 JSON-LD 객체이거나 [[RFC3986]]을 따르는
        유효한 <a>URI</a>이어야하고, [[RFC3986]]의 6장 규칙 및 그 밖의 적용 가능한
        URI 스킴 명세서의 규칙에 따라 정규화되어야 한다.
      </p>

      <p>
        <a>서비스 엔드포인트</a> 프로토콜은 표준 명세서로 공개되어야 한다.
      </p>

      <p>
        예제:
      </p>

      <pre class="example nohighlight" title="다양한 서비스 엔드포인트">
{
  "service": [{
    "id": "did:example:123456789abcdefghi#openid",
    "type": "OpenIdConnectVersion1.0Service",
    "serviceEndpoint": "https://openid.example.com/"
  }, {
    "id": "did:example:123456789abcdefghi#vcr",
    "type": "CredentialRepositoryService",
    "serviceEndpoint": "https://repository.example.com/service/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#xdi",
    "type": "XdiService",
    "serviceEndpoint": "https://xdi.example.com/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#agent",
    "type": "AgentService",
    "serviceEndpoint": "https://agent.example.com/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#hub",
    "type": "IdentityHub",
    "publicKey": "did:example:123456789abcdefghi#key-1",
    "serviceEndpoint": {
      "@context": "https://schema.identity.foundation/hub",
      "type": "UserHubEndpoint",
      "instances": ["did:example:456", "did:example:789"]
    }
  }, {
    "id": "did:example:123456789abcdefghi#messages",
    "type": "MessagingService",
    "serviceEndpoint": "https://example.com/messages/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#inbox",
    "type": "SocialWebInboxService",
    "serviceEndpoint": "https://social.example.com/83hfh37dj",
    "description": "My public social inbox",
    "spamCost": {
      "amount": "0.50",
      "currency": "USD"
    }
  }, {
    "id": "did:example:123456789abcdefghi#authpush",
    "type": "DidAuthPushModeVersion1",
    "serviceEndpoint": "http://auth.example.com/did:example:123456789abcdefg"
  }]
}
</pre>
      <p>
        <a>서비스 엔드포인트</a>에 대한 추가 보안 고려 사항은
        <a href="#did-method-schemes"></a> 및 <a href="#authentication"></a>을 참조
      </p>
      </section>

      <section id="created">
        <h2>
          생성
        </h2>

        <p>
          <a>DID 문서</a>에는 <code>created</code> 속성이 포함되어야 한다. 그렇다면:
        </p>

        <dl>
          <dt><dfn>created</dfn></dt>
          <dd>
            <code>created</code> 속성 값은 <a href="https://www.w3.org/TR/xmlschema11-2/">
              W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a>
            [[!XMLSCHEMA11-2]] 3.3.7장에 정의된 유효한 XML 날짜 및 시간이다.
            날짜 및 시간 값은 "Z" 끝나게 표시되는 UTC 00:00으로 정규화되어야 한다.
          </dd>
        </dl>

        <p>
          예제:
        </p>

        <pre class="example nohighlight">
{
  "created": "2002-10-10T17:00:00Z"
}
</pre>
      </section>

      <section id="updated">
        <h2>
          갱신
        </h2>

        <p>
          식별자 레코드의 표준 메타 데이터에는 가장 최근의 갱신에 대한 타임스탬프가 포함된다.
        </p>

        <p>
          <a>DID 문서</a>에는 <code>updated</code> 속성이 포함되어야 한다. 그렇다면:
        </p>

        <dl>
          <dt><dfn>updated</dfn></dt>
          <dd>
            <code>updated</code> 속성 값은 무조건 <code>created</code> 속성과 동일한
            규칙을 따른다 (<a href="#created"></a> 참조).
          </dd>
        </dl>

        <p>
          예제:
        </p>

        <pre class="example nohighlight">
{
  "updated": "2016-10-17T02:41:00Z"
}
</pre>
      </section>

      <section id="proof">
        <h2>
          증명 (Proof)
        </h2>

        <p>
          <a>DID 문서</a>의 <code>proof</code>은 다음 중 하나에 따라 <a>DID 문서</a>의 무결성을 증명하는 암호화 증명이다:
        </p>

        <ol start="1">
          <li>
            섹션 5.2 <a href="#did-subject"></a>에 정의 된 <a>DID 주체</a> 또는:
          </li>

          <li>
            <a href="#authorization-and-delegation"></a>에 정의 된 DID 컨트롤러 (있는 경우).
          </li>
        </ol>

        <p>
          이 증명은 <a>DID</a>와 <a>DID 문서</a>간의 연관성(binding) 대한 증명이 아니다 (섹션 <a
          href="#binding-of-identity"></a> 참조).
        </p>

        <p>
          <a>DID 문서</a>는 <code>proof</code> 속성을 포함 할 수 있다. 그렇다면:
        </p>

        <dl>
          <dt><dfn>proof</dfn></dt>
          <dd>
            <code>proof</code> 값은 무조건 링크 된 데이터 증명(<a href="https://w3c-dvcg.github.io/ld-signatures/">Linked Data
              Proofs</a>)에서 정의한 유효한 JSON-LD 증명이어야한다.
          </dd>
        </dl>

        <p>
          Example:
        </p>

        <pre class="example nohighlight" title="A signature-based proof">
{
  "proof": {
    "type": "LinkedDataSignature2015",
    "created": "2016-02-08T16:02:20Z",
    "creator": "did:example:8uQhQMGzWxR8vw5P3UWH1ja#keys-1",
    "signatureValue": "QNB13Y7Q9...1tzjn4w=="
  }
}
</pre>
      </section>

      <section id="extensibility">
        <h2>
          확장성 (Extensibility)
        </h2>

        <p>
          <a>탈중앙화 식별자</a> 데이터 모델의 목표 중 하나는 비허가형 혁신을 가능하게하는 것이다. 이를 위해서는 데이터 모델을 다양한 방법으로 확장 할 수 있어야 한다:
        </p>

        <ul>
          <li>
            The requirement to model complex multi-entity relationships is
            provided through the use of a graph-based data model.
          </li>

          <li>
            The requirement to enable extending the machine-readable
            vocabularies used to describe information in the data model &mdash;
            without relying on a centralized system &mdash; is accomplished via
            the use of [[LINKED-DATA]].
          </li>

          <li>
            The requirement to support multiple types of cryptographic proof
            formats is accomplished via the use of Linked Data Proofs
            [[LD-PROOFS]], Linked Data Signatures [[LD-SIGNATURES]], and a
            variety of signature suites.
          </li>

          <li>
            The requirement to provide all of the extensibility mechanisms
            outlined above in a data format that is popular among software
            developers and web page authors is enabled via the use of
            [[!JSON-LD]].
          </li>
        </ul>

        <p>
          This approach to data modeling is often called an "open world
          assumption", meaning that anyone can say anything about any other
          thing. This approach often feels in conflict with building simple
          and predictable software systems. Balancing extensibility with
          program correctness is always more challenging with an open world
          assumption than it is with closed software systems.
        </p>

        <p>
          The rest of this section describes how both extensibility and program
          correctness are achieved through a series of examples.
        </p>

        <p>
          다음과 같은 <a>DID 문서</a>로 시작한다고 가정 해 본다:
        </p>

        <pre class="example nohighlight" title="A simple DID document">
{
  "@context": "https://example.org/example-method/v1",
  "id": "did:example:123456789abcdefghi",
  "publicKey": [{ <span class="comment">...</span> }],
  "authentication": [{ <span class="comment">...</span> }],
  "service": [{ <span class="comment">...</span> }]
}
      </pre>
        <p>
          이 섹션에서는 <code>publicKey</code>, <code>authentication</code> 및 <code>service</code> 속성의 내용이 중요하지 않다. 중요한 것은 위의
          개체가 유효한 <a>DID 문서</a>라는 것이다. 개발자가 추가 정보를 표현하기 위해 <a>DID 문서</a>를 확장하고 싶다고 가정 하자. 추가정보는 피사체의 공개 사진 스트림이다.
        </p>

        <p>
          The first thing that a developer would do is create a JSON-LD Context
          containing the new term:
        </p>

        <pre class="example nohighlight" title="An example JSON-LD Context">
{
  "@context": {
    "PhotoStreamService": "https://example.com/vocab#PhotoStreamService"
  }
}
      </pre>
        <p>
          JSON-LD 컨텍스트가 생성되었으므로 개발자는 <a>DID 문서</a> 프로세서에 액세스 할 수있는 어떤 위치에 이를 무조건 게시해야한다. 예를 들어, 우리가 JSON-LD 컨텍스트 위의 다음
          URL에 게시되어 있다고 가정하자 :
          <code>did:example:contexts:987654321</code>. 이 시점에서이 섹션의 첫 번째 예제를 확장하는 것은 위의 컨텍스트를 포함하고 <a>DID 문서</a>에 새 속성을
          추가하는 간단한 문제이다.
        </p>

        <pre class="example nohighlight" title="A DID document with a custom extension">
{
  "@context": "https://example.org/example-method/v1",
  "id": "did:example:123456789abcdefghi",
  "authentication": [ <span class="comment">...</span> ],
  "service": [<span class="highlight">{
    "@context": "did:example:contexts:987654321",
    "id": "did:example:123456789abcdefghi#photos",
    "type": "PhotoStreamService",
    "serviceEndpoint": "https://example.org/photos/379283"
  }</span>]
}
      </pre>
        <p>
          지금까지의 예시에서는 <a>탈중앙화 식별자</a> 데이터 모델을 탈중앙화 방식으로 쉽게 확장 할 수 있음을 보여주었다. 또한 이 방식으로 생성 된 <a>탈중앙화 식별자</a>가 네임 스페이스 충돌
          및
          의미상 모호성을 방지한다.
        </p>

        <p>
          동적 확장성 모델은 구현 부담을 증가시킨다. 이러한 시스템 용으로 작성된 소프트웨어는 응용 프로그램의 위험 프로파일에 따라 확장명이 포함 된 <a>DID 문서</a>를 수락 할 수 있는지 여부를
          결정해야한다. 일부 응용 프로그램은 확장을 허용하지만 무시하도록 선택하고 다른 응용 프로그램은 특정 확장만 허용하도록 선택할 수 있지만 보안 수준이 높은 환경에서는 확장이 허용되지 않을 수 있다.
          이러한 결정은 응용 프로그램 개발자에게 달려 있으며 특히 이 사양의 영역이 아니다.
        </p>

        <p>
          Implementations MUST produce an error when an extension JSON-LD
          Context overrides the expanded URL for a term specified in this
          specification. To avoid the possibility of accidentally overriding
          terms, developers SHOULD scope their extensions. For example,
          the following extension scopes the new
          <code>PhotoStreamService</code> term so that it may only be used
          within the <code>service</code> property:
        </p>

        <pre class="example nohighlight" title="Scoping terms in a JSON-LD Context">
{
  "@context": {
    <span class="highlight">"service": {
      "@id": "https://w3id.org/did#service",
      "@context": {
        "PhotoStreamService": "https://example.com/vocab#PhotoStreamService"
      }
    }</span>
  }
}
      </pre>
        <p>
          Developers are urged to ensure that extension JSON-LD Contexts are
          highly available. Implementations that cannot fetch a context will
          produce an error. Strategies for ensuring that extension JSON-LD
          Contexts are always available include using content-addressed URLs
          for contexts, bundling context documents with implementations, or
          enabling aggressive caching of contexts.
        </p>
      </section>
    </section>
  </section>

  <section class="normative" id="did-document-syntax">
    <h1>
DID 문서의 문법
    </h1>

      <p>
<a>DID 문서</a>는 반드시 [[!RFC8259]] 규격을 따르는 하나의 JSON 객체여야만 한다. 
이 문서에서 설명하고 있는 많은 개념들은 JSON-LD 문법을 사용하는 예제를 활용하여 소개하고 있다. 
JSON-LD는 JSON 데이터를 RDF 의미 모형과 매핑하는 형식이며, [[!JSON-LD]] 규격에 정의되어 있다. 
이번 장에서는 데이터 모델(<a href="#data-model"></a>과 <a href="#did-documents"></a> 참조)이 
어떻게 JSON-LD로 나타나는지에 대해 명세한다.
      </p>
      <p>
비록 문법상의 매핑(syntactic mapping)이 JSON과 JSON-LD로만 제시된다 하더라도, 
응용프로그램과 서비스는 이와 다른 데이터 모델 표현 도구인 
JXD (JSON XDI Data, 
<a href="http://docs.oasis-open.org/xdi/xdi-core/v1.0/csd01/xdi-core-v1.0-csd01.xml">XDI 그래프 모델</a>을 위한 
직렬화 형식)나 XML, YAML, CBOR과 같이 
다양한 종류의 데이터 표현 문법을 사용할 수 있다.
      </p>

    <section>
      <h2>
        JSON
      </h2>

        <p>
데이터 모델(<a href="#data-model"></a> 참조)은 JSON(Javascript Object Notation, [[RFC8259]])으로 
인코딩될 수 있으며, 다음과 같이 속성값을 JSON 타입에 매핑한다:
        </p>

        <ul>
          <li>
IEEE754 표준과 같은 방식으로 기술한 숫자 값은 숫자 타입으로 표현해야 한다.
          </li>
          <li>
참과 거짓(boolean)으로 기술한 값은 불리언 타입으로 표현해야 한다.
          </li>
          <li>
열거된 값은 배열 타입으로 표현해야 한다.
          </li>
          <li>
순서없는 값의 집합은 배열 타입으로 표현해야 한다.
          </li>
          <li>
속성들의 집합은 객체(Object) 타입으로 표현해야 한다.
          </li>
          <li>
비어있는 값은 널(null)로 표현해야 한다.
          </li>
          <li>
이외의 나머지는 무조건 문자열 타입으로 표현해야 한다.
          </li>
        </ul>
    </section>

    <section>
      <h2>
        JSON-LD
      </h2>

        <p>
[[!JSON-LD]]는 JSON 기반의 형식이며, 
<a href="http://www.w3.org/TR/ld-glossary/#linked-data">연결 데이터(Linked Data)</a>를 직렬화하는데 사용한다. 
JSON-LD의 문법은 이미 JSON을 사용하고 있는 시스템에 쉽게 통합할 수 있도록 설계되었고, 
JSON에서 JSON-LD로의 업그레이드를 매끄럽게 할 수 있는 방법을 제공한다. 
웹 기반 프로그래밍 환경에서 연결 데이터를 사용할 수 있도록 하고, 
상호 운용 가능한 웹서비스를 만들 수 있도록 하며, 
연결 데이터를 JSON 기반 저장소 엔진에 저장하는데 주안점을 두고 있다.
        </p>

        <p>
JSON-LD는 이 명세서에서 설명하고 있는 데이터 모델을 확장할 때 유용하다. 
데이터 모델의 인스턴스는 JSON (<a href="#json"></a> 참조) 형식으로 인코딩되는 것과 같은 방식으로 
JSON-LD로 인코딩되며 <code>@context</code> 속성만 추가하면 된다. 
<a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD 컨텍스트</a>에 대한 
상세한 내용은 [[!JSON-LD]] 명세서에서 설명하고 있고, 
그 사용법은 <a href="#extensibility"></a> 섹션에서 자세히 다루고 있다.
        </p>

        <p>
일반적으로, 이 문서에서 설명하는 데이터 모델과 문법은 
개발자가 예제를 복사하여 자신들의 시스템에 붙여넣어 사용할 수 있도록 설계되었다. 
이러한 접근법을 선택하게 된 설계 목표는 서로 다른 소프트웨어 간에 
글로벌한 상호 운용성을 보장하기 위한 진입 장벽을 낮추는 것이다. 
이번 장에서는 이런 접근법 중 일부에 대해 설명할 것이다. 
이러한 접근법은 대부분의 개발자의 눈에는 잘 띄지 않지만 
구현자들은 관심을 가질 수 있는 상세한 내용이다. JSON-LD가 제공하는 주목할만한 기능은 다음과 같다:
        </p>

        <ul>
          <li>
<code>@id</code>와 <code>@type</code> 키워드는 각각 <code>id</code>와 <code>type</code>에 연결되며, 
개발자가 이 명세서를 관용적인 JSON으로 처리할 수 있도록 한다.
          </li>
          <li>
정수형이나 날짜, 측정 단위, URL과 같은 데이터 타입은 자동적으로 타입이 정해진다. 
그 이유는 그것을 요구하는 유즈 케이스에서 더 강력한 타입 보장을 지원하기 위함이다.
          </li>
          <li>
JSON-LD 1.1의 <code>@protected</code> 속성은 
이 명세서에 정의된 용어가 재정의되지 않도록 하는데 사용된다. 
즉, 같은 <code>@context</code> 선언이 <a>DID 문서</a>의 꼭대기에 존재하는 한, 
JSON-LD 프로세서를 사용하는 프로그램과 사용하지 않는 프로그램간에 상호 운용성이 보장된다.
          </li>
        </ul>
    </section>
  </section>

  <section id="did-methods">
    <h1>
      DID 메소드
    </h1>

    <section class="normative" id="did-method-schemes">
      <h2>
        DID 메소드 체계
      </h2>

      <p>
        <a>DID 메소드</a> 규격은 정확하게 메소드별 <a>DID 체계</a>마다 식별이 가능한 정확한 하나의 메소드 이름이 반드시 정의해야 한다. (<code>method-name</code> 규칙은
        <a href="#generic-did-syntax"></a>에 따른다)
      </p>

      <p>
        메소드 이름은 <a>DID</a>의 일부이므로, 짧은 메소드 이름이 선호된다. 메소드 이름은 5자 이하여야 한다. 메소드 이름은 <a>DID 메소드</a> 규격이 적용되는 <a>DID
          레지스트리</a>의 이름을 반영할 수 있다. (<a href="#unique-did-method-names"></a>.)
      </p>

      <p>
        메소드별 <a>DID 체계</a>를 위한 <a>DID 메소드</a> 규격에는 <a>DID</a>의 구성요소인 <code>method-specific-id</code>를 어떻게 생성하는지 반드시 명시가
        되어있어야 한다. <code>method-specific-id</code>는 반드시 중앙화 된 레지스트리 서비스를 이용하지 않고 생성할 수 있어야 한다.
        <code>method-specific-id</code>는 범용(범세계)적으로 고유해야 한다. <code>did</code> 규칙은 <a href="#generic-did-syntax"></a>에
        정의되어 있으며, 반드시 전세계적으로 고유해야 한다.
      </p>

      <p>
        필요하다면, 메소드별 <a>DID 체계</a>는 다수의 <code>method-specific-id</code> 형식을 정의할 수 있다. (하지만) 가능한 소수의
        <code>method-specific-id</code> 형식을 정의하는 것을 권장한다.
      </p>
    </section>

    <section id="did-operations">
      <h2>
        DID 기능
      </h2>

      <p>
        특정 <a>DID 레지스트리</a>에서 <a>DIDs</a> 및 <a>DID 문서</a>의 전체 기능을 사용하려면 클라이언트에 의해 수행되는 다음 <abbr
          title="Create, Read, Update, Delete">CRUD</abbr> 작업이 DID 메소드 규격에 반드시 지정되어 있어야 한다. 각 조작은 <a>DID 레지스트리</a>와 상호운용
        가능한 클라이언트 구현을 빌드하고 시험할 수준의 세부사항을 지정해야 할 필요가 있다. 이러한 조작은 CKMS(cryptographic key management system)에 필요한 모든 조작을
        효과적으로 수행할 수 있다. 예를 들면 키 등록, 키 교체, 키 회전(key rotation), 키 복구, 키 만료 들이다.
      </p>
      <p>
        업데이트 또는 비활성화와 같은 특정 작업을 지원하지 않는 <a>DID 메소드</a> 규격은 이러한 제한을 반드시 명확하게 명시해야 한다.
      </p>

      <section id="create">
        <h3>
          생성 (Create)
        </h3>

        <p>
          <a>DID 메소드</a> 규격은 클라이언트가 <a>DID</a> 및 관련 <a>DID 문서</a>를 <a>DID 레지스트리</a>에 어떻게 생성할지 명시해야 하며, 여기에는 제어증명 입증을 위한
          모든 암호화 작업이 포함된다.
        </p>
      </section>

      <section id="read-verify">
        <h3>
          읽기/검증 (Read/Verify)
        </h3>

        <p>
          <a>DID 메소드</a> 규격은 클라이언트가 <a>DID</a>를 사용하여 <a>DID 레지스트리</a>에 <a>DID 문서</a>를 요청하는 방법, 클라이언트가 응답의 진위를 확인할 수 있는
          방법을 반드시 명시해야 한다.
        </p>
      </section>

      <section id="update">
        <h3>
          갱신 (Update)
        </h3>

        <p>
          <a>DID 메소드</a> 규격은 클라이언트가 <a>DID 레지스트리</a>의 <a>DID 문서</a>를 갱신 할 수 있는 방법을 반드시 명시해야 한다. 여기에는 제어증명 입증을 위한 모든 암호화
          작업, <em>또는</em> 업데이트가 불가능하다는 상태가 포함된다.
        </p>
      </section>

      <section id="deactivate">
        <h3>
          비활성화 (Deactivate)
        </h3>

        <p>
          <a>DID 메소드</a> 규격은 클라이언트가 <a>DID 레지스트리</a>의 <a>DID</a>를 비활성화 할 수 있는 방법을 반드시 명시해야 한다. 여기에는 제어증명 입증을 위한 모든 암호화
          작업, <em>또는</em> 비활성화가 불가능하다는 상태가 포함된다.
        </p>
      </section>
    </section>

    <section class="informative" id="unique-did-method-names">
      <h2>
        고유한 DID 메소드 이름 (Unique DID Method Names)
      </h2>
      <p>
        새로운 <a>DID 메소드</a> 규격의 저자는 발표 당시 알려진 모든 <a>DID 메소드</a> 이름들과 중복되지 않는 고유한 메소드 이름을 사용해야만 한다.
      </p>
      <p>
        <a>DID 메소드</a> 이름을 할당하거나 승인 할 수 있는 권한을 가진 중앙기관이 없기 때문에 특정 <a>DID 메소드</a> 이름이 고유한 지 확인할 방법이 없다. 이 문제를 해결하기 위해 <a
          href="https://www.w3.org/community/credentials/">W3C Credentials Community Group</a>은 알려진 <a>DID 메소드</a> 이름과
        관련 규격의 비권한 목록을 유지한다(Appendix <a href="#registries"></a> 참조)
      </p>
      <p>
        [[DID-METHOD-REGISTRY]]는 새로운 메소드 명칭을 합의할 때 구현자가 참조 할 수 있는 도구이며, 또한 다른 <a>DID 메소드</a>의 <a>DID 리졸버</a>를 구현하는 소프트웨어
        개발자가 참조 할 수 있는 정보가 된다. 좀 더 많은 <a>DID 리졸버</a>에 대한 정보는 <a href="#did-resolvers"></a>을 참고 할 것.

        [[DID-METHOD-REGISTRY]]는 <a>DID 메소드</a>의 확정적 또는 공식적인 목록이 아니다. 그럼에도 불구하고, [[DID-METHOD-REGISTRY]]에 <a>DID 메소드</a>
        이름을 추가하여 다른 구현자와 커뮤니티 구성원이 기존 <a>DID 메소드</a>의 개요를 한곳에서 볼 수 있도록 하는 것을 장려한다. <a>DID 메소드</a> 이름을 추가하기 위한 간략한 기준은
        [[DID-METHOD-REGISTRY]]에 문서화되어 있다.
      </p>
    </section>

  </section>

  <section class='normative' id="did-resolvers">
    <h1>
DID 리졸버
    </h1>

    <p>
<a>DID 리졸버</a>는 <a>DID</a>를 해석하는데 필요한 API를 제공하는 
소프트웨어 또는 하드웨어를 말하며, 
DID 해석을 위해 DID는 하나 이상의 <a>DID 메소드</a>를 가져야한다. 
DID 리졸버는 믿을 만한(authoritative) <a>DID 문서</a>를 조회하기 위하여, 
해석하려는 <a>DID</a>와 연관된 <a>DID 메소드</a>의 읽기 명령을 수행한다.
더 자세한 내용은 <a href="#read-verify"></a> 참조.
    </p>

    <p>
<a>DID</a>를 해석하고 <a>DID URL</a>을 역참조하기 위한 
인터페이스와 알고리즘은 [[DID-RESOLUTION]]에 명시되어 있다.
    </p>

  </section>

  <section class="informative" id="security-considerations">
    <h1>
      보안 고려사항 (Security Considerations)
    </h1>

    <p class="note" title="개발자 참고사항">
      개발자의 초안 단계에서 이 장은 초기 구현에 중요한 보안 주제에 중점을 둔다.
      또한, 편집자들은 본 장 또는 사양의 다른 부분에 반영되어야만 하는 위협 및 위협 완화에
      대한 피드백을 탐색한다. <a>탈중앙 식별자</a>(DIDs) 및 <a>DID 문서</a>에 대한
      루트 식별자 레코드는 <a>탈중앙 ID 관리</a>의 필수 구성 요소이다. 또한 기존 X.509 인증서를
      보완하는 <a>탈중앙 공개키 인프라</a> (DPKI)의 기본 구성 요소이다. 따라서 <a>DID</a>는
      많은 IETF 표준에서 사용하는 일반적인 인터넷 위협 모델에서 작동하도록 설계되었다. 우리는
      침해되지 않는 엔드포인트를 가정하지만 네트워크상에서 메시지가 읽혀지거나, 손상될 수
      있음을 고려해야 한다. 시스템이 손상되었을 때 공격으로부터 보호하려면 외부 키 서명
      하드웨어가 필요하다. 키 폐기 및 복구에 관한 <a href="#key-revocation-and-recovery"></a>
      참조. <a>DID</a> 및 <a>DID 문서</a>를 호스팅하는 <a>DLT</a>에는 능동적인 공격을
      방지하기 위한 특별한 보안속성이 있다. 이 설계는 공개키 암호화를 사용하여 개인키가
      손상 될 위험없이 수동적으로 모니터링되는 네트워크에서 작동할 수 있다.
      이로 인하여 <a>DID</a> 아키텍처와 분산 ID를 가능하게 한다.
    </p>

    <section id="requirements-of-did-method-specifications">
      <h2>
        DID 메소드 사양의 요구 사항
      </h2>

      <p>
        <a>DID 메소드</a>의 요구사항 명세는 다음과 같다:
      </p>
      <ul>
        <li>
          <a>DID 메소드</a> 사양에는 무조건 자체 보안 고려 사항 항목이 포함되어야 한다.
        </li>

        <li>
          본 장은 무조건 [[RFC3552]] (27p) 5장 <a>DID</a> 연산에 언급된 모든 요구 사항을
          고려해야 한다. 특히:

          <p class="issue">
            차세대 Web of Trust 5에 대한 논의는 권한 부여를 DID 메소드 명세서로 이동하도록
            합의되었다. 현재 객체 기능을 기반으로 한 일반화된 권한 부여 메커니즘을 작성하려는
            시도가 기대된다.
          </p>

          <ul>
            <li>
              최소한 무조건 다음과 같은 형태의 공격을 고려해야만 한다:
              도청(eavesdropping), 재생(replay), 메시지 삽입(message insertion), 삭제(deletion),
              수정(modification), 중간자 공격(man-in-the-middle).
            </li>
            <li>
              또한 잠재적인 서비스 거부 공격(DoS)도 식별해야 한다.
            </li>
            <li>
              프로토콜에 암호화 보호 메커니즘이 통합된 경우 무조건 보호되는 데이터 부분과 보호 대상
              (즉, 무결성 전용, 기밀성 또는 엔드포인트 인증 등)이 명확하게 표시되어야 한다.
            </li>
            <li>
              암호학적 보호가 어떤 종류의 공격에 취약한지 작성해야 한다.
            </li>
            <li>
              비밀로 유지해야하는 데이터 (키 재료, 랜덤시드 등)는 명확하게 표시해야 한다.
            </li>
            <li>
              만일 본 기술에 인증, 특히 사용자-호스트 인증이 포함된 경우
              무조건 인증 방법의 보안을 명확하게 명시해야 한다.

            </li>
          </ul>
        </li>

        <li>
          또한 본 장은 [[RFC3552]] 5장에 따라 위협 완화가 전개 된 후의 잔류 위험
          (예를 들어 관련 프로토콜의 손상, 잘못된 구현 또는 암호)과 관련된 위험에 대해
          논의해야만 한다.
        </li>

        <li>
          본 장은 <a href="#did-operations"></a>에 요구된 필요한 모든 연산에 대하여
          무결성 보호 및 인증 업데이트를 제공해야 한다.
        </li>

        <li>
          <a>DID 메소드</a>가 P2P 컴퓨팅 리소스 (예를 들어 널리 알려진 <a>DLT</a>와 같은)를
          사용하는 경우 해당 리소스의 예상 부담은 서비스 거부(DoS)와 관련하여
          무조건 논의해야만 한다.
        </li>

        <li>
          메소드 별 엔드포인트 인증에 대해 무조건 논의해야 한다. <a>DID 메소드</a>가 다양한
          네트워크 토폴로지와 함께 <a>DLT</a>를 사용하거나 컴퓨팅 리소스를 줄이기 위해 <em>light node</em> 또는
          <em><a href="https://en.bitcoin.it/wiki/Thin_Client_Security">thin client</a></em>
          구현으로 제공되는 경우 <a>DID 메소드</a> 구현에 사용할 수 있는 토폴로지의 보안 가정을
          무조건 논의해야만 한다.
        </li>

        <li>
          <a>DID 메소드</a>은 <a>DID</a>가 고유하게 할당된 것이므로 할당된 정책 메커니즘을
          무조건 논의해야만 한다. <a>DID</a>는 [[RFC8141]]에 정의된 바와 같이 자원에 한 번만
          할당되고 다시 할당되지 않는 영구 식별자인 URN의 기능 정의에 적합하다.
          <a>DID</a>는 특정 권한 집합에 따라 특정 집단을 식별하는 데 사용될 수 있기 때문에
          보안 컨텍스트에서 특히 중요하다.
        </li>

        <li>
          새로운 인증 <a>서비스 엔드포인트</a> 유형을 소개하는
          <a>DID 메소드</a> (<a href="#service-endpoints"></a> 참조)는 지원되는
          인증 프로토콜의 보안 요구 사항을 고려해야 한다.
        </li>
      </ul>
    </section>

    <section id="choosing-did-resolvers">
      <h2>
        DID 리졸버 선택
      </h2>

      <p>
        [[DID-METHOD-REGISTRY]]는 <a>DID 메소드</a> 이름 및 해당 <a>DID 메소드</a> 사양에
        대한 정보를 제공하는 목록이다. 개발자는 특정 <a>DID 메소드</a> 이름과 함께
        사용해야하는 <a>DID 메소드</a> 사양을 위임 할 CA가 없다는 것을 알아두어야 하지만,
        <a>DID 메소드</a> 사양은 특정 <a>DID 메소드</a> 이름과 함께 사용해야 하고
        [[DID-METHOD-REGISTRY]]를 사용하여 사용할 <a>DID 리졸버</a> 구현을 선택할 때
        결정을 내릴 수 있다.

      </p>
    </section>

    <section id="binding-of-identity">
      <h2>
신원의 결합
      </h2>

      <p>
다음 섹션은 <a>DID</a>와 <a>DID 문서</a>에 신원을 결합하는 것에 대해 설명하고 있다.
      </p>

      <section>
        <h3>
DID와 DID 문서에 대한 컨트롤 증명하기
        </h3>

        <p>
서명은 <a>DID 문서</a>가 암호학적으로 검증 가능하도록 하는 하나의 수단이다.
        </p>

        <p>
<a>DID 문서</a>에 대한 검증된 서명 자체는 <a>DID</a>에 대한 컨트롤을 증명하지 못한다. 
그것은 단지 아래 내용만을 증명한다:
        </p>

        <ul>
          <li>
<a>DID 문서</a>는 그것이 등록된 이후 변조되지 않았다.
          </li>

          <li>
<a>DID 컨트롤러</a>는 서명이 생성된 시점의 서명을 위해 개인키를 컨트롤 했다.
          </li>
        </ul>

        <p>
<a>DID</a>의 컨트롤을 증명하는 것 즉, <a>DID</a>와 그것을 설명하는 <a>DID 문서</a> 사이를 결합하는 것은 다음 두 가지 과정을 필요로한다:
        </p>

        <ol start="1">
          <li>
<a>DID</a>를 <a>DID 메소드</a> 명세에 따라 주소분해 한다.
          </li>

          <li>
<a>DID 문서</a>의 <code>id</code> 프로퍼티가 주소분해된 <a>DID</a>와 일치하는지 검증한다.
          </li>
        </ol>

        <p>
주목해야 할 점은 이 과정이 <a>DID 문서</a>가 서명되었는지의 여부와 상관없이 <a>DID</a>와 <a>DID 문서</a>의 컨트롤을 증명한다는 점이다.
        </p>

        <p>
<a>DID 문서</a>에 대한 서명은 선택사항이다. 
만약 가능하다면, <a>DID 메소드</a> 명세는 그것의 구현에 대해 반드시 설명해 주어야 한다.
        </p>

        <p>
타임스탬프와 서명을 결합하는 것은 좋은 사례이다.
        </p>
      </section>

      <section>
        <h3>
공개키에 대한 컨트롤 증명하기
        </h3>

        <p>
<a>DID 문서</a>의 공개키에 대응하는 개인키의 증명에는 두가지 방법이 있다: 정적 그리고 동적. 
        </p>

        <p>
정적 방법은 <a>DID 문서</a>를 개인키로 서명하는 것이다.
이것은 <a>DID 문서</a>가 등록된 시점 까지의 개인키에 대한 컨트롤을 증명한다.
만약 <a>DID 문서</a>가 서명되지 않았다면, <a>DID 문서</a> 상의 공개키는 다음과 같은 동적 방법으로 증명할 수 있다:
        </p>

        <ol start="1">
          <li>
<a>DID 문서</a>의 <a>공개키 설명</a>(Description)을 포함한 신청 메세지를 보낸다.
그리고 <a>DID 문서</a>에 설명된 적절한 <a>서비스 엔드포인트</a>에 논스를 전달한다.
          </li>

          <li>
<a>공개키 설명</a>에 대한 반응 메세지의 서명을 검증한다.
          </li>
        </ol>
      </section>

      <section>
        <h3>
인증과 Verifiable Claim
        </h3>

        <p>
<a>DID</a>와 <a>DID 문서</a>는 <a href="https://en.wikipedia.org/wiki/Personally_identifiable_information">개인식별정보(PII)</a>를 포함하여 전달하지 않는다. 
<a>DID</a>와 사람 혹은 회사 같은 실 세계의 무언가와 결합하는 과정(예를들면, <a>DID</a>의 동일 주체에 대한 Credential)은 본 규격에서 다루지 않는다. 
더 상세한 내용은 [[VC-DATA-MODEL]]을 참고.
        </p>
      </section>
    </section>

    <section>
      <h2>
인증 서비스 엔드포인트
      </h2>

      <p>
만약 <a>DID 문서</a>가 <a>DID 주체</a>에 대한 인증 혹은 승인을 위한 <a>서비스 엔드포인트</a>를 발행했을 경우(섹션 <a href="#service-endpoints"></a> 참조), 
해당 <a>서비스 엔드포인트</a>에서 지원하는 인증 프로토콜의 요구사항을 만족시키는 것은 <a>서비스 엔드포인트</a>, 주체, 그리고 연계된 조직의 책임이다.
      </p>
    </section>

    <section>
      <h2>
부인방지
      </h2>

      <p>
<a>DID</a>와 <a>DID 문서</a>의 업데이트에 대한 부인 방지는 다음과 같은 가정 아래 지원된다:
      </p>

      <ul>
        <li>
주체는 승인되지 않은 업데이트에 대해 모니터링 한다. (섹션 <a href="#notification-of-did-document-changes"></a> 참조)
        </li>
        <li>
주체는 비정상적인 업데이트에 대해 <a>DID 메소드</a>의 접근관리 메커니즘을 통해 되돌릴 수 있는 충분한 기회를 가지고 있다. (섹션 <a href="#authentication"></a> 참조)
        </li>
        <ul>

      <p>
부인방지는 타임스탬프가 포함되고 (섹션 <a href="#created"></a> 및 <a href="#updated"></a> 참조), 대상 분산원장기술(DLT) 시스템이 타임스탬프를 지원하는 경우 더욱 보완된다.
      </p>
    </section>

    <section id="notification-of-did-document-changes">
      <h2>
DID 문서 변화 알림
      </h2>

      <p>
<a>DID 문서</a>의 승인되지 않은 변화에 대한 하나의 완화방안은 <a>DID 주체</a>를 모니터링하고 적극적으로 알리는 것이다.
이것은 전통적인 유저명/패스워드 계정의 계정 탈취를 막기 위해 패스워드 재설정에 대한 알림을 이메일 주소로 전달하는 것과 유사하다.
알림을 생성해 줄 중개 등록자 혹은 계정 공급자가 없는 <a>DID</a>의 경우, 다음과 같은 방법이 제안된다:
      </p>

      <ul>
        <li>
구독. <a>DID</a>가 등록된 <a>DID 레지스트리</a>가 변경 알림을 직접 지원하는 경우, 이 서비스는 <a>DID 컨트롤러</a>에게 제공될 수 있다. 
알림은 기존 <a>DID</a>에 나열된 서비스 엔트포인트로 직접 보낼 수 있다.
        </li>

        <li>
자기 모니터링. <a>DID 주체</a>는 정기적으로 <a>DID 문서</a>의 변화를 모니터링하는 로컬 혹은 온라인 상의 에이전트를 둘 수 있다.
        </li>

        <li>
3자 모니터링. <a>DID 주체</a>는 제 3의 모니터링 서비스에 의존할 수 있다. 다만, 이것은 또다른 공격 경로를 유발할 수 있다.
        </li>
      </ul>
    </section>

    <section id="key-and-signature-expiration">
      <h2>
        키 또는 서명 만료
      </h2>

      <p>
        <a>탈중앙 식별자</a> 아키텍처에는 키 또는 서명 만료 정책을 시행할 중앙 권한이 없다. 
        따라서 <a>DID 리졸버</a> 및 기타 클라이언트 프로그램은 키를 사용할 때 만료되지 않았는지 확인해야한다. 
        일부 사용 사례에는 이미 만료 된 키를 확장해야하는 합당한 이유가 있을 수 있으므로 만료가 되어도 키의 추가사용을 막지 않아야하며 
        리졸버를 구현할 때 이런 확장 기능을 호환가능하게 만들어야 한다.
      </p>
    </section>

    <section id="key-revocation-and-recovery">
      <h2>
        키 해지 및 복구
      </h2>

      <p>
        섹션 <a href="#did-operations"></a>은 업데이트 된 <a>DID 문서</a>로 교체하여 <a>DID 문서</a>를 비활성화 하는방법을 포함한 
        <a>DID 메소드</a> 사양에서 지원해야하는 <a>DID</a> 작업을 설명한다. 
        일반적으로 <a>DLT</a> 기반에서 키 해지여부 확인은 <a>분산 원장</a>에서 암호 화폐 게정의 잔액을 확인하는 것과 유사한 방식으로 처리 된다: 
        잔액이 비어있으면 <a>DID</a> 전체가 비활성화 된것이다. <a>DID 메소드</a> 사양은 신뢰하는 집단의 합의를 통해 키 복원을 지원해야한다. 
        그렇게 할 수 있는 방법들은 섹션 <a href="#authorization-and-delegation"></a>에 나와있다. 
        참고해야 할 것은 모든 <a>DID 메소드</a> 사양이 다른 <a>DID 메소드</a>를 사용하여 등록 된 <a>DID</a>의 제어를 인식하는 것은 아니며 
        타사 제어를 동일한 방법을 사용하는 <a>DID</a>로 제한 할 수 있다는 점이다. 
        <a>DID 메소드</a> 사양의 접근 제어 및 키 복구에는 복구를 위한 두번째 제어 권한을 유지하는 방식으로 키 손상을 일으키는 방식을 방지하는 
        시간 잠금 기능도 포함 될 수 있다. 이러한 유형의 제어에 대한 추가 사양은 향후 작업의 문제이다. 
        (섹션 <a href="#time-locks-and-did-document-recovery"></a> 참조)
      </p>
    </section>

    <section id="the-role-of-human-friendly-identifiers">
      <h2>
        인간 친화적 식별자의 역할
      </h2>

      <p>
        <a>DID들</a>은 중앙 등록 기관이 없어도 글로벌 독창성을 달성한다. 그러나 이것은 인간의 기억력을 희생시키면서 발생한다. 전역적으로 고유한 식별자를 생성 할 수 있는 알고리즘은 의미가없는 임의의
        문자열을 자동으로 생성한다. 이것은 Zooko의 Triangle(<a href="https://en.wikipedia.org/wiki/Zooko%27s_triangle">Zooko's
          Triangle</a>)으로 알려진 식별자에 대한 공리를 보여준다 : "의미, 탈중앙화, 안전. 셋 중 아무거나 둘을 선택하십시오".
      </p>

      <p>
        물론 인간 친화적인 식별자 (이메일 주소, Twitter 핸들 또는 블로그 URL등과 같은 <a>DID 컨트롤러</a>의 주소, 자연어 이름, 도메인 이름 또는 휴대 전화 번호)에서 시작할 때
        <a>DID</a>를 발견하는 것이 바람직한 많은 경우가 있다. 그러나 사람에게 친숙한 식별자를 <a>DID들</a>에 매핑 (및 확인 및 신뢰할 수있는 방식으로)하는 문제는 다른 이야기 이다.
      </p>

      <p>
        이 문제에 대한 해결책들은 여러가지 사양들 별로 별도의 정의가 필요하다. 정의시 다음과 같은 사양들을 신중하게 고려하는 것 이 좋다:
      </p>

      <ul>
        <li>
          대상 엔터티에 대한 사용자 친화적 식별자에 대해 믿을 수 없는 사용자들의 수많은 보안 공격
        </li>
        <li>
          본질적으로 연관 될 수 있는 사용자 친화적 식별자를 사용하는 경우의 개인 정보 보안, 특히 특정 정보 보안이 전 세계적으로 고유 한 정보 보안일 경우
        </li>
        <ul>

          <p class="note">
            DNS 조회를 사용하여 도메인 이름 및 전자 메일 주소에서 <a>DID</a>를 검색하기위한 초안 사양은 [[DNS-DID]]에 있다.
          </p>
    </section>

    <section id="immutability">
      <h2>
        불변성
      </h2>

      <p>
        많은 사이버 보안 침해는 현실과 합리적이고 선의의 이용자들의 이상 사이의 격차를 이용하는 데 달려 있다. 다른 생태계와 마찬가지로, <a>DID</a> 생태계는 이것이 일어날 가능성이 있다. 이 사양은
        프로토콜이 아닌 데이터 모델에 중점을 두기 때문에 해당 모델의 사용 방식에 대한 여러 측면에 대한 의견을 제시하지 않았다. 그러나 개별 <a>DID 메소드</a>들은 필요하지 않은 동작이나 의미를
        제거하는 제약 조건을 고려할 수 있다. <a>DID 메소드</a>가 <em>잠금</em>(<em>locked down</em>)상태 일수록 동일한 기능 세트를 제공하는 반면 악의적인 행위자가 조작 할
        수있는 수준은 줄어 든다.
      </p>
      <p>
        예를 들어, 데이터 모델이 업데이트와 관련하여 제공하는 유연성을 고려해보자. <a>DID 문서</a>를 한 번만 편집하면 문서의 루트 ID 속성을 제외한 모든 항목을 변경할 수 있으며 데이터 모델의
        개별 JSON 객체는 root <code>id</code>를 제외한 모든 속성을 변경할 수 있다. 그러나 <a>서비스 엔드포인트</a>가 일단 정의되면 <code>type</code>을 변경하는 것이
        실제로 바람직한가? 아니면 가치를 바꾸는 열쇠가 필요한가? 아니면 객체의 특정 기본 속성이 변경 될 때 새로운 <code>id</code>를 요구하는 것이 더 좋은가? 웹 사이트의 악의적인 인수는 종종
        사이트가 자신의 식별자 (호스트 이름)를 유지하지만 그 아래에 미묘하고 위험한 변화를 가져 오는 결과를 목표로 한다. 사양에 따라 사이트의 특정 속성을 변경할 수없는 경우 (예 : IP 주소와 관련된
        ASN) 이러한 공격을 수행하는 데 훨씬 더 어렵고 비용이 많이 들며 이상 탐지가 더 쉬울 수 있다.
      </p>
      <p>
        불변성이 일부 사이버 보안 이점을 제공 할 수 있다는 개념은 캐싱 때문에 특히 관련이 있다. 전 세계 진실 소스에 연결된 <a>DID 메소드</a>들의 경우 최신 버전의 <a>DID 문서</a>를
        적시에
        직접 조회 할 수 있다. 그러나 캐시 레이어는 결국 클라이언트와 해당 소스 사이에 있을 수 있다. 만약 그렇다면, 실제로 미묘하게 다른 <a>DID 문서</a>에있는 객체(object)의 속성이 주어진
        상태를 가지고 있다고 믿으면 활용을 증대 할 수 있습니다. 일부 조회가 전체 <a>DID 문서</a>이고 다른 조회가 부분적인 데이터 인 경우 더 큰 맥락이 가정되는 경우에 특히 그렇습니다.
    </section>

  </section>

  <section class="informative" id="privacy-considerations">
    <h1>
      프라이버시 고려사항
    </h1>

    <p>
      DIDs 및 DID 문서는 설계 상 <a> DID 컨트롤러</a>에 의해 직접 관리되므로, 
      프라이버시 디자인 (Privacy by Design) 원칙을 분산 식별자 아키텍처의 모든 측면에 적용하는 것이 매우 중요하다.
      추가적으로 프라이버시 보호를 권장하거나 적용할 등록 기관, 호스팅 회사 또는 기타 중간 서비스 제공 업체는 없다.
      이 규격의 저자는 개발 전반에 걸쳐 7가지 프라이버시 디자인(Privacy by Design) 원칙을 모두 적용했다.
      예를 들어, 이 규격에서 프라이버시는 예방적이지 교정적이지 않다. 프라이버시는 기본 설정이다. 
      또한 <a>decentralized identifier</a> 아키텍처 자체는 원칙 # 7, "Respect for user privacy — keep it user-centric."를 구현한다. 
      이 섹션에는 구현자(implementers), 대리인(delegates) 및 <a>DID 주체</a>가 염두에 두어야 할 추가 프라이버시 고려 사항이 나열되어 있다.
    </p>

    <section id="requirements-of-did-method-specifications">
      <h2>
        DID 메소드 규격의 요구사항
      </h2>

      <ol start="1">
        <li>
          이 섹션의 일반적인 프라이버시 고려사항만 가리키는 경우, 
          <a>DID 메소드</a> 규격에는 반드시 자체 프라이버시 고려사항 섹션이 포함되어야한다.
        </li>

        <li>
          <a>DID 메소드</a> 규격의 프라이버시 고려사항 섹션은 
          메소드에 따라 적용 할 수있는 [RFC6973]의 5 항의 하위 섹션을 반드시 논의해야한다. 
          고려해야 할 하위 섹션은 ‘감시, 저장된 데이터 손상, 원치 않는 트래픽, 
          잘못된 속성, 상관 관계, 식별, 2차 사용, 공개, 예외’가 있다.
        </li>
      </ol>
    </section>

    <section id="keep-personally-identifiable-information-(ppi)-private">
      <h2>
        개인 식별 정보 비공개 유지
      </h2>

      <p>
        <a>DID 메소드</a> 규격이 모든 <a>DIDs</a> 및 <a>DID 문서</a>를 공개적으로 사용할 수 있는 
        공개<a>DID 레지스트리</a>에 대해 작성된 경우, 
        <a>DID 문서</a>에 PII가 포함되지 않도록 하는 것은  매우 <em>중요하다</em>. 
        
        모든 PII는 <a>DID 주체</a>의 통제  하에 <a>서비스 엔드포인트</a> 뒤에서 유지되어야 한다. 
        
        With this privacy architecture, PII may be exchanged
        on a private, peer-to-peer basis using communications channels identified and
        secured by <a>public key descriptions</a> in <a>DID documents</a>. 
        
        이 프라이버시 설계를 통해, 
        PII는 <a>DID 문서</a>의 <a>공개키 설명</a>으로 식별되고 보안되는 통신 채널을 사용하여, 
        피어 투 피어 기반으로 교환 될 수 있다. 
        
        또한 이것은 불변의 분산 장부에 PII가 기록되지 않기 때문에, 
        <a>DID 주체</a>와 신뢰 당사자가 <a href="https://en.wikipedia.org/wiki/General_Data_Protection_Regulation">GDPR</a> 
        <a href="https://en.wikipedia.org/wiki/Right_to_be_forgotten">right
          to be forgotten</a>를 구현할 수 있다.
              </p>
    </section>

    <section id="did-correlation-risks-and-pseudonymous-dids">
      <h2>
        DID 상관 관계 위험과 유사 DIDs
      </h2>

      <p>
        모든 유형의 전역적 고유 식별자와 마찬가지로, <a>DIDs</a> 상관 관계에 사용할 수 있다.
        <a>DID 컨트롤러</a>는 쌍으로 된 고유한 <a>DIDs</a> 사용하거나, 
        모든 관계에 대해 다른 개인용 <a>DID</a>를 공유함으로써 프라이버시 위험을 완화할 수 있다. 
        실제로 각 <a>DID</a>는 익명으로 사용된다.
        익명 <a>DID</a>는 <a>DID 주체</a>가 당사자 간의 상관 관계를 명시적으로 승인한 경우 둘 이상의 당사자끼리만 공유하면 된다. 
        익명 <a>DIDs</a>가 기본 값일 때, 공개 <a>DIDs</a> (공개적으로 발행되었거나 다수의 당사자와 공유된 <a>DIDs</a>)가 
        필요한 경우는 <a>DID 주체</a>가 명시적으로 공개 식별을 원할 때 뿐이다.
      </p>
    </section>

    <section id="did-document-correlation-risks">
      <h2>
        DID 문서 상관 관계 위험
      </h2>

      <p>
        해당 <a>DID 문서</a>의 데이터를 연관시킬 수 있으면 익명 <a>DIDs</a>의 안티-상관관계 보호는 쉽게 무너진다. 
        예를 들어, 여러 <a>DID 문서</a>에서 동일한 <a>공개키 설명</a> 또는 
        맞춤형 <a>서비스 엔드포인트</a>를 사용하면 동일한 <a>DID</a>를 사용하는 것과 같은 수준의 상관 정보를 제공 할 수 있다.
        따라서 익명 <a>DID</a>에 대한 <a>DID 문서</a>도 쌍별로 고유한 공개 키를 사용해야 한다. 
        익명 <a>DID</a>에 대해 <a>DID 문서</a>에서 쌍별로 고유한 <a>서비스 엔드포인트</a>를 사용하는 것도 자연스러운 것처럼 보일 수 있다. 
        그러나 고유한 엔드 포인트를 통해 <a>DIDs</a> 간 모든 트래픽을 
        타이밍 상관 관계와 유사한 분석이 용이한 고유한 버킷으로 완벽하게 분리할 수 있다.
        따라서 엔드 포인트 프라이버시를 위한 더 나은 전략은 많은 다른 주체에 의해 제어되는 
        수천 또는 수백만 개의 <a>DIDs</a> 간에 엔드 포인트를 공유하는 것이다.
      </p>
    </section>

    <section id="herd-privacy">
      <h2>
        군중 프라이버시
      </h2>

      <p>
        <a>DID 주체</a>가 군중의 다른 사람들과 구별되지 않는 경우, 프라이버시 보호가 가능하다. 
        다른 당사자와 개인적으로 참여하는 행위가 그 자체로 인식 가능한 플래그(flag)인 경우, 프라이버시가 크게 훼손된다.
        <a>DIDs</a>와 <a>DID 메소드</a>는 군중 프라이버시의 보호, 
        특히 합법적으로 가장 필요한 사람들의 프라이버시를 개선하기 위해 작동해야한다. 
        익명성과 가명성을 유지하는 데 도움이 되는 기술과 휴먼 인터페이스를 선택해야 한다. 
        <a href="https://en.wikipedia.org/wiki/Device_fingerprint">디지털 지문</a>을 줄이려면, 
        클라이언트 구현에서 공통 설정을 공유하고, 협의된 옵션을 유선 프로토콜에서 최소로 유지하고, 암호화 된 전송 계층을 사용하고, 메시지를 표준 길이로 채워야 한다.
      </p>
    </section>
  </section>

  <section class="informative">
    <h1>
      Future Work
    </h1>

    <section>
      <h2>
        Upper Limits on DID Character Length
      </h2>

      <p>
        The current specification does not take a position on maximum length
        of a <a>DID</a>. The maximum interoperable URL length is currently about 2K
        characters. QR codes can handle about 4K characters. Clients using
        <a>DIDs</a> will be responsible for storing many <a>DIDs</a>, and some methods
        would be able to externalize some of their costs onto clients by
        relying on more complicated signature schemes or by adding state into
        <a>DIDs</a> intended for temporary use. A future version of this
        specification should set reasonable limits on <a>DID</a> character length to
        minimize externalities.
      </p>
    </section>

    <section>
      <h2>
        Equivalence
      </h2>

      <p>
        Including an equivalence property, such as <code>equivID</code>, in <a>DID documents</a>
        whose value is an array of <a>DIDs</a> would allow subjects to assert two or
        more <a>DIDs</a> that represent the same subject. This capability has
        numerous uses, including supporting migration between <a>DID registries</a> and
        providing forward compatibility of existing <a>DIDs</a> to future <a>DID
          registries</a>. In
        theory, equivalent <a>DIDs</a> should have the same identifier rights,
        allowing <a href="https://w3c.github.io/vctf/">verifiable claims</a>
        made against one <a>DID</a> to apply to equivalent <a>DIDs</a>. Equivalence was not
        included in the current specification due to the complexity of
        verifying equivalence across different <a>DLTs</a> and different <a>DID
          methods</a>, and also of aggregating properties of equivalent <a>DID
          documents</a>. However equivalence should be supported in a future
        version of this specification.
      </p>
    </section>

    <section>
      <h2>
        Timestamps
      </h2>

      <p>
        Verifiable timestamps have significant utility for identifier
        records. This is a good fit for <a>DLTs</a>, since most offer some type of
        timestamp mechanism. Despite some transactional cost, they are the
        most censorship-resistant transaction ordering systems in the world,
        so they are nearly ideal for <a>DID document</a> timestamping. In some cases
        a <a>DLT</a>'s immediate timing is approximate, however their sense of
        <a href="https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki%23Abstract">
          "median time past" (see Bitcoin BIP 113)</a> can be precisely
        defined. A generic <a>DID document</a> timestamping mechanism could would
        work across all <a>DLTs</a> and might operate via a mechanism including
        either individual transactions or transaction batches. The generic
        mechanism was deemed out of scope for this version, although it may
        be included in a future version of this specification.
      </p>
    </section>

    <section>
      <h2>
        Time Locks and DID Document Recovery
      </h2>

      <p>
        Section <a href="#key-revocation-and-recovery"></a> mentions one
        possible clever use of time locks to recover control of a <a>DID</a> after a
        key compromise. The technique relies on an ability to override the
        most recent update to a <a>DID document</a> with Authorization applied by an
        earlier version of the <a>DID document</a> in order to defeat the attacker.
        This protection depends on adding a <a
          href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki%23Abstract">
          time lock (see Bitcoin BIP 65)</a> to protect part of the transaction
        chain, enabling a Authorization block to be used to recover control.
        We plan to add support for time locks in a future version of this
        specification.
      </p>
    </section>

    <section>
      <h2>
        Smart Signatures
      </h2>

      <p>
        Not all <a>DLTs</a> can support the Authorization logic in section
        <a href="#authorization-and-delegation"></a>.
        Therefore, in this version of the specification, all Authorization
        logic is delegated to <a>DID method</a> specifications. A potential
        future solution is a <a href="http://www.weboftrust.info/downloads/smart-signatures.pdf">Smart
          Signature</a> specification that specifies the code any conformant
        <a>DLT</a> may implement to process signature control logic.
      </p>
    </section>

    <section>
      <h2>
        Verifiable Claims
      </h2>

      <p>
        Although <a>DIDs</a> and <a>DID documents</a> form a foundation for decentralized
        identity, they are only the first step in describing their subjects. The
        rest of the descriptive power comes through collecting and
        selectively using <a href="https://w3c.github.io/vctf/">verifiable
          claims</a>. Future versions of the specification will describe in
        more detail how <a>DIDs</a> and <a>DID document</a> can be integrated with &mdash; and help
        enable &mdash; the verifiable claims ecosystem.
      </p>
    </section>

    <section>
      <h2>
        Alternate Serializations and Graph Models
      </h2>

      <p>
        This version of the specification relies on JSON-LD and the RDF graph
        model for expressing a <a>DID document</a>. Future versions of this
        specification might specify other semantic graph formats for a <a>DID
          document</a>.
      </p>
    </section>
  </section>

  <section class="appendix" id="current-issues">
    <h1>현재 이슈</h1>

    <p>
      현재 활발하게 논의되고 있고 이 규격에 변화를 줄 수 있는 이슈사항들의 목록이다.
    </p>

    <div class="issue" data-number="85">Syntactially differentiate data about the DID versus application data</div>
    <div class="issue" data-number="84">Add `initial-values` matrix parameter to Generic DID Parameters</div>
    <div class="issue" data-number="80">Define conformance classes such as "DID document processor"</div>
    <div class="issue" data-number="76">Bikeshed the DID specification short name</div>
    <div class="issue" data-number="75">tracking revocation of public keys</div>
    <div class="issue" data-number="72">Privacy Considerations - Specifically call out GDPR</div>
    <div class="issue" data-number="70">Enable instant DID use/resolution for DID Methods that include a propagation
      delay</div>
    <div class="issue" data-number="69">How to integrate certificates with DIDs?</div>
    <div class="issue" data-number="68">When do we publish a FPWD?</div>
    <div class="issue" data-number="67">Supported public key formats?</div>
    <div class="issue" data-number="65">Does DID Document metadata belong in the Document?</div>
    <div class="issue" data-number="64">Encrypted serviceEndpoint values?</div>
    <div class="issue" data-number="63">Add publicKeyHex as a valid publicKey format</div>
    <div class="issue" data-number="62">Add "service-type" DID URL matrix parameter.</div>
    <div class="issue" data-number="61">Add "content-type" and "content-id" DID URL matrix parameters.</div>
    <div class="issue" data-number="60">Add "key-type" DID URL matrix parameter.</div>
    <div class="issue" data-number="59">Add "key" DID URL matrix parameter.</div>
    <div class="issue" data-number="58">Registry handling</div>
    <div class="issue" data-number="57">Clarification of other verification methods in authentication section missing
    </div>
    <div class="issue" data-number="56">Added support for ethereumAddress in context - fixed #55</div>
    <div class="issue" data-number="55">Add support for ethereumAddress public key type in @context</div>
    <div class="issue" data-number="53">Normative vs. non-normative references</div>
    <div class="issue" data-number="52">(Minor note) update the IANA file</div>
    <div class="issue" data-number="51">[Convention] Method `0` (zero) become a well-known method for retrieving
      properties/metadata from/about a particular DID Server</div>
    <div class="issue" data-number="49">If an existing DID Document has a Service Endpoint fragment, what are the
      primary keys to be used if that Service Endpoint needs to be replaced, updated, or deleted?</div>
    <div class="issue" data-number="48">Some comments by Steven Rowat</div>
    <div class="issue" data-number="46">It would be useful to have `services` as a mapping instead of an `array`</div>
    <div class="issue" data-number="45">Is method-specific-id supposed to be equivalent to param-char?</div>
  </section>

  <section class="appendix" id="registries">
    <h1>
      레지스트리
    </h1>

    <p>
      이 규격을 바탕으로 <a>DID 메소드</a>를 정의하는 다수의 레지스트리들이 있다. 그 목록은 다음과 같다:
    </p>

    <table class="simple">
      <thead>
        <tr>
          <th>
            레지스트리
          </th>
          <th>
            목적
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            <a href="https://w3c-ccg.github.io/did-method-registry/">DID
              메소드 레지스트리</a>
          </td>
          <td>
            모든 <a>DID 메소드</a>들과 그들의 상세 규격에 대한 목록
          </td>
        </tr>

        <tr>
          <td>
            <a href="https://w3c-ccg.github.io/ld-cryptosuite-registry/">Linked Data
              Cryptography Suite Registry</a>
          </td>
          <td>
            알려진 모든 Linked Data Cryptography Suites와 Key Format을 정의
          </td>
        </tr>
      </tbody>
    </table>
  </section>

  <section class="appendix" id="real-world-example">
    <h1>
      실사용 예제
    </h1>

    <p>
      미래지향적 실사용 예제는 다음과 같다:
    </p>

    <pre class="example nohighlight" title="Advanced DID document example">
{
  "@context": "https://w3id.org/future-method/v1",
  "id": "did:example:123456789abcdefghi",

  "publicKey": [{
    "id": "did:example:123456789abcdefghi#keys-1",
    "type": "RsaVerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }, {
    "id": "did:example:123456789abcdefghi#keys-3",
    "type": "Ieee2410VerificationKey2018",
    "controller": "did:example:123456789abcdefghi",
    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"
  }],

  "authentication": [
    <span class="comment">// this mechanism can be used to authenticate as did:...fghi</span>
    "did:example:123456789abcdefghi#keys-1",
    <span class="comment">// this mechanism can be used to biometrically authenticate as did:...fghi</span>
    "did:example:123456789abcdefghi#keys-3",
    <span class="comment">// this mechanism is *only* authorized for authentication, it may not</span>
    <span class="comment">// be used for any other proof purpose, so its full description is</span>
    <span class="comment">// embedded here rather than using only a reference</span>
    {
      "id": "did:example:123456789abcdefghi#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:example:123456789abcdefghi",
      "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
    }
  ],

  "service": [{
    "id": "did:example:123456789abcdefghi#oidc",
    "type": "OpenIdConnectVersion1.0Service",
    "serviceEndpoint": "https://openid.example.com/"
  }, {
    "id": "did:example:123456789abcdefghi#vcStore",
    "type": "CredentialRepositoryService",
    "serviceEndpoint": "https://repository.example.com/service/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#xdi",
    "type": "XdiService",
    "serviceEndpoint": "https://xdi.example.com/8377464"
  }, {
    "id": "did:example:123456789abcdefghi#hub",
    "type": "HubService",
    "serviceEndpoint": "https://hub.example.com/.identity/did:example:0123456789abcdef/"
  }, {
    "id": "did:example:123456789abcdefghi#messaging",
    "type": "MessagingService",
    "serviceEndpoint": "https://example.com/messages/8377464"
  }, {
    "type": "SocialWebInboxService",
    "id": "did:example:123456789abcdefghi#inbox",
    "serviceEndpoint": "https://social.example.com/83hfh37dj",
    "description": "My public social inbox",
    "spamCost": {
      "amount": "0.50",
      "currency": "USD"
    }
  }, {
    "type": "DidAuthPushModeVersion1",
    "id": "did:example:123456789abcdefghi#push",
    "serviceEndpoint": "http://auth.example.com/did:example:123456789abcdefghi"
  }, {
    "id": "did:example:123456789abcdefghi#bops",
    "type": "BopsService",
    "serviceEndpoint": "https://bops.example.com/enterprise/"
  }]
}
</pre>
  </section>
  <section id="conformance"></section>

</body>

</html>
